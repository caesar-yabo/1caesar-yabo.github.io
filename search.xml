<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>my-first-blog</title>
    <url>/2020/04/07/blog_next_settings/</url>
    <content><![CDATA[<h1 id="首页只显示文章的标题和描述。"><a href="#首页只显示文章的标题和描述。" class="headerlink" title="首页只显示文章的标题和描述。"></a>首页只显示文章的标题和描述。</h1><p>在Next 主题下，设置首页不显示文章全文(只显示预览)。</p>
<p>进入 hexo/themes/next/_config.yml 文件， 搜索 “auto_excerpt”,找到如下部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto_excerpt:</span><br><span class="line">  enable: false</span><br><span class="line">  length: 150</span><br></pre></td></tr></table></figure>

<p>把 false 改为 true即可。</p>
]]></content>
      <categories>
        <category>软件安装设置</category>
      </categories>
      <tags>
        <tag>next主题</tag>
      </tags>
  </entry>
  <entry>
    <title>category_test</title>
    <url>/2020/04/07/category-test/</url>
    <content><![CDATA[<p>测试分类怎么分</p>
<p>测试分类怎么分</p>
<p>测试分类怎么分</p>
<p>测试分类怎么分</p>
<p>测试分类怎么分</p>
]]></content>
      <categories>
        <category>目标检测</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/04/07/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>3. Longest Substring Without Repeating Characters</title>
    <url>/2020/04/07/LeetCode_Cpp/0003._Longest_Substring_Without_Repeating_Characters/</url>
    <content><![CDATA[<h1 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3. Longest Substring Without Repeating Characters"></a>3. Longest Substring Without Repeating Characters</h1><p>难度:Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-substring-without-repeating-characters/description/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Given a string, find the length of the longest substring without repeating characters.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: &quot;abcabcbb&quot;</span><br><span class="line">Output: 3 </span><br><span class="line">Explanation: The answer is &quot;abc&quot;, with the length of 3. </span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: &quot;bbbbb&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The answer is &quot;b&quot;, with the length of 1.</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: &quot;pwwkew&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;wke&quot;, with the length of 3. </span><br><span class="line">             Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</span><br></pre></td></tr></table></figure>

<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1<br><strong>**</strong>- 时间复杂度: O(NlgN)<strong>**</strong>- 空间复杂度: O(N)<strong>**</strong></p>
</blockquote>
<p>用 map储存 key为字符，value 为这个字符的位置，我们可以维护一个子字符串(无重复字符)，记录它的起始位置，遍历 string s 当无法在map中找到字符或者小于子字符串的起始位置，就是没有在这个字符串中出现，反之则字符重复，不过 map查找为 O(lgn)，因此总的时间复杂度为O(NlgN)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">int</span> beg = <span class="number">0</span>,length = s.length(),ll = <span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m.find(s[i]) == m.end() || m[s[i]] &lt; beg)</span><br><span class="line">            ll++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = m[s[i]];</span><br><span class="line">            ans = max(ll,ans);</span><br><span class="line">            ll = ll - (pos - beg);</span><br><span class="line">            beg = pos + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m[s[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = max(ans,ll);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路 2<br><strong>**</strong>- 时间复杂度: O(NlgN)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>这个思路和上面差不多，用到了一个小窍门，因为储存的是字符，char为8位，因此能储存的最大数为256，这样空间复杂度就为O(1)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">256</span>;++i)</span><br><span class="line">        m[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> beg = <span class="number">0</span>,length = s.length(),ll = <span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m[s[i]] &lt; beg)</span><br><span class="line">            ll++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = m[s[i]];</span><br><span class="line">            ans = max(ll,ans);</span><br><span class="line">            ll = ll - (pos - beg);</span><br><span class="line">            beg = pos + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m[s[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = max(ans,ll);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>2. Add Two Numbers</title>
    <url>/2020/04/07/LeetCode_Cpp/0002._Add_Two_Numbers/</url>
    <content><![CDATA[<h1 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2. Add Two Numbers"></a>2. Add Two Numbers</h1><p>难度:Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/add-two-numbers/description/" target="_blank" rel="noopener">https://leetcode.com/problems/add-two-numbers/description/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定两个链表代表两个非负数，求这两个数的和</span><br><span class="line">(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">因为 342 + 465 &#x3D; 807</span><br><span class="line">所以返回 7 -&gt; 0 -&gt; 8</span><br></pre></td></tr></table></figure>

<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路</p>
</blockquote>
<p>这题的的关键在于链表的数储存是倒序的，因此只要从链表头相加，再将所得数挨个储存即可，但是要注意两数相加有可能大于10要进一位。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">	ListNode* current;</span><br><span class="line">	ListNode* ret = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(l1 &amp;&amp; l2)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = l1 -&gt;val + l2 -&gt;val + num;</span><br><span class="line">		ListNode* node = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">		num = sum / <span class="number">10</span>;</span><br><span class="line">		ret ? current -&gt;next = node : ret = node;</span><br><span class="line">		current = node;</span><br><span class="line">		l1 = l1 -&gt;next;</span><br><span class="line">		l2 = l2 -&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(l2)</span><br><span class="line">		l1 = l2;</span><br><span class="line">	<span class="keyword">while</span>(l1)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = num + l1 -&gt;val;</span><br><span class="line">		ListNode* node = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">		num = sum / <span class="number">10</span>;</span><br><span class="line">		current -&gt;next = node;</span><br><span class="line">		current = node;</span><br><span class="line">		l1 = l1 -&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(num)</span><br><span class="line">	&#123;</span><br><span class="line">		ListNode* node = <span class="keyword">new</span> ListNode(num);</span><br><span class="line">		current -&gt;next = node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>1.Two Sum</title>
    <url>/2020/04/07/LeetCode_Cpp/0001._two_sum/</url>
    <content><![CDATA[<h1 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a>1. Two Sum</h1><p>难度: Easy</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/two-sum" target="_blank" rel="noopener">https://leetcode.com/problems/two-sum</a><ul>
<li><a href="https://leetcode-cn.com/problems/two-sum/description" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum/description</a><blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line"> 因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
</li>
<li><strong><strong><em>- 时间复杂度: O(NlgN)*</em></strong></strong>- 空间复杂度: O(N)<strong>**</strong><br>采用双指针法，先将数组排序形成了一个有序的区间，指针i，j分别指向头尾，<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当 nums1[i] + nums[j] &gt; traget 时，j--，</span><br><span class="line">nums[i] + nums[j] &lt; target 时，i++，</span><br><span class="line">直到 nums[i] + nums[j] &#x3D;&#x3D; target</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; nums1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.size();++i)</span><br><span class="line">            nums1.push_back(make_pair(nums[i],i));</span><br><span class="line">        sort(nums1.begin(),nums1.end());</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j = nums1.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i].first + nums1[j].first == target)</span><br><span class="line">            &#123;</span><br><span class="line">                ret.push_back(nums1[i].second);</span><br><span class="line">                ret.push_back(nums1[j].second);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">            nums1[i].first +nums1[j].first &lt; target ? ++i : --j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路 2</p>
</blockquote>
</li>
<li><strong><strong><em>- 时间复杂度: O(N)*</em></strong></strong>- 空间复杂度: O(N)<strong>**</strong><br>c++中提供了 unordered_map 的容器，unordered_map 中的元素没有按照它们的键值或映射值的任何顺序排序，<br>而是根据它们的散列值组织成桶以允许通过它们的键值直接快速访问单个元素（具有常数平均时间复杂度）<br>将先出现的元素储存在 unorder_map 中，遍历数组，每次查找 target - nums[i] 是否存在即可。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            m[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (m.count(t) &amp;&amp; m[t] != i) &#123;</span><br><span class="line">                res.push_back(i);</span><br><span class="line">                res.push_back(m[t]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>6. ZigZag Conversion</title>
    <url>/2020/04/07/LeetCode_Cpp/0006._ZigZag%20_Conversion/</url>
    <content><![CDATA[<h1 id="6-ZigZag-Conversion"><a href="#6-ZigZag-Conversion" class="headerlink" title="6. ZigZag Conversion"></a>6. ZigZag Conversion</h1><p>难度:Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<p>*<a href="https://leetcode.com/problems/zigzag-conversion/description/" target="_blank" rel="noopener">https://leetcode.com/problems/zigzag-conversion/description/</a></p>
<ul>
<li><blockquote>
<p>内容描述</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The string &quot;PAYPALISHIRING&quot; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</span><br><span class="line"></span><br><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br><span class="line">And then read line by line: &quot;PAHNAPLSIIGYIR&quot;</span><br><span class="line"></span><br><span class="line">Write the code that will take a string and make this conversion given a number of rows:</span><br><span class="line"></span><br><span class="line">string convert(string s, int numRows);</span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: s &#x3D; &quot;PAYPALISHIRING&quot;, numRows &#x3D; 3</span><br><span class="line">Output: &quot;PAHNAPLSIIGYIR&quot;</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: s &#x3D; &quot;PAYPALISHIRING&quot;, numRows &#x3D; 4</span><br><span class="line">Output: &quot;PINALSIGYAHRPI&quot;</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure>

<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路1<br><strong>**</strong>- 时间复杂度: O(N)<strong>**</strong>- 空间复杂度: O(N + numRows)<strong>**</strong></p>
</blockquote>
<p>这道题理解了题目意思其实不难，一般人可能会开一个二维数组，然后就按题目意思储存，这样做的话时间复杂度和空间复杂度都比较大，这里我用的方法先用一个 string 类型变量 str ，resize 和输入的 s 长度相等，接着只要遍历找到 s[i] 在 str 中的位置即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">         <span class="built_in">string</span> newStr;</span><br><span class="line">    <span class="keyword">if</span>(!s.length() || numRows == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    newStr.resize(s.length());</span><br><span class="line">    <span class="keyword">int</span> num = numRows * <span class="number">2</span> - <span class="number">2</span>,col = s.length() / num,rem = (s.length() - <span class="number">1</span>) % num;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rowNum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; numRows;++i)</span><br><span class="line">        <span class="keyword">if</span>(!i)</span><br><span class="line">            s.length() % num ? rowNum.push_back(col + <span class="number">1</span>) : rowNum.push_back(col);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == numRows - <span class="number">1</span>)</span><br><span class="line">                rem &gt;= i ? rowNum.push_back(rowNum[i - <span class="number">1</span>] + (s.length() - <span class="number">1</span>) / num + <span class="number">1</span>) : rowNum.push_back(rowNum[i - <span class="number">1</span>] + (s.length() - <span class="number">1</span>) / num);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = <span class="number">2</span> * numRows - i - <span class="number">2</span>,col1 = (s.length() - <span class="number">1</span>) / num;</span><br><span class="line">                <span class="keyword">if</span>(rem &gt;= temp)</span><br><span class="line">                    rowNum.push_back(rowNum[i - <span class="number">1</span>] + (col1 + <span class="number">1</span>) * <span class="number">2</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(rem &gt;= i)</span><br><span class="line">                    rowNum.push_back(rowNum[i - <span class="number">1</span>] + col1 * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    rowNum.push_back(rowNum[i - <span class="number">1</span>] + col1 * <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> index1 = i % num;</span><br><span class="line">        <span class="keyword">int</span> index2 = i / num;</span><br><span class="line">        <span class="keyword">if</span>(!index1)</span><br><span class="line">            newStr[index2] = s[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(index1 == numRows - <span class="number">1</span>)</span><br><span class="line">            newStr[index2 + rowNum[index1 - <span class="number">1</span>]] = s[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(index1 &lt; numRows)</span><br><span class="line">            newStr[index2 * <span class="number">2</span> + rowNum[index1 - <span class="number">1</span>]] = s[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> index3 = <span class="number">2</span> * numRows - index1 - <span class="number">2</span>;</span><br><span class="line">            newStr[index2 * <span class="number">2</span> + <span class="number">1</span> + rowNum[index3 - <span class="number">1</span>]] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>7. Reverse Integer</title>
    <url>/2020/04/07/LeetCode_Cpp/0007._Reverse_Integer/</url>
    <content><![CDATA[<h1 id="7-Reverse-Integer"><a href="#7-Reverse-Integer" class="headerlink" title="7. Reverse Integer"></a>7. Reverse Integer</h1><p><strong><font color=red>难度:Easy<font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/reverse-integer/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-integer/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a 32-bit signed integer, reverse digits of an integer.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 123</span><br><span class="line">Output: 321</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: -123</span><br><span class="line">Output: -321</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: 120</span><br><span class="line">Output: 21</span><br><span class="line">Note:</span><br><span class="line">Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [?231,  231 ? 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路1<br><strong>**</strong>- 时间复杂度: O(n)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>一道easy的题目，依次计算各个位的数。不过要注意超出int的范围。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> </span><br><span class="line">        &#123;</span><br><span class="line">            val = val * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (x);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (val &gt; INT_MAX || val &lt; INT_MIN) ? <span class="number">0</span> : val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>4. Median of Two Sorted Arrays</title>
    <url>/2020/04/07/LeetCode_Cpp/0004.%20_Median_of_Two_Sorted_Arrays/</url>
    <content><![CDATA[<h1 id="4-Median-of-Two-Sorted-Arrays"><a href="#4-Median-of-Two-Sorted-Arrays" class="headerlink" title="4. Median of Two Sorted Arrays"></a>4. Median of Two Sorted Arrays</h1><p>难度:Hard</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/submissions/" target="_blank" rel="noopener">https://leetcode.com/problems/median-of-two-sorted-arrays/submissions/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">There are two sorted arrays nums1 and nums2 of size m and n respectively.</span><br><span class="line"></span><br><span class="line">Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</span><br><span class="line"></span><br><span class="line">You may assume nums1 and nums2 cannot be both empty.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">nums1 &#x3D; [1, 3]</span><br><span class="line">nums2 &#x3D; [2]</span><br><span class="line"></span><br><span class="line">The median is 2.0</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">nums1 &#x3D; [1, 2]</span><br><span class="line">nums2 &#x3D; [3, 4]</span><br><span class="line"></span><br><span class="line">The median is (2 + 3)&#x2F;2 &#x3D; 2.5</span><br></pre></td></tr></table></figure>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路1<br><strong>**</strong>- 时间复杂度: O(n + m)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>直接用暴利搜索，类似与归并两个有序的数组。遍历两个数组，当总长度等于（m+n）/ 2，注意区分总长度奇数和偶数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = (nums1.size() + nums2.size()) / <span class="number">2</span>,count1 = <span class="number">0</span>,i = <span class="number">0</span>,j = <span class="number">0</span>,current,pre;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.size() &amp;&amp; j &lt; nums2.size() &amp;&amp; count1 &lt;= temp)</span><br><span class="line">        &#123;</span><br><span class="line">            pre = current;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &gt; nums2[j])</span><br><span class="line">                current = nums2[j++];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                current = nums1[i++];</span><br><span class="line">            ++count1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count1 &lt;= temp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; nums1.size())</span><br><span class="line">                <span class="keyword">while</span>(count1 &lt;= temp)</span><br><span class="line">                &#123;</span><br><span class="line">                    pre = current;</span><br><span class="line">                    current = nums1[i++];</span><br><span class="line">                    ++count1;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">while</span>(count1 &lt;= temp)</span><br><span class="line">                &#123;</span><br><span class="line">                    pre = current;</span><br><span class="line">                    current = nums2[j++];</span><br><span class="line">                    ++count1;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((nums1.size() + nums2.size()) % <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">        <span class="keyword">double</span> ans = (current + pre) / <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路2<br><strong>**</strong>- 时间复杂度: O(lg(min(n.m)))<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>我们可以通过二分查找优化算法，利用中位数的定义，将两个数组划分为左右两个部分，nums1左半部分加nums2左半部分等于nums1右半部分加nums2的右半部分，如果总长度为偶数，那么nums1左半部分加nums2左半部分等于nums1右半部分加nums2的右半部分加1。并且<code>max(nums1[i],nums2[j]) &lt;= max(nums1[i + 1],nums2[j + 1])</code>，接下来我们只要二分查找找i，并且要注意边界情况</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.size(),n = nums2.size(),sum = m + n;</span><br><span class="line">        <span class="keyword">if</span>(!nums1.size())</span><br><span class="line">            <span class="keyword">return</span> sum % <span class="number">2</span> ? nums2[sum / <span class="number">2</span>] : (nums2[sum /<span class="number">2</span>] + nums2[sum / <span class="number">2</span> - <span class="number">1</span>]) / <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!nums2.size())</span><br><span class="line">            <span class="keyword">return</span> sum % <span class="number">2</span> ? nums1[sum / <span class="number">2</span>] : (nums1[sum /<span class="number">2</span>] + nums1[sum / <span class="number">2</span> - <span class="number">1</span>]) / <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(m &gt; n)</span><br><span class="line">            <span class="keyword">return</span> findMedianSortedArrays(nums2,nums1);</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> j = (sum + <span class="number">1</span>) / <span class="number">2</span> - mid - <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> min1 = max(nums1[mid],nums2[j]),max1 = min(nums1[mid + <span class="number">1</span>],nums2[j + <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(min1 &lt;= max1)</span><br><span class="line">                <span class="keyword">return</span> sum % <span class="number">2</span> ? min1 : (min1 + max1) / <span class="number">2.0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums1[mid] &gt; nums2[j])</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j = (sum + <span class="number">1</span>) / <span class="number">2</span> - l - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> min1,max1;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; <span class="number">0</span>)</span><br><span class="line">           min1 = nums1[l];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">           min1 = max(nums1[l],nums2[j]);</span><br><span class="line">        <span class="keyword">if</span>(l == nums1.size() - <span class="number">1</span>)</span><br><span class="line">            max1 = nums2[j + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            max1 = min(nums1[l + <span class="number">1</span>],nums2[j + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(min1 &lt;= max1)</span><br><span class="line">            <span class="keyword">return</span> sum % <span class="number">2</span> ? min1 : (min1 + max1) / <span class="number">2.0</span>;</span><br><span class="line">        j++;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; nums2.size() - <span class="number">1</span>)</span><br><span class="line">            max1 = min(nums1[l],nums2[j + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            max1 = nums1[l];</span><br><span class="line">        min1 = nums2[j];</span><br><span class="line">        <span class="keyword">return</span> sum % <span class="number">2</span> ? min1 : (min1 + max1) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路3<br><strong>**</strong>- 时间复杂度: O(lg(n+m))<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>由于题目中建议我们在时间复杂度O(lg(m+n))中完成，我们可以把这题看成寻找第k大的值，这样我们可以递归的去做，每次查找k/2，知道k等于1，注意边界值的处理</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getKth</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums1, <span class="keyword">int</span> start1, <span class="keyword">int</span> end1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums2, <span class="keyword">int</span> start2, <span class="keyword">int</span> end2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = end1 - start1 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len2 = end2 - start2 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (len1 &gt; len2) <span class="keyword">return</span> getKth(nums2, start2, end2, nums1, start1, end1, k);</span><br><span class="line">        <span class="keyword">if</span> (len1 == <span class="number">0</span>) <span class="keyword">return</span> nums2[start2 + k - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> min(nums1[start1], nums2[start2]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = start1 + min(len1, k / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = start2 + min(len2, k / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">            <span class="keyword">return</span> getKth(nums1, start1, end1, nums2, j + <span class="number">1</span>, end2, k - (j - start2 + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getKth(nums1, i + <span class="number">1</span>, end1, nums2, start2, end2, k - (i - start1 + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums1.size();</span><br><span class="line">    <span class="keyword">int</span> m = nums2.size();</span><br><span class="line">    <span class="keyword">int</span> left = (n + m + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> right = (n + m + <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> (getKth(nums1, <span class="number">0</span>, n - <span class="number">1</span>, nums2, <span class="number">0</span>, m - <span class="number">1</span>, left) + getKth(nums1, <span class="number">0</span>, n - <span class="number">1</span>, nums2, <span class="number">0</span>, m - <span class="number">1</span>, right)) * <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>5. Longest Palindromic Substring</title>
    <url>/2020/04/07/LeetCode_Cpp/0005._Longest_Palindromic_Substring/</url>
    <content><![CDATA[<h1 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5. Longest Palindromic Substring"></a>5. Longest Palindromic Substring</h1><p>难度:Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/longest-palindromic-substring/description/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-palindromic-substring/description/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: &quot;babad&quot;</span><br><span class="line">Output: &quot;bab&quot;</span><br><span class="line">Note: &quot;aba&quot; is also a valid answer.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: &quot;cbbd&quot;</span><br><span class="line">Output: &quot;bb&quot;</span><br></pre></td></tr></table></figure>

<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1<br><strong>**</strong>- 时间复杂度: O(N^2)<strong>**</strong>- 空间复杂度: O(N^2)<strong>**</strong></p>
</blockquote>
<p>这题如果用单纯暴力的解法，时间复杂度为 O(n ^ 3)，肯定超时，那么就要对这个算法进行优化，这里采用的是DP思想，定义 p(i,j)为s中的第i个数到s中的第j个数的子串，不难看出 p(i，j)中的子串有重复计算，接下来就可以写出状态转移方程 P(i,j)=(P(i+1,j?1) and S[i] == S[j])</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">1000</span>][<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">		 <span class="keyword">int</span> beg = <span class="number">0</span>,en = <span class="number">1</span>,ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> length = s.length();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length;++i)</span><br><span class="line">		&#123;</span><br><span class="line">			dp[i][i] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i + <span class="number">1</span> &lt; length &amp;&amp; s[i] == s[i + <span class="number">1</span>])</span><br><span class="line">				dp[i][i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length;++i)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= i;++j)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(i &gt; j + <span class="number">1</span>)</span><br><span class="line">					dp[j][i] = (dp[j + <span class="number">1</span>][i - <span class="number">1</span>] &amp;&amp; s[i] == s[j]);</span><br><span class="line">				<span class="keyword">if</span>(dp[j][i] &amp;&amp; i - j + <span class="number">1</span> &gt; ans)</span><br><span class="line">				&#123;</span><br><span class="line">					ans = i - j + <span class="number">1</span>;</span><br><span class="line">					beg = j;</span><br><span class="line">					en = i + <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="function"><span class="built_in">string</span> <span class="title">ret</span><span class="params">(s.begin() + beg,s.begin() + en)</span></span>;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>8. String to Integer (atoi)</title>
    <url>/2020/04/07/LeetCode_Cpp/0008._String_to_Integer_(atoi)/</url>
    <content><![CDATA[<h1 id="8-String-to-Integer-atoi"><a href="#8-String-to-Integer-atoi" class="headerlink" title="8. String to Integer (atoi)"></a>8. String to Integer (atoi)</h1><p><strong><font color=red>难度:Medium<font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">https://leetcode.com/problems/string-to-integer-atoi/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Implement atoi which converts a string to an integer.</span><br><span class="line"></span><br><span class="line">The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</span><br><span class="line"></span><br><span class="line">The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</span><br><span class="line"></span><br><span class="line">If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</span><br><span class="line"></span><br><span class="line">If no valid conversion could be performed, a zero value is returned.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">Only the space character &#39; &#39; is considered as whitespace character.</span><br><span class="line">Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [?231,  231 ? 1]. If the numerical value is out of the range of representable values, INT_MAX (231 ? 1) or INT_MIN (?231) is returned.</span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: &quot;42&quot;</span><br><span class="line">Output: 42</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: &quot;   -42&quot;</span><br><span class="line">Output: -42</span><br><span class="line">Explanation: The first non-whitespace character is &#39;-&#39;, which is the minus sign.</span><br><span class="line">             Then take as many numerical digits as possible, which gets 42.</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: &quot;4193 with words&quot;</span><br><span class="line">Output: 4193</span><br><span class="line">Explanation: Conversion stops at digit &#39;3&#39; as the next character is not a numerical digit.</span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input: &quot;words and 987&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The first non-whitespace character is &#39;w&#39;, which is not a numerical </span><br><span class="line">             digit or a +&#x2F;- sign. Therefore no valid conversion could be performed.</span><br><span class="line">Example 5:</span><br><span class="line"></span><br><span class="line">Input: &quot;-91283472332&quot;</span><br><span class="line">Output: -2147483648</span><br><span class="line">Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer.</span><br><span class="line">             Thefore INT_MIN (?231) is returned.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(N)<strong>**</strong>- 空间复杂度: O(N)<strong>**</strong></p>
</blockquote>
<p>把一个字符串转成数字，如果字符串只有数字只要遍历字符串转成int类型的数字即可，不过这题的限制蛮多的，因此要注意边界值，判断数字的正负。这里为了提高效率。先计算了10的32次方内10的n次方的值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,count1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> arr[<span class="number">34</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">34</span>;++i)</span><br><span class="line">            arr[i] = arr[i - <span class="number">1</span>] * <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span>(str[i] == <span class="string">' '</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">'-'</span> || str[i] == <span class="string">'+'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">'-'</span>)</span><br><span class="line">                count1 = <span class="number">1</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">isdigit</span>(str[i]))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(str[i] == <span class="string">'0'</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; str.length() &amp;&amp; <span class="built_in">isdigit</span>(str[j]))</span><br><span class="line">            j++;</span><br><span class="line">        <span class="keyword">if</span>(j - i &gt; <span class="number">33</span>)</span><br><span class="line">            <span class="keyword">return</span> count1 ? INT_MIN : INT_MAX;</span><br><span class="line">        j--;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= i)</span><br><span class="line">        &#123;</span><br><span class="line">            num += (str[j] - <span class="string">'0'</span>) * arr[t++];</span><br><span class="line">            <span class="keyword">if</span>(!count1 &amp;&amp; num &gt; INT_MAX)</span><br><span class="line">                <span class="keyword">return</span>  INT_MAX;</span><br><span class="line">            <span class="keyword">if</span>(count1 &amp;&amp; num * <span class="number">-1</span> &lt; INT_MIN)</span><br><span class="line">                <span class="keyword">return</span> INT_MIN;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count1)</span><br><span class="line">            num *= <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>9. Palindrome Number</title>
    <url>/2020/04/07/LeetCode_Cpp/0009._Palindrome_Number/</url>
    <content><![CDATA[<h1 id="9-Palindrome-Number"><a href="#9-Palindrome-Number" class="headerlink" title="9. Palindrome Number"></a>9. Palindrome Number</h1><p>难度:Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/palindrome-number/description/" target="_blank" rel="noopener">https://leetcode.com/problems/palindrome-number/description/</a></li>
<li><blockquote>
<p>内容描述</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 121</span><br><span class="line">Output: true</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: -121</span><br><span class="line">Output: false</span><br><span class="line">Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: 10</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Reads 01 from right to left. Therefore it is not a palindrome.</span><br><span class="line">Follow up:</span><br><span class="line"></span><br><span class="line">Coud you solve it without converting the integer to a string?</span><br></pre></td></tr></table></figure>

<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路1<br><strong>**</strong>- 时间复杂度: O(N)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>这题的难度不大，由于是数字，判断回文只需要求出倒过来的数字，判断两者是否相等，不过要注意负数一定不是回文</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = x;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(num)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = <span class="number">10</span> * ret + num % <span class="number">10</span>;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ret == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路2<br><strong>**</strong>- 时间复杂度: O(N)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>计算出数字的长度，用双指针法，一个指针指向头，另一个指向尾，相等就前一个指针加一，后一个指针减一，若不相等则返回 false</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> fac = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> div = INT_MAX;</span><br><span class="line">        <span class="keyword">while</span> (div != <span class="number">0</span>) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            fac *= <span class="number">10</span>;</span><br><span class="line">            div = x/fac;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fac /= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;cnt/<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> last = x%<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">int</span> first = x/fac;</span><br><span class="line">            <span class="keyword">if</span> (first != last)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            x = x % fac;</span><br><span class="line">            x = (x-last)/<span class="number">10</span>;</span><br><span class="line">            fac /= <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这两种方法的时间复杂度都取决于输入的数字的长度</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>15. 3sum</title>
    <url>/2020/04/07/LeetCode_Cpp/0015._3sum/</url>
    <content><![CDATA[<h1 id="15-3sum"><a href="#15-3sum" class="headerlink" title="15. 3sum"></a>15. 3sum</h1><p>难度:Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<p>*<a href="https://leetcode.com/problems/3sum/description/" target="_blank" rel="noopener">https://leetcode.com/problems/3sum/description/</a></p>
<ul>
<li><blockquote>
<p>内容描述</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c &#x3D; 0? Find all unique triplets in the array which gives the sum of zero.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">The solution set must not contain duplicate triplets.</span><br></pre></td></tr></table></figure>

<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(N ^ 2)<strong>**</strong>- 空间复杂度: O(N)<strong>**</strong></p>
</blockquote>
<p>之前做过两个数之和等于某个数的题目，其实这题也差不多，三数之和等于0，那么我们只要让另外两个数之和等于第三个数的相反数即可，不过这里要注意会存在重复，所以要去重</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">threeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ret;</span><br><span class="line">    sort(nums.begin(),nums.end());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.size();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t1 = i + <span class="number">1</span>,t2 = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span>(t1 &lt; t2)</span><br><span class="line">            <span class="keyword">if</span>(nums[t1] + nums[t2] == -nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">                v.push_back(nums[i]);</span><br><span class="line">                v.push_back(nums[t1]);</span><br><span class="line">                v.push_back(nums[t2]);</span><br><span class="line">                ret.push_back(v);</span><br><span class="line">                ++t1;</span><br><span class="line">                --t2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[t1] + nums[t2] &lt; -nums[i])</span><br><span class="line">                ++t1;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                --t2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> pos = unique(ret.begin(),ret.end());</span><br><span class="line">    ret.erase(pos,ret.end());</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>14. Longest Common Prefix</title>
    <url>/2020/04/07/LeetCode_Cpp/0014._Longest_Common_Prefix/</url>
    <content><![CDATA[<h1 id="14-Longest-Common-Prefix"><a href="#14-Longest-Common-Prefix" class="headerlink" title="14. Longest Common Prefix"></a>14. Longest Common Prefix</h1><p><strong><font color=red>难度:Easy<font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/longest-common-prefix/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-common-prefix/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Write a function to find the longest common prefix string amongst an array of strings.</span><br><span class="line"></span><br><span class="line">If there is no common prefix, return an empty string &quot;&quot;.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">Output: &quot;fl&quot;</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: There is no common prefix among the input strings.</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">All given inputs are in lowercase letters a-z.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路1<br><strong>**</strong>- 时间复杂度: O(n^2)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>求最长前缀公共子串，只有遍历所有子串，求出最长公共子串即可，不过要注意可能存在空字符串</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;            </span><br><span class="line">        <span class="built_in">string</span> temp;</span><br><span class="line">        <span class="keyword">if</span>(!strs.size() || !strs[<span class="number">0</span>].length())</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> ch = strs[<span class="number">0</span>][j];</span><br><span class="line">            <span class="keyword">for</span>(;i &lt; strs.size();++i)</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= strs[i].length() || strs[i][j] != ch)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i != strs.size())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            temp.push_back(strs[<span class="number">0</span>][j++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>10. Regular Expression Matching</title>
    <url>/2020/04/07/LeetCode_Cpp/0010._Regular_Expression_Matching/</url>
    <content><![CDATA[<h1 id="10-Regular-Expression-Matching"><a href="#10-Regular-Expression-Matching" class="headerlink" title="10. Regular Expression Matching"></a>10. Regular Expression Matching</h1><p>难度: Hard</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/regular-expression-matching/description/" target="_blank" rel="noopener">https://leetcode.com/problems/regular-expression-matching/description/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given an input string (s) and a pattern (p), implement regular expression matching with support for &#39;.&#39; and &#39;*&#39;.</span><br><span class="line"></span><br><span class="line">&#39;.&#39; Matches any single character.</span><br><span class="line">&#39;*&#39; Matches zero or more of the preceding element.</span><br><span class="line">The matching should cover the entire input string (not partial).</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">s could be empty and contains only lowercase letters a-z.</span><br><span class="line">p could be empty and contains only lowercase letters a-z, and characters like . or *.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &#39;*&#39; means zero or more of the precedeng element, &#39;a&#39;. Therefore, by repeating &#39;a&#39; once, it becomes &quot;aa&quot;.</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;ab&quot;</span><br><span class="line">p &#x3D; &quot;.*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.</span><br><span class="line"></span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;aab&quot;</span><br><span class="line">p &#x3D; &quot;c*a*b&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches &quot;aab&quot;.</span><br><span class="line"></span><br><span class="line">Example 5:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;mississippi&quot;</span><br><span class="line">p &#x3D; &quot;mis*is*p*.&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路1<br><strong>**</strong>- 时间复杂度: O(n^2)<strong>**</strong>- 空间复杂度: O(n^2)<strong>**</strong></p>
</blockquote>
<p>用动态规划的思路去解，dp[i][j]代表字符串s中第i个字符之前的字符串与p中第j个字符串之前的字符是否匹配。写出状态转移方程。当<code>s[i] == p[j] || p[j] == &#39;.&#39;</code>时。<code>dp[i + 1][j + 1] = dp[i][j]</code>。当<code>p[j] == &#39;*&#39;</code>时，可以匹配0个，1个或多个之前相同的字符。当之前的字符<code>s[i] == p[j - 1] || p[j - 1] == &#39;*&#39;</code>时。<code>dp[i + 1][j + 1] = dp[i][j] || dp[i][j + 1]</code>表示匹配1个或者多个。还可匹配0个。因此<code>dp[i + 1][j + 1] = dp[i + 1][j + 1] || dp[i + 1][j - 1]</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        s.push_back(<span class="string">' '</span>);</span><br><span class="line">        p.push_back(<span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">int</span> len1 = s.length(),len2 = p.length();</span><br><span class="line">        <span class="keyword">int</span> dp[len1 + <span class="number">1</span>][len2 + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len2;++i)</span><br><span class="line">            <span class="keyword">if</span>(p[i] == <span class="string">'*'</span>)</span><br><span class="line">                dp[<span class="number">0</span>][i + <span class="number">1</span>] = dp[<span class="number">0</span>][i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len1;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; len2;++j)</span><br><span class="line">                <span class="keyword">if</span>(j &amp;&amp; p[j] == <span class="string">'*'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = (p[j - <span class="number">1</span>] == s[i] || p[j - <span class="number">1</span>] == <span class="string">'.'</span>) &amp;&amp; (dp[i][j] || dp[i][j + <span class="number">1</span>]);</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i + <span class="number">1</span>][j + <span class="number">1</span>] || dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == p[j] || p[j] == <span class="string">'.'</span>)</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j];</span><br><span class="line">        <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>11. container with most water</title>
    <url>/2020/04/07/LeetCode_Cpp/0011._container_with_most_water/</url>
    <content><![CDATA[<h1 id="11-container-with-most-water"><a href="#11-container-with-most-water" class="headerlink" title="11. container with most water"></a>11. container with most water</h1><p>难度:Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<p>*<a href="https://leetcode.com/problems/container-with-most-water/" target="_blank" rel="noopener">https://leetcode.com/problems/container-with-most-water/</a></p>
<ul>
<li><blockquote>
<p>内容描述</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</span><br><span class="line"></span><br><span class="line">Note: You may not slant the container and n is at least 2.</span><br></pre></td></tr></table></figure>

<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(N)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>这道题刚开始很容易想到用暴力的方法去解，但是时间复杂度为 O(n^2) 测试之后发现是 TLE，那么我们就要对算法进行优化，这里我们用双指针法，定义两个指针，一个指向头，另一个指向尾部，比较两个指针指向的数的大小，若头部的大，则指向头部的指针向后移动一位，反之，则指向尾部的指针向前移动一位。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j = height.size() - <span class="number">1</span>,ans = INT_MIN;</span><br><span class="line">		<span class="keyword">while</span>(i &lt; j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> t = min(height[i],height[j]);</span><br><span class="line">			ans = max(ans,t * (j - i));</span><br><span class="line">			height[i] &lt; height[j] ? i++ : j--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>16. 3Sum Closest</title>
    <url>/2020/04/07/LeetCode_Cpp/0016._3Sum_Closest/</url>
    <content><![CDATA[<h2 id="16-3Sum-Closest"><a href="#16-3Sum-Closest" class="headerlink" title="16. 3Sum Closest"></a>16. 3Sum Closest</h2><p>难度：Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题链接：<a href="https://leetcode.com/problems/3sum-closest/description/" target="_blank" rel="noopener">https://leetcode.com/problems/3sum-closest/description/</a></p>
</blockquote>
<p>Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given array nums &#x3D; [-1, 2, 1, -4], and target &#x3D; 1.</span><br><span class="line"></span><br><span class="line">The sum that is closest to the target is 2. (-1 + 2 + 1 &#x3D; 2).</span><br></pre></td></tr></table></figure>

<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>先排序，遍历第一个数，第二和第三个数通过双指针查找，转化为2sum closest的问题。如果遇到和等于target的三个数，直接返回target。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> min_distance&#123;INT_MAX&#125;, sum&#123;<span class="number">0</span>&#125;, cur_sum&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = nums.cbegin(); it != nums.cend(); ++it)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> left_idx = <span class="built_in">std</span>::next(it), right_idx = <span class="built_in">std</span>::prev(nums.cend()); left_idx &lt; right_idx; cur_sum &gt; target ? --right_idx : ++left_idx) &#123;</span><br><span class="line">                cur_sum = *it + *left_idx + *right_idx;</span><br><span class="line">                <span class="keyword">auto</span> cur_distance = <span class="built_in">std</span>::<span class="built_in">abs</span>(cur_sum - target);</span><br><span class="line">                <span class="keyword">if</span> (cur_sum == target)</span><br><span class="line">                    <span class="keyword">return</span> target;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cur_distance &lt; min_distance) &#123;</span><br><span class="line">                    min_distance = cur_distance;</span><br><span class="line">                    sum = cur_sum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>17. Letter Combinations of a Phone Number</title>
    <url>/2020/04/07/LeetCode_Cpp/0017._Letter_Combinations_of_a_Phone_Number/</url>
    <content><![CDATA[<h1 id="17-Letter-Combinations-of-a-Phone-Number"><a href="#17-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="17. Letter Combinations of a Phone Number"></a>17. Letter Combinations of a Phone Number</h1><p><strong><font color=red>难度:Medium<font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">https://leetcode.com/problems/letter-combinations-of-a-phone-number/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.</span><br><span class="line"></span><br><span class="line">A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: &quot;23&quot;</span><br><span class="line">Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">Although the above answer is in lexicographical order, your answer could be in any order you want.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路1<br><strong>**</strong>- 时间复杂度: O(2^n)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>用回溯法去解，先将给定字符串转成数字。处了7和9之外的所有数字都有3个字母，计算出每个数字代表的字母。接着再用回溯法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">string</span>&amp; s,<span class="keyword">int</span> i,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ans,<span class="built_in">string</span>&amp; temp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == s.length())</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> t = s[i] - <span class="string">'2'</span>;</span><br><span class="line">        <span class="keyword">int</span> ch_beg;</span><br><span class="line">        <span class="keyword">if</span>(t &lt; <span class="number">6</span>)</span><br><span class="line">            ch_beg = <span class="string">'a'</span> + t * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ch_beg = <span class="string">'a'</span> + (t - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> en = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="number">5</span> || t == <span class="number">7</span>)</span><br><span class="line">            en = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; en;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            temp.push_back(ch_beg + j);</span><br><span class="line">            DFS(s,i + <span class="number">1</span>,ans,temp);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">letterCombinations</span><span class="params">(<span class="built_in">string</span> digits)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(!digits.size())</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">string</span> temp;</span><br><span class="line">        DFS(digits,<span class="number">0</span>,ans,temp);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>18. 4Sum</title>
    <url>/2020/04/07/LeetCode_Cpp/0018._4Sum/</url>
    <content><![CDATA[<h2 id="18-4Sum"><a href="#18-4Sum" class="headerlink" title="18. 4Sum"></a>18. 4Sum</h2><p>难度：Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><p>题目链接：<a href="https://leetcode.com/problems/4sum/description/" target="_blank" rel="noopener">https://leetcode.com/problems/4sum/description/</a></p>
<p>Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</p>
<p>Note:</p>
<p>The solution set must not contain duplicate quadruplets.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given array nums &#x3D; [1, 0, -1, 0, -2, 2], and target &#x3D; 0.</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1,  0, 0, 1],</span><br><span class="line">  [-2, -1, 1, 2],</span><br><span class="line">  [-2,  0, 0, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>思路和 3Sum 类似，多了一层for循环。为了避免重复，在存储结果的时候使用STL的set。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">fourSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() &lt; <span class="number">4</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&#123;&#125;;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">std</span>::sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">3</span>; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> j = i + <span class="number">1</span>; j &lt; nums.size() - <span class="number">2</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">auto</span> left_idx = j + <span class="number">1</span>; <span class="keyword">auto</span> right_idx = nums.size() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (left_idx = j + <span class="number">1</span>, right_idx = nums.size() - <span class="number">1</span>; left_idx &lt; right_idx; sum &gt; target ? --right_idx : ++left_idx) &#123;</span><br><span class="line">                    sum = nums[i] + nums[j] + nums[left_idx] + nums[right_idx];</span><br><span class="line">                    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res_single&#123;nums[i], nums[j], nums[left_idx], nums[right_idx]&#125;;</span><br><span class="line">                        res.insert(res_single);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(res.begin(), res.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>19. Remove Nth Node From End of List</title>
    <url>/2020/04/07/LeetCode_Cpp/0019._Remove_Nth_Node_From_End_of_List/</url>
    <content><![CDATA[<h1 id="19-Remove-Nth-Node-From-End-of-List"><a href="#19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="19. Remove Nth Node From End of List"></a>19. Remove Nth Node From End of List</h1><p><strong><font color=red>难度:Medium<font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">https://leetcode.com/problems/remove-nth-node-from-end-of-list/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a linked list, remove the n-th node from the end of list and return its head.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n &#x3D; 2.</span><br><span class="line"></span><br><span class="line">After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(n)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>删除倒数第n个数，为了防止链表长度为1时的空指针异常，先插入一个链表头，接着我们只要先遍历链表，计算出链表的总长度，再用总长度减去 n 就是我们要删除的数的前一个数距链表头的长度，接下来只要用个循环找到并删除要删除的节点即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       ListNode* current = head;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(current)</span><br><span class="line">        &#123;</span><br><span class="line">            num++;</span><br><span class="line">            current = current -&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* n1 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        n1 -&gt;next = head;</span><br><span class="line">        current = n1;</span><br><span class="line">        num -= n;</span><br><span class="line">        <span class="keyword">while</span>(num)</span><br><span class="line">        &#123;</span><br><span class="line">            num--;</span><br><span class="line">            current = current -&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* temp = current -&gt;next;</span><br><span class="line">        current -&gt;next = temp -&gt;next;</span><br><span class="line">        <span class="keyword">return</span> n1 -&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>20. Valid Parentheses</title>
    <url>/2020/04/07/LeetCode_Cpp/0020._valid_parentheses/</url>
    <content><![CDATA[<h2 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20. Valid Parentheses"></a>20. Valid Parentheses</h2><p> 难度: Easy</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-parentheses/</a><blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a string containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;&#123;&#39;, &#39;&#125;&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid.</span><br><span class="line"></span><br><span class="line">An input string is valid if:</span><br><span class="line"></span><br><span class="line">Open brackets must be closed by the same type of brackets.</span><br><span class="line">Open brackets must be closed in the correct order.</span><br><span class="line">Note that an empty string is also considered valid.</span><br><span class="line"></span><br><span class="line">### Example</span><br><span class="line">1. Input: &quot;()&quot;   -&gt; Output: true</span><br><span class="line"></span><br><span class="line">2. Input: &quot;()[]&#123;&#125;&quot; -&gt; Output: true</span><br><span class="line"></span><br><span class="line">3. Input: &quot;(]&quot; -&gt; Output: false</span><br><span class="line"></span><br><span class="line">4. Input: &quot;([)]&quot; -&gt; Output: false</span><br><span class="line"></span><br><span class="line">5. Input: &quot;&#123;[]&#125;&quot; -&gt; Output: true</span><br></pre></td></tr></table></figure>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">利用栈先进后出的先天优势，解决匹配问题。</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; stacks;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'('</span>||s[i]==<span class="string">'&#123;'</span>||s[i]==<span class="string">'['</span>)</span><br><span class="line">                stacks.push(s[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(stacks.empty())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">char</span> ch = stacks.top();</span><br><span class="line">                stacks.pop();</span><br><span class="line">                <span class="keyword">if</span>(s[i]==<span class="string">')'</span>&amp;&amp;ch==<span class="string">'('</span>||s[i]==<span class="string">']'</span>&amp;&amp;ch==<span class="string">'['</span>||s[i]==<span class="string">'&#125;'</span>&amp;&amp;ch==<span class="string">'&#123;'</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stacks.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>23. merge k sorted lists</title>
    <url>/2020/04/07/LeetCode_Cpp/0023._merge_k_sorted_lists/</url>
    <content><![CDATA[<h1 id="23-merge-k-sorted-lists"><a href="#23-merge-k-sorted-lists" class="headerlink" title="23. merge k sorted lists"></a>23. merge k sorted lists</h1><p>难度: Hard</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-k-sorted-lists/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure>

<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路1<br><strong>**</strong>- 时间复杂度: O(Nlg(K))<strong>**</strong>- 空间复杂度: O(K)<strong>**</strong></p>
</blockquote>
<p>这里运用最小堆，先去每个链表的第一个元素构建最小堆，由于链表都是已排序的，因此，每次堆的顶部都是最小的元素，这里用优先队列实现最小堆。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cmp</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode* a, ListNode* b)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> a -&gt;val &gt; b -&gt;val;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;  </span><br><span class="line">		priority_queue&lt;ListNode*,<span class="built_in">vector</span>&lt;ListNode*&gt;,cmp&gt; pq;</span><br><span class="line">		ListNode* ret = <span class="literal">nullptr</span>;</span><br><span class="line">		ListNode* current = <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lists.size();++i)</span><br><span class="line">			<span class="keyword">if</span>(lists[i])</span><br><span class="line">				pq.push(lists[i]);</span><br><span class="line">		<span class="keyword">while</span>(pq.size())</span><br><span class="line">		&#123;</span><br><span class="line">			ListNode* temp = pq.top();</span><br><span class="line">			pq.pop();</span><br><span class="line">			<span class="keyword">if</span>(!ret)</span><br><span class="line">				ret = temp;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				current -&gt;next = temp;</span><br><span class="line">			current = temp;</span><br><span class="line">			<span class="keyword">if</span>(temp -&gt;next)</span><br><span class="line">				pq.push(temp -&gt;next);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路2<br><strong>**</strong>- 时间复杂度: O(Nlg(K))<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>这个思路用分治思想，我们可以通过归并排序解决，首先前面已经做过了两个有序链表的排序，我们可以把链表看做元素，只要对数组 Lists进行归并排序即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">head</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        ListNode* tail = &amp;head;</span><br><span class="line">        <span class="keyword">auto</span> cur1 = list1;</span><br><span class="line">        <span class="keyword">auto</span> cur2 = list2;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != <span class="literal">nullptr</span> &amp;&amp; cur2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur1-&gt;val &lt; cur2-&gt;val) &#123;</span><br><span class="line">                tail-&gt;next = cur1;</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">                cur1 = cur1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail-&gt;next = cur2;</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">                cur2 = cur2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> cur = cur1 == <span class="literal">nullptr</span> ? cur2 : cur1;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            tail-&gt;next = cur;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> lists[start];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">auto</span> list1 = mergeSort(lists, start, mid);</span><br><span class="line">        <span class="keyword">auto</span> list2 = mergeSort(lists, mid + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> merge(list1, list2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = lists.size();</span><br><span class="line">        <span class="keyword">return</span> mergeSort(lists, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>24. Swap Nodes in Pairs</title>
    <url>/2020/04/07/LeetCode_Cpp/0024._Swap_Nodes_in_Pairs/</url>
    <content><![CDATA[<h1 id="24-Swap-Nodes-in-Pairs"><a href="#24-Swap-Nodes-in-Pairs" class="headerlink" title="24. Swap Nodes in Pairs"></a>24. Swap Nodes in Pairs</h1><p> 难度: Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/swap-nodes-in-pairs/</a></p>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">你的算法只能使用常数的额外空间。</span><br><span class="line">你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">链表反转</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">    ListNode* slow=head;</span><br><span class="line">    ListNode* fast=head-&gt;next;</span><br><span class="line">    ListNode* pre=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode* ans = pre;</span><br><span class="line">    <span class="keyword">while</span>(slow&amp;&amp;fast)&#123;</span><br><span class="line">        slow-&gt;next = fast-&gt;next;</span><br><span class="line">        fast-&gt;next = slow;</span><br><span class="line">        pre-&gt;next = fast;</span><br><span class="line">        <span class="keyword">if</span>(slow-&gt;next==<span class="literal">NULL</span>||slow-&gt;next-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = slow-&gt;next-&gt;next;</span><br><span class="line">        pre = slow;</span><br><span class="line">        slow = slow-&gt;next; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>21. Merge Two Sorted Lists</title>
    <url>/2020/04/07/LeetCode_Cpp/0021._Merge%20_Two%20_Sorted%20_Lists/</url>
    <content><![CDATA[<h1 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="21. Merge Two Sorted Lists"></a>21. Merge Two Sorted Lists</h1><p>难度:Easy</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/merge-two-sorted-lists/description/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-two-sorted-lists/description/</a></li>
<li><blockquote>
<p>内容描述</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>

<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(N + M)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>首先这两个链表是排序好的，那么我们先定义一个空链表，再定义两个指针 i，j，按照顺序比较两个链表，如果 i 指向的数字小于 j指向的数字，i 指向的节点插入新链表中，i = i -&gt; next，反之则操作 j。不过要注意其中一个链表可能会先结束，所以另一个未结束的链表直接插入新链表即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">         ListNode* h1 = l1;</span><br><span class="line">        ListNode* h2 = l2;</span><br><span class="line">        ListNode* t = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* curr = t;</span><br><span class="line">        <span class="keyword">while</span> (h1 &amp;&amp; h2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (h1-&gt;val &lt;= h2-&gt;val) &#123;</span><br><span class="line">                curr-&gt;next = h1; </span><br><span class="line">                h1 = h1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                curr-&gt;next = h2;</span><br><span class="line">                h2 = h2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (h1)</span><br><span class="line">        &#123;</span><br><span class="line">            curr-&gt;next = h1;</span><br><span class="line">            h1 = h1-&gt;next;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(h2)</span><br><span class="line">        &#123;</span><br><span class="line">            curr-&gt;next = h2;</span><br><span class="line">            h2 = h2-&gt;next;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* res = t-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> t;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>22. Generate Parentheses</title>
    <url>/2020/04/07/LeetCode_Cpp/0022._generate_parentheses/</url>
    <content><![CDATA[<h1 id="22-Generate-Parentheses"><a href="#22-Generate-Parentheses" class="headerlink" title="22. Generate Parentheses"></a>22. Generate Parentheses</h1><p> 难度: Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/generate-parentheses/</a></p>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</span><br><span class="line"></span><br><span class="line">例如，给出 n &#x3D; 3，生成结果为：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  &quot;((()))&quot;,</span><br><span class="line">  &quot;(()())&quot;,</span><br><span class="line">  &quot;(())()&quot;,</span><br><span class="line">  &quot;()(())&quot;,</span><br><span class="line">  &quot;()()()&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">回溯法</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> total, <span class="built_in">string</span> path, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(total==<span class="number">0</span>&amp;&amp;left==<span class="number">0</span>)&#123;</span><br><span class="line">        ans.push_back(path);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;<span class="number">0</span>)</span><br><span class="line">        dfs(left<span class="number">-1</span>, total<span class="number">-1</span>, path+<span class="string">"("</span>, ans);</span><br><span class="line">    <span class="keyword">if</span>(left&lt;total-left)</span><br><span class="line">        dfs(left, total<span class="number">-1</span>, path+<span class="string">")"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">    <span class="built_in">string</span> path=<span class="string">""</span>;</span><br><span class="line">    dfs(n, n*<span class="number">2</span>, path, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>26.Remove Duplicates From Sorted Array</title>
    <url>/2020/04/07/LeetCode_Cpp/0026._Remove_Duplicates_From_Sorted_Array/</url>
    <content><![CDATA[<h1 id="26-Remove-Duplicates-From-Sorted-Array"><a href="#26-Remove-Duplicates-From-Sorted-Array" class="headerlink" title="26.Remove Duplicates From Sorted Array"></a>26.Remove Duplicates From Sorted Array</h1><p><strong><font color=red>难度Easy</font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">https://leetcode.com/problems/remove-duplicates-from-sorted-array/</a><blockquote>
<p>内容描述</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.</span><br><span class="line"></span><br><span class="line">Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Given nums &#x3D; [1,1,2],</span><br><span class="line"></span><br><span class="line">Your function should return length &#x3D; 2, with the first two elements of nums being 1 and 2 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&#39;t matter what you leave beyond the returned length.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Given nums &#x3D; [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">Your function should return length &#x3D; 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&#39;t matter what values are set beyond the returned length.</span><br><span class="line">Clarification:</span><br><span class="line"></span><br><span class="line">Confused why the returned value is an integer but your answer is an array?</span><br><span class="line"></span><br><span class="line">Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.</span><br><span class="line"></span><br><span class="line">Internally you can think of this:</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; nums is passed in by reference. (i.e., without making a copy)</span><br><span class="line">int len &#x3D; removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; any modification to nums in your function would be known by the caller.</span><br><span class="line">&#x2F;&#x2F; using the length returned by your function, it prints the first len elements.</span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(N)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>由于数组已经排序好的，我们直接遍历数组，用一个指针 i 指向开始处，另一个 j 指向第二个，若 j 指向的数不等于 i 指向的数，则<code>++i,++j</code>。否则只<code>++j</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!nums.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.size();)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[j] == nums[i] &amp;&amp; i &lt; nums.size())</span><br><span class="line">               ++i;</span><br><span class="line">            <span class="keyword">if</span>(i == nums.size())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            swap(nums[++j],nums[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>25.reverse nodes in k group</title>
    <url>/2020/04/07/LeetCode_Cpp/0025._reverse_nodes_in_k_group/</url>
    <content><![CDATA[<h1 id="25-reverse-nodes-in-k-group"><a href="#25-reverse-nodes-in-k-group" class="headerlink" title="25.reverse nodes in k group"></a>25.reverse nodes in k group</h1><p><strong><font color=red>难度Hard</font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-nodes-in-k-group/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</span><br><span class="line"></span><br><span class="line">k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5</span><br><span class="line"></span><br><span class="line">For k &#x3D; 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5</span><br><span class="line"></span><br><span class="line">For k &#x3D; 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">Only constant extra memory is allowed.</span><br><span class="line">You may not alter the values in the list&#39;s nodes, only nodes itself may be changed.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路1<br><strong>**</strong>- 时间复杂度: O(N)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>题目本身不难，这题我用了递归的方法去解，但题目中的note中说不能有额外的储存空间，但递归会生成辅助的空间，可以把递归改成循环，不过接下还是递归的版本</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode* current = head,*next1,*pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(m &lt;= k &amp;&amp; current)</span><br><span class="line">    &#123;</span><br><span class="line">        next1 = current -&gt;next;</span><br><span class="line">        current -&gt;next = pre;</span><br><span class="line">        pre = current;</span><br><span class="line">        current = next1;</span><br><span class="line">        ++m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m &lt;= k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(current != head)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* temp = pre -&gt;next;</span><br><span class="line">            pre -&gt;next = current;</span><br><span class="line">            current = pre;</span><br><span class="line">            pre = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        head -&gt;next = reverseKGroup(current,k);</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>27.Remove Element</title>
    <url>/2020/04/07/LeetCode_Cpp/0027._Remove_Element/</url>
    <content><![CDATA[<h1 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="27.Remove Element"></a>27.Remove Element</h1><p><strong><font color=red>难度Easy</font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/remove-element/" target="_blank" rel="noopener">https://leetcode.com/problems/remove-element/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given an array nums and a value val, remove all instances of that value in-place and return the new length.</span><br><span class="line"></span><br><span class="line">Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</span><br><span class="line"></span><br><span class="line">The order of elements can be changed. It doesn&#39;t matter what you leave beyond the new length.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Given nums &#x3D; [3,2,2,3], val &#x3D; 3,</span><br><span class="line"></span><br><span class="line">Your function should return length &#x3D; 2, with the first two elements of nums being 2.</span><br><span class="line"></span><br><span class="line">It doesn&#39;t matter what you leave beyond the returned length.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Given nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2,</span><br><span class="line"></span><br><span class="line">Your function should return length &#x3D; 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.</span><br><span class="line"></span><br><span class="line">Note that the order of those five elements can be arbitrary.</span><br><span class="line"></span><br><span class="line">It doesn&#39;t matter what values are set beyond the returned length.</span><br><span class="line">Clarification:</span><br><span class="line"></span><br><span class="line">Confused why the returned value is an integer but your answer is an array?</span><br><span class="line"></span><br><span class="line">Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.</span><br><span class="line"></span><br><span class="line">Internally you can think of this:</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; nums is passed in by reference. (i.e., without making a copy)</span><br><span class="line">int len &#x3D; removeElement(nums, val);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; any modification to nums in your function would be known by the caller.</span><br><span class="line">&#x2F;&#x2F; using the length returned by your function, it prints the first len elements.</span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(n)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>我们可以遍历数组，把等于 val 的数放到数组的后半部分就行。我们可以用双指针实现。当 nums[i] != val 时，nums[j++] = nums[i]</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i ,count = <span class="number">0</span>,j = <span class="number">0</span>,numsSize = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; numsSize;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == val)</span><br><span class="line">            &#123; </span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nums[j++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numsSize - count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>28.implement strstr</title>
    <url>/2020/04/07/LeetCode_Cpp/0028._implement_strstr/</url>
    <content><![CDATA[<h1 id="28-implement-strstr"><a href="#28-implement-strstr" class="headerlink" title="28.implement strstr"></a>28.implement strstr</h1><p><strong><font color=red>难度Easy</font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/implement-strstr/" target="_blank" rel="noopener">https://leetcode.com/problems/implement-strstr/</a><blockquote>
<p>内容描述</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Implement strStr().</span><br><span class="line"></span><br><span class="line">Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: haystack &#x3D; &quot;hello&quot;, needle &#x3D; &quot;ll&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: haystack &#x3D; &quot;aaaaa&quot;, needle &#x3D; &quot;bba&quot;</span><br><span class="line">Output: -1</span><br><span class="line">Clarification:</span><br><span class="line"></span><br><span class="line">What should we return when needle is an empty string? This is a great question to ask during an interview.</span><br><span class="line"></span><br><span class="line">For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C&#39;s strstr() and Java&#39;s indexOf().</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(N)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>这题直接遍历 haystack ，匹配到与 needle 第一个字符相等时，就遍历 needle，挨个比较字符。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>,i = <span class="number">0</span>,index= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; haystack.size() &amp;&amp; j &lt; needle.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(haystack[i] == needle[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!j)</span><br><span class="line">                    index = i;</span><br><span class="line">                j++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                i = ++index;</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == needle.size())</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>29.divide two integers</title>
    <url>/2020/04/07/LeetCode_Cpp/0029._divide_two_integers/</url>
    <content><![CDATA[<h1 id="29-divide-two-integers"><a href="#29-divide-two-integers" class="headerlink" title="29.divide two integers"></a>29.divide two integers</h1><p>难度:Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/divide-two-integers/" target="_blank" rel="noopener">https://leetcode.com/problems/divide-two-integers/</a><blockquote>
<p>内容描述</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.</span><br><span class="line"></span><br><span class="line">Return the quotient after dividing dividend by divisor.</span><br><span class="line"></span><br><span class="line">The integer division should truncate toward zero.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: dividend &#x3D; 10, divisor &#x3D; 3</span><br><span class="line">Output: 3</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: dividend &#x3D; 7, divisor &#x3D; -3</span><br><span class="line">Output: -2</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">Both dividend and divisor will be 32-bit signed integers.</span><br><span class="line">The divisor will never be 0.</span><br><span class="line">Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [?231,  231 ? 1]. For the purpose of this problem, assume that your function returns 231 ? 1 when the division result overflows.</span><br></pre></td></tr></table></figure>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(N)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>这里如果直接用暴力的方法肯定超时，这里我牺牲了空间换时间，不过由于 int 最大为2^31 - 1 所以数组的大小也是固定的。这里我们用倍增法，先定义一个res = 0，每次都计算 res += divisor * 2^n 直到大于dividend ，接着再从 res = divisor * 2^(n-1)开始，直到某个res + divisor &gt; dividend</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dividend)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> arr[<span class="number">33</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">33</span>;++i)</span><br><span class="line">            arr[i] = arr[i - <span class="number">1</span>] * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> temp1 = dividend,temp2 = divisor;</span><br><span class="line">        <span class="keyword">if</span>(temp1 &lt; <span class="number">0</span>)</span><br><span class="line">            temp1 *= <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp2 &lt; <span class="number">0</span>)</span><br><span class="line">            temp2 *= <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res,pre = <span class="number">0</span>,ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = pre + arr[count1] * temp2;</span><br><span class="line">            <span class="keyword">if</span>(res &gt; temp1)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!count1)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                pre = pre + arr[count1 - <span class="number">1</span>] * temp2;</span><br><span class="line">                ret += arr[count1 - <span class="number">1</span>];</span><br><span class="line">                count1 = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                count1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dividend &lt; <span class="number">0</span>)</span><br><span class="line">            ret *= <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(divisor &lt; <span class="number">0</span>)</span><br><span class="line">            ret *= <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">2147483648</span>)</span><br><span class="line">            <span class="keyword">return</span> ret - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>30.substring with concatenation of all words</title>
    <url>/2020/04/07/LeetCode_Cpp/0030._substring_with_concatenation_of_all_words/</url>
    <content><![CDATA[<h1 id="30-substring-with-concatenation-of-all-words"><a href="#30-substring-with-concatenation-of-all-words" class="headerlink" title="30.substring with concatenation of all words"></a>30.substring with concatenation of all words</h1><p>难度：Hard</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/substring-with-concatenation-of-all-words/" target="_blank" rel="noopener">https://leetcode.com/problems/substring-with-concatenation-of-all-words/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">  s &#x3D; &quot;barfoothefoobarman&quot;,</span><br><span class="line">  words &#x3D; [&quot;foo&quot;,&quot;bar&quot;]</span><br><span class="line">Output: [0,9]</span><br><span class="line">Explanation: Substrings starting at index 0 and 9 are &quot;barfoor&quot; and &quot;foobar&quot; respectively.</span><br><span class="line">The output order does not matter, returning [9,0] is fine too.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">  s &#x3D; &quot;wordgoodstudentgoodword&quot;,</span><br><span class="line">  words &#x3D; [&quot;word&quot;,&quot;student&quot;]</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(mlgn)<strong>**</strong>- 空间复杂度: O(m+n)<strong>**</strong></p>
</blockquote>
<p>这题可以两个 map 来解决，第一个 map 中存放了 words 中的所有单词和出现的次数，接下来遍历字符串，固定区间的大小为 words 的长度，存入另一个map，两个 map 相等就放入返回数组中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(!s.length() || !words.size())</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; m1;</span><br><span class="line">        <span class="keyword">int</span> len = words.size(),wl = words[<span class="number">0</span>].length(),sl = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; words.size();++i)</span><br><span class="line">            m1[words[i]]++;</span><br><span class="line">        <span class="keyword">int</span> count1 = <span class="number">0</span>,reLen = wl * len,left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; sl - wl * len + <span class="number">1</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; m2;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>,left = i;j &lt; len;j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> temp = s.substr(left,wl);</span><br><span class="line">                left += wl;</span><br><span class="line">                m2[temp]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(m2 == m1)</span><br><span class="line">                ans.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>31.Next Permutatio</title>
    <url>/2020/04/07/LeetCode_Cpp/0031._Next_Permutatio/</url>
    <content><![CDATA[<h1 id="31-Next-Permutatio"><a href="#31-Next-Permutatio" class="headerlink" title="31.Next Permutatio"></a>31.Next Permutatio</h1><p>难度:Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/next-permutation/" target="_blank" rel="noopener">https://leetcode.com/problems/next-permutation/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</span><br><span class="line"></span><br><span class="line">If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</span><br><span class="line"></span><br><span class="line">The replacement must be in-place and use only constant extra memory.</span><br><span class="line"></span><br><span class="line">Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</span><br><span class="line"></span><br><span class="line">1,2,3 → 1,3,2</span><br><span class="line">3,2,1 → 1,2,3</span><br><span class="line">1,1,5 → 1,5,1</span><br></pre></td></tr></table></figure>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(n)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>我们可以用两个指针表示需要交换的两个数，遍历数组。这题的最坏的情况下，数组降序排列，排序算法的复杂度也是O(n)。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = <span class="number">0</span>,n2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.size();++i)</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[n2])</span><br><span class="line">            &#123;</span><br><span class="line">                n1 = n2;</span><br><span class="line">                n2 = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((nums[i] &lt; nums[n2] &amp;&amp; nums[i] &gt; nums[n1]) || nums[i] == nums[n2])</span><br><span class="line">                n2 = i;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &lt;= nums[n1])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i;</span><br><span class="line">                <span class="keyword">for</span>(;j &lt; nums.size() - <span class="number">1</span>;++j)</span><br><span class="line">                    <span class="keyword">if</span>(nums[j + <span class="number">1</span>] &gt; nums[j])</span><br><span class="line">                    &#123;</span><br><span class="line">                        n1 = j;</span><br><span class="line">                        n2 = j + <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                i = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(n1 == n2)</span><br><span class="line">            sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            swap(nums[n1],nums[n2]);</span><br><span class="line">            sort(nums.begin() + n1 + <span class="number">1</span>,nums.end());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>32. Longest Valid Parentheses</title>
    <url>/2020/04/07/LeetCode_Cpp/0032._Longest_Valid_Parentheses/</url>
    <content><![CDATA[<h1 id="32-Longest-Valid-Parentheses"><a href="#32-Longest-Valid-Parentheses" class="headerlink" title="32. Longest Valid Parentheses"></a>32. Longest Valid Parentheses</h1><p><strong><font color=red>难度:Hard<font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-valid-parentheses/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a string containing just the characters &#39;(&#39; and &#39;)&#39;, find the length of the longest valid (well-formed) parentheses substring.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: &quot;(()&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The longest valid parentheses substring is &quot;()&quot;</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: &quot;)()())&quot;</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest valid parentheses substring is &quot;()()&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路1<br><strong>**</strong>- 时间复杂度: O(n)<strong>**</strong>- 空间复杂度: O(n)<strong>**</strong></p>
</blockquote>
<p>用DP的方法解这题。首先用一个栈去储存括号左边的部分，即’(‘的位置，直到遇到第一个’)’时。就记录栈顶的’(‘位置，接下来我们就可以写出状态转移方程。定义数组dp[i]代表字符串中第i个括号向左最远的位置。当第一次遇到’)’时，dp[i] = 栈顶’(‘的位置。由于可以存在连续的括号，若dp[dp[i] - 1]存在，则dp[i] = dp[dp[i] - 1]，需要注意边界即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span>(!len)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[len];</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;++i)</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'('</span>)</span><br><span class="line">                v.push_back(i);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">')'</span> &amp;&amp; v.size())</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = v[v.size() - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(dp[i] &amp;&amp; dp[dp[i] - <span class="number">1</span>] &gt;= <span class="number">0</span>)</span><br><span class="line">                    dp[i] = dp[dp[i] - <span class="number">1</span>];</span><br><span class="line">                ans = max(ans,i - dp[i] + <span class="number">1</span>);</span><br><span class="line">                v.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>33. Search in Rotated Sorted Array</title>
    <url>/2020/04/07/LeetCode_Cpp/0033._Search_in_Rotated_Sorted_Array/</url>
    <content><![CDATA[<h1 id="033-Search-in-Rotated-Sorted-Array"><a href="#033-Search-in-Rotated-Sorted-Array" class="headerlink" title="033. Search in Rotated Sorted Array"></a>033. Search in Rotated Sorted Array</h1><p>难度:Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">https://leetcode.com/problems/search-in-rotated-sorted-array/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</span><br><span class="line"></span><br><span class="line">(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).</span><br><span class="line"></span><br><span class="line">You are given a target value to search. If found in the array return its index, otherwise return -1.</span><br><span class="line"></span><br><span class="line">You may assume no duplicate exists in the array.</span><br><span class="line"></span><br><span class="line">Your algorithm&#39;s runtime complexity must be in the order of O(log n).</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">Output: 4</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><blockquote>
<p>思路1<br><strong>**</strong>- 时间复杂度: O(n)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>第一个方法是直接遍历数组，找到返回数组下标，找不到就返回-1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.size();++i)</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == target)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路2<br><strong>**</strong>- 时间复杂度: O(lgn)<strong><strong><em>- 空间复杂度: O(1)*</em></strong></strong></p>
</blockquote>
<p>第二个方法是用二分法找到旋转轴，再用二分法找到目标数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>,j = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!nums.size())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (i + j) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; nums[mid])</span><br><span class="line">            i = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = mid;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; i &lt;&lt; j &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums[i] &lt;= nums[j])</span><br><span class="line">        j = i;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; j;</span></span><br><span class="line">    <span class="keyword">auto</span> pos = lower_bound(nums.begin(),nums.begin() + j,target);</span><br><span class="line">    <span class="keyword">if</span>(pos != nums.end() &amp;&amp; (*pos) == target)</span><br><span class="line">        <span class="keyword">return</span> pos - nums.begin();</span><br><span class="line">    pos = lower_bound(nums.begin() + j,nums.end(),target);</span><br><span class="line">    <span class="keyword">if</span>(pos != nums.end() &amp;&amp; (*pos) == target)</span><br><span class="line">        <span class="keyword">return</span> pos - nums.begin();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>34. Find First and Last Position of Element in Sorted Array</title>
    <url>/2020/04/07/LeetCode_Cpp/0034._Find_First_and_Last_Position_of_Element_in_Sorted_Array/</url>
    <content><![CDATA[<h1 id="34-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><a href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array" class="headerlink" title="34. Find First and Last Position of Element in Sorted Array"></a>34. Find First and Last Position of Element in Sorted Array</h1><p><strong><font color=red>难度:Medium<font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.</span><br><span class="line"></span><br><span class="line">Your algorithm&#39;s runtime complexity must be in the order of O(log n).</span><br><span class="line"></span><br><span class="line">If the target is not found in the array, return [-1, -1].</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">Output: [3,4]</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">Output: [-1,-1]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路1<br><strong>**</strong>- 时间复杂度: O(lgn)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>典型的二分搜索，先查找目标数组中是否有target，在分别二分找第一个出现的target和最后一个target。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans = &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (r + l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">                r = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mid == <span class="number">-1</span> || nums[mid] != target)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">int</span> mid1 = l = mid;</span><br><span class="line">        r = nums.size();</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (r + l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid == nums.size())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">                r = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">            mid--;</span><br><span class="line">        ans[<span class="number">1</span>] = mid;</span><br><span class="line">        l = <span class="number">0</span>;</span><br><span class="line">        r = mid1 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (r + l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">            mid++;</span><br><span class="line">        ans[<span class="number">0</span>] = mid;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路2<br><strong>**</strong>- 时间复杂度: O(lgn)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>由于我们用的是c++，所以这里可以用lower_bound和upper_bound</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">     	<span class="keyword">auto</span> pos1 = lower_bound(nums.begin(),nums.end(),target);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans = &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(pos1 == nums.end() || (*pos1) != target)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        ans[<span class="number">0</span>] = pos1 - nums.begin();</span><br><span class="line">        <span class="keyword">auto</span> pos2 = upper_bound(nums.begin(),nums.end(),target);</span><br><span class="line">        ans[<span class="number">1</span>] = pos2 - nums.begin() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>36. Valid Sudoku</title>
    <url>/2020/04/07/LeetCode_Cpp/0036._Valid_Sudoku/</url>
    <content><![CDATA[<h1 id="36-Valid-Sudoku"><a href="#36-Valid-Sudoku" class="headerlink" title="36. Valid Sudoku"></a>36. Valid Sudoku</h1><p><strong><font color=red>难度:Medium<font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/valid-sudoku/" target="_blank" rel="noopener">https://leetcode.com/problems/valid-sudoku/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:</span><br><span class="line"></span><br><span class="line">Each row must contain the digits 1-9 without repetition.</span><br><span class="line">Each column must contain the digits 1-9 without repetition.</span><br><span class="line">Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.</span><br><span class="line">A partially filled sudoku which is valid.</span><br><span class="line"></span><br><span class="line">The Sudoku board could be partially filled, where empty cells are filled with the character &#39;.&#39;.</span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],</span><br><span class="line">  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]</span><br><span class="line">]</span><br><span class="line">Output: true</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],</span><br><span class="line">  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]</span><br><span class="line">]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Same as Example 1, except with the 5 in the top left corner being </span><br><span class="line">    modified to 8. Since there are two 8&#39;s in the top left 3x3 sub-box, it is invalid.</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">A Sudoku board (partially filled) could be valid but is not necessarily solvable.</span><br><span class="line">Only the filled cells need to be validated according to the mentioned rules.</span><br><span class="line">The given board contain only digits 1-9 and the character &#39;.&#39;.</span><br><span class="line">The given board size is always 9x9.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路1<br><strong>**</strong>- 时间复杂度: O(n^2)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>由于board是9x9的，实际的时间复杂度也是9x9的。这里我们只要分别判断每行每列和每9个小方块内是否有重复的数即可。难度不大。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">int</span> arr[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">int</span> arr1[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">int</span> arr2[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="built_in">memset</span>(arr,<span class="number">0</span>,<span class="keyword">sizeof</span>(arr));</span><br><span class="line">        <span class="built_in">memset</span>(arr2,<span class="number">0</span>,<span class="keyword">sizeof</span>(arr1));</span><br><span class="line">        <span class="built_in">memset</span>(arr1,<span class="number">0</span>,<span class="keyword">sizeof</span>(arr1));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">9</span>;++j)</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] != <span class="string">'.'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[i][board[i][j] - <span class="string">'1'</span>] || arr1[j][board[i][j] -<span class="string">'1'</span>] ||  arr2[<span class="number">3</span> * (i / <span class="number">3</span>) + (j / <span class="number">3</span>)][board[i][j] -<span class="string">'1'</span>])</span><br><span class="line">                     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    arr[i][board[i][j] - <span class="string">'1'</span>] = <span class="number">1</span>;</span><br><span class="line">                    arr1[j][board[i][j] -<span class="string">'1'</span>] = <span class="number">1</span>;</span><br><span class="line">                    arr2[<span class="number">3</span> * (i / <span class="number">3</span>) + (j / <span class="number">3</span>)][board[i][j] -<span class="string">'1'</span>] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>35.search insert position</title>
    <url>/2020/04/07/LeetCode_Cpp/0035._search_insert_position/</url>
    <content><![CDATA[<h1 id="35-search-insert-position"><a href="#35-search-insert-position" class="headerlink" title="35.search insert position"></a>35.search insert position</h1><p><strong><font color=red>难度:Easy</font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<p>*<a href="https://leetcode.com/problems/search-insert-position/" target="_blank" rel="noopener">https://leetcode.com/problems/search-insert-position/</a></p>
<ul>
<li><blockquote>
<p>内容描述</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</span><br><span class="line"></span><br><span class="line">You may assume no duplicates in the array.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路1<br><strong>**</strong>- 时间复杂度: O(lgN)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>由于数组是已经排序好的，这就是一个很典型的二分法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">0</span>,last = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(last &gt; (first + <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> medium = (last + first) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[medium] == target)</span><br><span class="line">                <span class="keyword">return</span> medium;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[medium] &lt; target)</span><br><span class="line">                first = medium;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                last = medium;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target &gt; nums[last])</span><br><span class="line">            <span class="keyword">return</span> last + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((target &lt; nums[first]) || (target == nums[first]))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路2<br><strong>**</strong>- 时间复杂度: O(lgN)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>其实这个思路也是二分法，只不过c++中已经给我们封装好了lower_bound，我们直接调用即可<br>代码看上去也简洁很多</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> pos = lower_bound(nums.begin(),nums.end(),target);</span><br><span class="line">        <span class="keyword">return</span> pos - nums.begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>38. Count and Say</title>
    <url>/2020/04/07/LeetCode_Cpp/0038._Count_and_Say/</url>
    <content><![CDATA[<h1 id="38-Count-and-Say"><a href="#38-Count-and-Say" class="headerlink" title="38. Count and Say"></a>38. Count and Say</h1><p><strong><font color=red>难度:Easy<font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/count-and-say/" target="_blank" rel="noopener">https://leetcode.com/problems/count-and-say/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The count-and-say sequence is the sequence of integers with the first five terms as following:</span><br><span class="line"></span><br><span class="line">1.     1</span><br><span class="line">2.     11</span><br><span class="line">3.     21</span><br><span class="line">4.     1211</span><br><span class="line">5.     111221</span><br><span class="line">1 is read off as &quot;one 1&quot; or 11.</span><br><span class="line">11 is read off as &quot;two 1s&quot; or 21.</span><br><span class="line">21 is read off as &quot;one 2, then one 1&quot; or 1211.</span><br><span class="line"></span><br><span class="line">Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence.</span><br><span class="line"></span><br><span class="line">Note: Each term of the sequence of integers will be represented as a string.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 1</span><br><span class="line">Output: &quot;1&quot;</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: 4</span><br><span class="line">Output: &quot;1211&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(n)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>首先要弄清楚题目的意思n == 1时就是1，接着念一个1就是 one 1，n == 2时就是“11”，接着念2个1就是 two 1，n == 3时就是“21”。再念1个2，1个1就是 one 2 one 1，n == 4时就是“1211”，接着依次类推，我们写个循环模拟上面的操作即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        str.push_back(<span class="string">'0'</span> + <span class="number">1</span>);</span><br><span class="line">        n--;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> temp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; str.length();)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(i + j &lt; str.length() &amp;&amp; str[i] == str[j + i])</span><br><span class="line">                    ++j;</span><br><span class="line">                temp.push_back(<span class="string">'0'</span> + j);</span><br><span class="line">                temp.push_back(str[i]);</span><br><span class="line">                i += j;</span><br><span class="line">            &#125;</span><br><span class="line">            --n;</span><br><span class="line">            str = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>39. Combination Sum</title>
    <url>/2020/04/07/LeetCode_Cpp/0039._Combination_Sum/</url>
    <content><![CDATA[<h1 id="39-Combination-Sum"><a href="#39-Combination-Sum" class="headerlink" title="39. Combination Sum"></a>39. Combination Sum</h1><p> 难度: Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combination-sum/</a></p>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</span><br><span class="line"></span><br><span class="line">candidates 中的数字可以无限制重复被选取。</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">所有数字（包括 target）都是正整数。</span><br><span class="line">解集不能包含重复的组合。 </span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: candidates &#x3D; [2,3,6,7], target &#x3D; 7,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: candidates &#x3D; [2,3,5], target &#x3D; 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">回溯</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> index, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">        ans.push_back(path);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;candidates.size();++i)&#123;</span><br><span class="line">        path.push_back(candidates[i]);</span><br><span class="line">        dfs(candidates, target-candidates[i], i, path, ans);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    sort(candidates.begin(), candidates.end());</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    dfs(candidates, target, <span class="number">0</span>, path, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>43. Multiply Strings</title>
    <url>/2020/04/07/LeetCode_Cpp/0043._Multiply_Strings/</url>
    <content><![CDATA[<h1 id="43-Multiply-Strings"><a href="#43-Multiply-Strings" class="headerlink" title="43. Multiply Strings"></a>43. Multiply Strings</h1><p><strong><font color=red>难度:Medium<font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/multiply-strings/" target="_blank" rel="noopener">https://leetcode.com/problems/multiply-strings/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: num1 &#x3D; &quot;2&quot;, num2 &#x3D; &quot;3&quot;</span><br><span class="line">Output: &quot;6&quot;</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: num1 &#x3D; &quot;123&quot;, num2 &#x3D; &quot;456&quot;</span><br><span class="line">Output: &quot;56088&quot;</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">The length of both num1 and num2 is &lt; 110.</span><br><span class="line">Both num1 and num2 contain only digits 0-9.</span><br><span class="line">Both num1 and num2 do not contain any leading zero, except the number 0 itself.</span><br><span class="line">You must not use any built-in BigInteger library or convert the inputs to integer directly.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路1<br><strong>**</strong>- 时间复杂度: O(n^2)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>由于这里的数字比较大超过了long long的最大值，因此不能转成数字，所以这里我们模拟两个数字的乘法。把每一位记录在一个字符串中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">multiply</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">                <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">int</span> d[<span class="number">120</span>][<span class="number">120</span>];</span><br><span class="line">        <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = num2.size() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;--i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> count1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = num1.size()- <span class="number">1</span>;j &gt;= <span class="number">0</span>;--j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> pro_ans = (num1[j] - <span class="string">'0'</span>) * (num2[i] - <span class="string">'0'</span>);</span><br><span class="line">                d[num2.size() - <span class="number">1</span> - i][num1.size() - j - <span class="number">1</span>] = pro_ans % <span class="number">10</span> + count1;</span><br><span class="line">                count1 = pro_ans / <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">if</span>(d[num2.size() - <span class="number">1</span> - i][num1.size() - j - <span class="number">1</span>] &gt;= <span class="number">10</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    count1++;</span><br><span class="line">                    d[num2.size() - <span class="number">1</span> - i][num1.size() - j - <span class="number">1</span>] %= <span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            d[num2.size() - <span class="number">1</span> - i][num1.size()] = count1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; num1.size() + num2.size();++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= num2.size();++i)</span><br><span class="line">                <span class="keyword">if</span>(j - i &gt;= <span class="number">0</span>  &amp;&amp; j - i &lt;= num1.size())</span><br><span class="line">                    count1 += d[i][j - i];</span><br><span class="line">            ans.push_back(count1 % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">            count1 /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(ans.length() &gt; <span class="number">1</span> &amp;&amp; ans[ans.length() - <span class="number">1</span>] == <span class="string">'0'</span>)</span><br><span class="line">            ans.pop_back();</span><br><span class="line">        reverse(ans.begin(),ans.end());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>42. Trapping Rain Water</title>
    <url>/2020/04/07/LeetCode_Cpp/0042._Trapping_Rain_Water/</url>
    <content><![CDATA[<h1 id="42-Trapping-Rain-Water"><a href="#42-Trapping-Rain-Water" class="headerlink" title="42. Trapping Rain Water"></a>42. Trapping Rain Water</h1><p><strong><font color=red>难度Hard<font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/trapping-rain-water/" target="_blank" rel="noopener">https://leetcode.com/problems/trapping-rain-water/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure>

<p>记录 l = 0，先正向遍历数组，如果 height[i] &lt; height[l],则说明此位置无法积水，记录无法积水的面积，如果 height[i] &gt;= height[l]，则说明[i,l]的区间内可以积水，然后减去无法积水的面积就是积水的面积。遍历完数组之后，如果 l != height.size() - 1，则反向遍历数组，进行上述步骤。 </p>
<blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(N)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,sum1 = <span class="number">0</span>,water = <span class="number">0</span>,i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>;i &lt; height.size();++i)</span><br><span class="line">            <span class="keyword">if</span>(height[i] &gt;= height[l])</span><br><span class="line">            &#123;</span><br><span class="line">                water = water + height[l] * (i - l - <span class="number">1</span>) - sum1;</span><br><span class="line">                l = i;</span><br><span class="line">                sum1 = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                sum1 += height[i];</span><br><span class="line">        <span class="keyword">if</span>(l !=  (height.size() - <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = l;</span><br><span class="line">            sum1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(i = height.size() - <span class="number">2</span>,l = height.size() - <span class="number">1</span>;i &gt;= temp;--i)</span><br><span class="line">                <span class="keyword">if</span>(height[i] &gt;= height[l])</span><br><span class="line">                &#123;</span><br><span class="line">                    water = water + height[l] * (l- i - <span class="number">1</span>) - sum1;</span><br><span class="line">                    l = i;</span><br><span class="line">                    sum1 = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sum1 += height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> water;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>41.First Missing Positive</title>
    <url>/2020/04/07/LeetCode_Cpp/0041._First_Missing_Positive/</url>
    <content><![CDATA[<h1 id="041-First-Missing-Positive"><a href="#041-First-Missing-Positive" class="headerlink" title="041.First Missing Positive"></a>041.First Missing Positive</h1><p><strong><font color=red>难度Hard</font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/first-missing-positive/" target="_blank" rel="noopener">https://leetcode.com/problems/first-missing-positive/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given an unsorted integer array, find the smallest missing positive integer.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [1,2,0]</span><br><span class="line">Output: 3</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [3,4,-1,1]</span><br><span class="line">Output: 2</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: [7,8,9,11,12]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(n)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>刚开始题目的意思理解错了，之后就依次AC了。其实这题如果不加限制条件额外的储存空间，应该会容易想到，直接 hash 表就行，这里我们可以遍历数组，若数组存在1，则在数组的第一个储存1，若2存在，则在数组的第二个位子，依次类推</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!nums.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.size();)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums.size() &amp;&amp; nums[i] != nums[nums[i] - <span class="number">1</span>])</span><br><span class="line">                swap(nums[i],nums[nums[i] - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.size();++i)</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> nums.size() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>40. Combination Sum II</title>
    <url>/2020/04/07/LeetCode_Cpp/0040._Combination_Sum_II/</url>
    <content><![CDATA[<h1 id="40-Combination-Sum-II"><a href="#40-Combination-Sum-II" class="headerlink" title="40. Combination Sum II"></a>40. Combination Sum II</h1><p> 难度: Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combination-sum-ii/</a></p>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</span><br><span class="line"></span><br><span class="line">candidates 中的每个数字在每个组合中只能使用一次。</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">所有数字（包括目标数）都是正整数。</span><br><span class="line">解集不能包含重复的组合。 </span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: candidates &#x3D; [2,5,2,1,2], target &#x3D; 5,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">回溯</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> index, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">        ans.push_back(path);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;candidates.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; index &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        path.push_back(candidates[i]);</span><br><span class="line">        dfs(candidates, target-candidates[i], i+<span class="number">1</span>, path, ans);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    sort(candidates.begin(), candidates.end());</span><br><span class="line">    dfs(candidates, target, <span class="number">0</span>, path, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>44. Wildcard Matching</title>
    <url>/2020/04/07/LeetCode_Cpp/0044._Wildcard_Matching/</url>
    <content><![CDATA[<h1 id="44-Wildcard-Matching"><a href="#44-Wildcard-Matching" class="headerlink" title="44. Wildcard Matching"></a>44. Wildcard Matching</h1><p><strong><font color=red>难度:Hard<font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/wildcard-matching/" target="_blank" rel="noopener">https://leetcode.com/problems/wildcard-matching/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for &#39;?&#39; and &#39;*&#39;.</span><br><span class="line"></span><br><span class="line">&#39;?&#39; Matches any single character.</span><br><span class="line">&#39;*&#39; Matches any sequence of characters (including the empty sequence).</span><br><span class="line">The matching should cover the entire input string (not partial).</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">s could be empty and contains only lowercase letters a-z.</span><br><span class="line">p could be empty and contains only lowercase letters a-z, and characters like ? or *.</span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &#39;*&#39; matches any sequence.</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;cb&quot;</span><br><span class="line">p &#x3D; &quot;?a&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &#39;?&#39; matches &#39;c&#39;, but the second letter is &#39;a&#39;, which does not match &#39;b&#39;.</span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;adceb&quot;</span><br><span class="line">p &#x3D; &quot;*a*b&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The first &#39;*&#39; matches the empty sequence, while the second &#39;*&#39; matches the substring &quot;dce&quot;.</span><br><span class="line">Example 5:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;acdcb&quot;</span><br><span class="line">p &#x3D; &quot;a*c?b&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(n^2)<strong>**</strong>- 空间复杂度: O(n^2)<strong>**</strong></p>
</blockquote>
<p>刚开始做的时候以为是一道大模拟题，但是做的时候才发现可以用DP。在使用DP时先找到状态转移方程。这里我们定义数组dp[i][j]表示第字符串 p 中第 i - 1个字母之前的字符串与字符串 s 中的第 j - 1个字母之前的子串匹配，我们就可以写出相应的状态转移方程当p[i] == ‘?’或者p[i] == s[j]时，dp[i + 1][j + 1] = dp[i][j],当p[i] == ‘*’时。j &lt; p.length(),所有dp[i + 1][j + 1] = dp[i][j],并且dp[i + 1][j] = dp[i][j],最后返回dp[p.length()][s.length() - 1]</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p.length())</span><br><span class="line">        <span class="keyword">return</span> !s.length();</span><br><span class="line">    s.push_back(<span class="string">' '</span>);</span><br><span class="line">    <span class="keyword">int</span> dp[p.length() + <span class="number">1</span>][s.length() + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i &lt;= p.length();++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= s.length();++j)</span><br><span class="line">            dp[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count1 = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; p.length();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j  = <span class="number">0</span>;j &lt; s.length();++j)</span><br><span class="line">            <span class="keyword">if</span>(p[i] == <span class="string">'?'</span> || p[i] == s[j])</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p[i] == <span class="string">'*'</span> &amp;&amp; dp[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                dp[i + <span class="number">1</span>][j] = <span class="number">1</span>;</span><br><span class="line">                ++j;</span><br><span class="line">                <span class="keyword">while</span>(j &lt; s.length())</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                    ++j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[p.length()][s.length() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>46. Permutations</title>
    <url>/2020/04/07/LeetCode_Cpp/0046._Permutations/</url>
    <content><![CDATA[<h1 id="46-Permutations"><a href="#46-Permutations" class="headerlink" title="46. Permutations"></a>46. Permutations</h1><p><strong><font color=red>难度:Medium<font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/permutations/" target="_blank" rel="noopener">https://leetcode.com/problems/permutations/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a collection of distinct integers, return all possible permutations.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: [1,2,3]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路1<br><strong>**</strong>- 时间复杂度: O(n!<em>n)*****</em>- 空间复杂度: O(n)<strong>**</strong></p>
</blockquote>
<p>很不错的考察递归的一道题，每次都将第一个和之后的数交换即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">   <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(!nums.size())</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">1</span>)</span><br><span class="line">            ans.push_back(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.size();++i)</span><br><span class="line">       &#123;</span><br><span class="line">            swap(nums[<span class="number">0</span>],nums[i]);</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(nums.begin() + <span class="number">1</span>,nums.end())</span></span>;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ret = permute(v);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; ret.size();++i)</span><br><span class="line">            &#123;</span><br><span class="line">                ret[i].push_back(nums[<span class="number">0</span>]);</span><br><span class="line">                ans.push_back(ret[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums[<span class="number">0</span>],nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路2<br><strong>**</strong>- 时间复杂度: O(n!)<strong>**</strong>- 空间复杂度: O(n)<strong>**</strong></p>
</blockquote>
<p>我们可以对上面的算法进行优化，用DFS的方法，每次记录已经搜索过的数字进行递归即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span>* visited,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; ans,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.size();++i)</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">        &#123;</span><br><span class="line">            temp.push_back(nums[i]);</span><br><span class="line">            visited[i] = <span class="number">1</span>;</span><br><span class="line">            DFS(visited,nums,ans,temp);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">            visited[i] = <span class="number">0</span>;</span><br><span class="line">            count1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(!count1)</span><br><span class="line">        ans.push_back(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line">        <span class="keyword">int</span> visited[nums.size()];</span><br><span class="line">        <span class="built_in">memset</span>(visited,<span class="number">0</span>,<span class="keyword">sizeof</span>(visited));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            visited[i] = <span class="number">1</span>;</span><br><span class="line">            temp.push_back(nums[i]);</span><br><span class="line">            DFS(visited,nums,ans,temp);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">            visited[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>47. Permutations II</title>
    <url>/2020/04/07/LeetCode_Cpp/0047._Permutations_II/</url>
    <content><![CDATA[<h1 id="47-Permutations-II"><a href="#47-Permutations-II" class="headerlink" title="47. Permutations II"></a>47. Permutations II</h1><p><strong><font color=red>难度:Medium<font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/permutations-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/permutations-ii/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a collection of numbers that might contain duplicates, return all possible unique permutations.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: [1,1,2]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,1,2],</span><br><span class="line">  [1,2,1],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路1<br><strong>**</strong>- 时间复杂度: O(n!<em>nlgn)*****</em>- 空间复杂度: O(n)<strong>**</strong></p>
</blockquote>
<p>和前面的那道题有点类似，可以参考之前的解法。由于做了之前的题目，我直接就用set去重了，虽然通过了，但是时间复杂度比较高，因此需要进行优化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span>* visited,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; ans,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> count1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.size();++i)</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">        &#123;</span><br><span class="line">            temp.push_back(nums[i]);</span><br><span class="line">            visited[i] = <span class="number">1</span>;</span><br><span class="line">            DFS(visited,nums,ans,temp);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">            visited[i] = <span class="number">0</span>;</span><br><span class="line">            count1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(!count1)</span><br><span class="line">        ans.insert(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permuteUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">               <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line">        <span class="keyword">int</span> visited[nums.size()];</span><br><span class="line">        <span class="built_in">memset</span>(visited,<span class="number">0</span>,<span class="keyword">sizeof</span>(visited));</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; s;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            visited[i] = <span class="number">1</span>;</span><br><span class="line">            temp.push_back(nums[i]);</span><br><span class="line">            DFS(visited,nums,s,temp);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">            visited[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> pos = s.begin();pos != s.end();++pos)</span><br><span class="line">            ans.push_back(*pos);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路2<br><strong>**</strong>- 时间复杂度: O(n!)<strong>**</strong>- 空间复杂度: O(n)<strong>**</strong></p>
</blockquote>
<p>有了之前那道题的经验。我们也可以通过DFS的方法去解，但是有个问题，有相同的数字就会产生重复。因此先对数组进行排序，这样相同的数字就会出现在一起，然后进行DFS时，由于我们是从左往右进行的，因此当一个数与之前的数相等并且之前的数字已经搜索过了，那么我们就不必再搜索这个数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permuteUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        vector&lt;int&gt; visited(n, 0), arr;</span><br><span class="line">        dfs(nums, ret, arr, visited);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ret, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.size() == nums.size()) &#123;</span><br><span class="line">            ret.push_back(arr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i]) &#123;<span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span> (i <span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &amp;&amp; !visited[i<span class="number">-1</span>]) &#123;<span class="keyword">continue</span>;&#125;</span><br><span class="line">            arr.push_back(nums[i]);</span><br><span class="line">            visited[i] = <span class="number">1</span>;</span><br><span class="line">            dfs(nums, ret, arr, visited);</span><br><span class="line">            arr.pop_back();</span><br><span class="line">            visited[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>45. Jump Game II</title>
    <url>/2020/04/07/LeetCode_Cpp/0045._Jump_Game_II/</url>
    <content><![CDATA[<h1 id="045-Jump-Game-II"><a href="#045-Jump-Game-II" class="headerlink" title="045. Jump Game II"></a>045. Jump Game II</h1><p><strong><font color=red>难度Hard<font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/jump-game-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/jump-game-ii/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given an array of non-negative integers, you are initially positioned at the first index of the array.</span><br><span class="line"></span><br><span class="line">Each element in the array represents your maximum jump length at that position.</span><br><span class="line"></span><br><span class="line">Your goal is to reach the last index in the minimum number of jumps.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: [2,3,1,1,4]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The minimum number of jumps to reach the last index is 2.</span><br><span class="line">    Jump 1 step from index 0 to 1, then 3 steps to the last index.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(n)<strong><strong><em>- 空间复杂度: O(1)*</em></strong></strong></p>
</blockquote>
<p>刚开始想到使用动态规划，时间复杂度为O(n)，但是TLE了，其实可以在O(n)的时间复杂度内完成的。遍历数组，每次都走到在nums[i]的范围里能走到的最远的距离。记录ans。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,length = nums.size(),next = nums[<span class="number">0</span>],ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; length)</span><br><span class="line">        &#123;</span><br><span class="line">             ++ans;</span><br><span class="line">            <span class="keyword">if</span>(next &gt;= length - <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">            <span class="keyword">int</span> current = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = current+<span class="number">1</span>;j &lt;= min(next,length - <span class="number">1</span>);++j)</span><br><span class="line">            &#123;</span><br><span class="line">                i = max(i,nums[j] + j);</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(i,next);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>&lt;&lt; next &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>49. Group Anagrams</title>
    <url>/2020/04/07/LeetCode_Cpp/0049._Group_Anagrams/</url>
    <content><![CDATA[<h1 id="49-Group-Anagrams"><a href="#49-Group-Anagrams" class="headerlink" title="49. Group Anagrams"></a>49. Group Anagrams</h1><p> 难度: Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/group-anagrams/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/group-anagrams/submissions/</a></p>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">所有输入均为小写字母。</span><br><span class="line">不考虑答案输出的顺序。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">不同的组别字符串元素相同，顺序不同，所以排序后相同</span><br><span class="line">把排序后相同的元素映射到同一个vector</span><br><span class="line">所有vector的组合就是结果</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">groupAnagrams</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; maps;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strs.size();i++)&#123;</span><br><span class="line">        <span class="built_in">string</span> tmp = strs[i];</span><br><span class="line">        sort(tmp.begin(), tmp.end());</span><br><span class="line">        maps[tmp].push_back(strs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item:maps)&#123;</span><br><span class="line">        ans.push_back(item.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>51. N-Queens</title>
    <url>/2020/04/07/LeetCode_Cpp/0051._%20N-Queens/</url>
    <content><![CDATA[<h1 id="51-N-Queens"><a href="#51-N-Queens" class="headerlink" title="51. N-Queens"></a>51. N-Queens</h1><p><strong><font color=red>难度:Hard<font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/n-queens/" target="_blank" rel="noopener">https://leetcode.com/problems/n-queens/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Given an integer n, return all distinct solutions to the n-queens puzzle.</span><br><span class="line"></span><br><span class="line">Each solution contains a distinct board configuration of the n-queens&#39; placement, where &#39;Q&#39; and &#39;.&#39; both indicate a queen and an empty space respectively.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: 4</span><br><span class="line">Output: [</span><br><span class="line"> [&quot;.Q..&quot;,  &#x2F;&#x2F; Solution 1</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;..Q.&quot;],</span><br><span class="line"></span><br><span class="line"> [&quot;..Q.&quot;,  &#x2F;&#x2F; Solution 2</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;.Q..&quot;]</span><br><span class="line">]</span><br><span class="line">Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路1<br><strong>**</strong>- 时间复杂度: O(2^n)<strong>**</strong>- 空间复杂度: O(n)<strong>**</strong></p>
</blockquote>
<p>用回溯法去解这题。遇到合适的就继续搜索，不合适的就回退，这里用三个数组分别记录竖直方向，右斜上方和左斜上方是否有皇后。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">travel</span><span class="params">(<span class="keyword">int</span>* d,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ret,<span class="keyword">int</span> level,<span class="keyword">int</span> n,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt;&amp; ans,<span class="keyword">int</span>* l,<span class="keyword">int</span>* r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(level &gt;= n)</span><br><span class="line">            ans.push_back(ret);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;++i)</span><br><span class="line">            <span class="keyword">if</span>(!d[i] &amp;&amp; !r[level + i] &amp;&amp; !l[i - level + n])</span><br><span class="line">            &#123;</span><br><span class="line">                d[i] = <span class="number">1</span>;</span><br><span class="line">                r[level + i] = <span class="number">1</span>;</span><br><span class="line">                l[i- level + n] = <span class="number">1</span>;</span><br><span class="line">                ret[level][i] = <span class="string">'Q'</span>;</span><br><span class="line">                travel(d,ret,level + <span class="number">1</span>,n,ans,l,r);</span><br><span class="line">                d[i] = <span class="number">0</span>;</span><br><span class="line">                r[level + i] = <span class="number">0</span>;</span><br><span class="line">                l[i- level + n] = <span class="number">0</span>;</span><br><span class="line">                ret[level][i] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">solveNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> d[n];</span><br><span class="line">        <span class="keyword">int</span> l[<span class="number">2</span> * n];</span><br><span class="line">        <span class="keyword">int</span> r[<span class="number">2</span> * n];</span><br><span class="line">        <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line">        <span class="built_in">memset</span>(l,<span class="number">0</span>,<span class="keyword">sizeof</span>(l));</span><br><span class="line">        <span class="built_in">memset</span>(r,<span class="number">0</span>,<span class="keyword">sizeof</span>(r));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; temp;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; ans;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(n,<span class="string">'.'</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;++i)</span><br><span class="line">            temp.push_back(s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            temp[<span class="number">0</span>][i] =<span class="string">'Q'</span>;</span><br><span class="line">            d[i] = <span class="number">1</span>;</span><br><span class="line">            r[i] = <span class="number">1</span>;</span><br><span class="line">            l[i + n] = <span class="number">1</span>;</span><br><span class="line">            travel(d,temp,<span class="number">1</span>,n,ans,l,r);</span><br><span class="line">            temp[<span class="number">0</span>][i] = <span class="string">'.'</span>;</span><br><span class="line">            d[i] = <span class="number">0</span>;</span><br><span class="line">            r[i] = <span class="number">0</span>;</span><br><span class="line">            l[i + n] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>50. powx n</title>
    <url>/2020/04/07/LeetCode_Cpp/0050._powx_n/</url>
    <content><![CDATA[<h1 id="50-powx-n"><a href="#50-powx-n" class="headerlink" title="50. powx n"></a>50. powx n</h1><p>难度:Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/powx-n/" target="_blank" rel="noopener">https://leetcode.com/problems/powx-n/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mplement pow(x, n), which calculates x raised to the power n (xn).</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 2.00000, 10</span><br><span class="line">Output: 1024.00000</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: 2.10000, 3</span><br><span class="line">Output: 9.26100</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: 2.00000, -2</span><br><span class="line">Output: 0.25000</span><br><span class="line">Explanation: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">-100.0 &lt; x &lt; 100.0</span><br><span class="line">n is a 32-bit signed integer, within the range [?2^31, 2^31 ? 1]</span><br></pre></td></tr></table></figure>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><blockquote>
<p>思路1<br><strong>**</strong>- 时间复杂度: O(lgN)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>求一个数的n次方是我们经常用的函数，一般刚开始可能会用暴力的方法去求，做了n次循环，但由于这里的n非常大，单纯的暴力会TLE，这里可以用分治的思想，比如<code>2*2*2*2</code>，我们前面已经计算过<code>2*2</code>了，那么后面就不用再计算依次，就相当于<code>2*2*（2*2）</code>,这样时间复杂度就变成了lgN，接下来只要主要幂次是负数的情况即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Pow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> <span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!n)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">double</span> temp = Pow(x,(n)/ <span class="number">2</span>);</span><br><span class="line">         <span class="keyword">double</span> ret;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)</span><br><span class="line">            ret = temp * temp * x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ret = temp * temp;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> k = n;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">        <span class="keyword">return</span> Pow(x,n);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>52. N-Queens II</title>
    <url>/2020/04/07/LeetCode_Cpp/0052._N-Queens_II/</url>
    <content><![CDATA[<h1 id="52-N-Queens-II"><a href="#52-N-Queens-II" class="headerlink" title="52. N-Queens II"></a>52. N-Queens II</h1><p><strong><font color=red>难度:Hard<font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/n-queens-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/n-queens-ii/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Given an integer n, return the number of distinct solutions to the n-queens puzzle.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: 4</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two distinct solutions to the 4-queens puzzle as shown below.</span><br><span class="line">[</span><br><span class="line"> [&quot;.Q..&quot;,  &#x2F;&#x2F; Solution 1</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;..Q.&quot;],</span><br><span class="line"></span><br><span class="line"> [&quot;..Q.&quot;,  &#x2F;&#x2F; Solution 2</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;.Q..&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路1<br><strong>**</strong>- 时间复杂度: O(2^n)<strong>**</strong>- 空间复杂度: O(n)<strong>**</strong></p>
</blockquote>
<p>这题和上一道题基本一样，只是求次数。稍微改动一下就好，具体的不多说了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">travel</span><span class="params">(<span class="keyword">int</span>* d,<span class="keyword">int</span> level,<span class="keyword">int</span> n,<span class="keyword">int</span>* l,<span class="keyword">int</span>* r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(level &gt;= n)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;++i)</span><br><span class="line">            <span class="keyword">if</span>(!d[i] &amp;&amp; !r[level + i] &amp;&amp; !l[i - level + n])</span><br><span class="line">            &#123;</span><br><span class="line">                d[i] = <span class="number">1</span>;</span><br><span class="line">                r[level + i] = <span class="number">1</span>;</span><br><span class="line">                l[i- level + n] = <span class="number">1</span>;</span><br><span class="line">                ans += travel(d,level + <span class="number">1</span>,n,l,r);</span><br><span class="line">                d[i] = <span class="number">0</span>;</span><br><span class="line">                r[level + i] = <span class="number">0</span>;</span><br><span class="line">                l[i- level + n] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> d[n];</span><br><span class="line">        <span class="keyword">int</span> l[<span class="number">2</span> * n];</span><br><span class="line">        <span class="keyword">int</span> r[<span class="number">2</span> * n];</span><br><span class="line">        <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line">        <span class="built_in">memset</span>(l,<span class="number">0</span>,<span class="keyword">sizeof</span>(l));</span><br><span class="line">        <span class="built_in">memset</span>(r,<span class="number">0</span>,<span class="keyword">sizeof</span>(r));</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            d[i] = <span class="number">1</span>;</span><br><span class="line">            r[i] = <span class="number">1</span>;</span><br><span class="line">            l[i + n] = <span class="number">1</span>;</span><br><span class="line">            ans += travel(d,<span class="number">1</span>,n,l,r);</span><br><span class="line">            d[i] = <span class="number">0</span>;</span><br><span class="line">            r[i] = <span class="number">0</span>;</span><br><span class="line">            l[i + n] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>53. Maximum Subarray</title>
    <url>/2020/04/07/LeetCode_Cpp/0053._Maximum_Subarray/</url>
    <content><![CDATA[<h1 id="53-Maximum-Subarray"><a href="#53-Maximum-Subarray" class="headerlink" title="53. Maximum Subarray"></a>53. Maximum Subarray</h1><p><strong><font color=red>难度Easy<font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/maximum-subarray/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-subarray/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [4,-1,2,1] has the largest sum &#x3D; 6.</span><br><span class="line">Follow up:</span><br><span class="line"></span><br><span class="line">If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路1<br><strong>**</strong>- 时间复杂度: O(lgn)<strong><strong><em>- 空间复杂度: O(1)*</em></strong></strong></p>
</blockquote>
<p>如果用暴力的方法去解，大部分人都会想到，这里我们可以对算法进行优化，这里我们用分治法的思想，把数组对半分为两个子数组，接着数组的最大值可能在[left,mid]区间，[mid + 1,right]区间或者在横跨mid的区间内，只要取这三个区间的最大值即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> beg,<span class="keyword">int</span> en)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(beg == en)</span><br><span class="line">            <span class="keyword">return</span> nums[en];</span><br><span class="line">        <span class="keyword">int</span> mid = (beg + en) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = max(findArray(nums,beg,mid),findArray(nums,mid + <span class="number">1</span>,en));</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>,max1 = INT_MIN,max2 = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = mid;i &gt;= beg;--i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            max1 = max(max1,sum);</span><br><span class="line">        &#125;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = mid + <span class="number">1</span>;i &lt;= en;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            max2 = max(max2,sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(temp,max1 + max2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> findArray(nums,<span class="number">0</span>,nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路2<br><strong>**</strong>- 时间复杂度: O(n)<strong><strong><em>- 空间复杂度: O(1)*</em></strong></strong></p>
</blockquote>
<p>这里还可以在O(n)的时间复杂度求解，遍历数组，若ret &gt; 0,ret =nums[i]<br>否则ret += nums[i]</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.size(),ret = nums[<span class="number">0</span>],ans = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; length;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ret &lt;= <span class="number">0</span>)</span><br><span class="line">            ret = nums[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ret += nums[i];</span><br><span class="line">        ans = max(ans,ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>54. Spiral Matrix</title>
    <url>/2020/04/07/LeetCode_Cpp/0054._Spiral_Matrix/</url>
    <content><![CDATA[<h1 id="54-Spiral-Matrix"><a href="#54-Spiral-Matrix" class="headerlink" title="54. Spiral Matrix"></a>54. Spiral Matrix</h1><p><strong><font color=red>难度:Medium<font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/spiral-matrix/submissions/" target="_blank" rel="noopener">https://leetcode.com/problems/spiral-matrix/submissions/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 4, 5, 6 ],</span><br><span class="line"> [ 7, 8, 9 ]</span><br><span class="line">]</span><br><span class="line">Output: [1,2,3,6,9,8,7,4,5]</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [1, 2, 3, 4],</span><br><span class="line">  [5, 6, 7, 8],</span><br><span class="line">  [9,10,11,12]</span><br><span class="line">]</span><br><span class="line">Output: [1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路1<br><strong>**</strong>- 时间复杂度: O(n<em>m)*****</em>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>螺旋遍历数组，找到规律就行，好像没什么难度</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(!matrix.size())</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">int</span> row = matrix[<span class="number">0</span>].size(),colunm = matrix.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (matrix.size() + <span class="number">1</span>) / <span class="number">2</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(row &lt; <span class="number">1</span> || colunm &lt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; row;++j)</span><br><span class="line">                ans.push_back(matrix[i][i + j]);</span><br><span class="line">            <span class="keyword">if</span>(colunm &lt;= <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; colunm;++j)</span><br><span class="line">                ans.push_back(matrix[i + j][row + i - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(row &lt;= <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; row;++j)</span><br><span class="line">                ans.push_back(matrix[i + colunm - <span class="number">1</span>][row + i - <span class="number">1</span> - j]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; colunm - <span class="number">1</span>;++j)</span><br><span class="line">                ans.push_back(matrix[i + colunm - <span class="number">1</span> - j][i]);</span><br><span class="line">            row -= <span class="number">2</span>;</span><br><span class="line">            colunm -= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>56. Merge Intervals</title>
    <url>/2020/04/07/LeetCode_Cpp/0056._Merge_Intervals/</url>
    <content><![CDATA[<h1 id="56-Merge-Intervals"><a href="#56-Merge-Intervals" class="headerlink" title="56. Merge Intervals"></a>56. Merge Intervals</h1><p><strong><font color=red>难度:Medium<font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/merge-intervals/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-intervals/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a collection of intervals, merge all overlapping intervals.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">Output: [[1,6],[8,10],[15,18]]</span><br><span class="line">Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [[1,4],[4,5]]</span><br><span class="line">Output: [[1,5]]</span><br><span class="line">Explanation: Intervals [1,4] and [4,5] are considered overlapping.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路1<br><strong>**</strong>- 时间复杂度: O(nlgn)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>这里我们要先对数组进行排序，按照start进行升序排序。接下来就遍历排序好的数组，如过不相交就将两个区间都存入ans。如果相交就将合并后的区间的并入ans。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * struct Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() : start(0), end(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;Interval&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">         <span class="built_in">vector</span>&lt;Interval&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(!intervals.size())</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        sort(intervals.begin(),intervals.end(),[](Interval a, Interval b)&#123;<span class="keyword">return</span> a.start &lt; b.start;&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; intervals.size() - <span class="number">1</span>;++i)</span><br><span class="line">            <span class="keyword">if</span>(intervals[i + <span class="number">1</span>].start &lt;= intervals[i].end)</span><br><span class="line">            &#123;</span><br><span class="line">                intervals[i + <span class="number">1</span>].start = intervals[i].start;</span><br><span class="line">                intervals[i].end = max(intervals[i].end,intervals[i + <span class="number">1</span>].end);</span><br><span class="line">                intervals[i + <span class="number">1</span>].end = intervals[i].end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans.push_back(intervals[i]);</span><br><span class="line">        ans.push_back(intervals[intervals.size() - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>55. Jump Game</title>
    <url>/2020/04/07/LeetCode_Cpp/0055._Jump_Game/</url>
    <content><![CDATA[<h1 id="55-Jump-Game"><a href="#55-Jump-Game" class="headerlink" title="55. Jump Game"></a>55. Jump Game</h1><p><strong><font color=red>难度:Medium<font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/jump-game/submissions/" target="_blank" rel="noopener">https://leetcode.com/problems/jump-game/submissions/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given an array of non-negative integers, you are initially positioned at the first index of the array.</span><br><span class="line"></span><br><span class="line">Each element in the array represents your maximum jump length at that position.</span><br><span class="line"></span><br><span class="line">Determine if you are able to reach the last index.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [2,3,1,1,4]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [3,2,1,0,4]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: You will always arrive at index 3 no matter what. Its maximum</span><br><span class="line">             jump length is 0, which makes it impossible to reach the last index.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(N)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>刚开始想到的就是DP的方法，但是用DP的话时间复杂度为O(n^2)，很显然我们可以对算法进行优化,在时间复杂度O(n)内完成。我们只需要判断每一步能走的最远的距离即可，比如数组[2,3,1,1,4]，第一步只能走到0，第二步在区间[1，2]中找最远的距离为4。依次类推</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,r = <span class="number">0</span>;i &lt; nums.size() - <span class="number">1</span>;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> max1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt;= r)</span><br><span class="line">            &#123;</span><br><span class="line">                max1 = max(max1,i + nums[i]);</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; max1 &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span>(max1 &gt;= nums.size() - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(max1 &lt;= r)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            r = max1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>57. Insert Interval</title>
    <url>/2020/04/07/LeetCode_Cpp/0057._Insert_Interval/</url>
    <content><![CDATA[<h1 id="57-Insert-Interval"><a href="#57-Insert-Interval" class="headerlink" title="57. Insert Interval"></a>57. Insert Interval</h1><p><strong><font color=red>难度:Hard<font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/insert-interval/" target="_blank" rel="noopener">https://leetcode.com/problems/insert-interval/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).</span><br><span class="line"></span><br><span class="line">You may assume that the intervals were initially sorted according to their start times.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: intervals &#x3D; [[1,3],[6,9]], newInterval &#x3D; [2,5]</span><br><span class="line">Output: [[1,5],[6,9]]</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: intervals &#x3D; [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval &#x3D; [4,8]</span><br><span class="line">Output: [[1,2],[3,10],[12,16]]</span><br><span class="line">Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(N)<strong>**</strong>- 空间复杂度: O(N)<strong>**</strong></p>
</blockquote>
<p>先计算出新区间在原先区间数组中的位置。遍历数组，依次比较两个区间。记录 l 和r。分别代表了要添加的区间的起点和终点。得到位置之后，找到 intervals[i].end &lt; l,添加进返回数组，接着再添加区间[l,r]。最后添加 intervals[i].start &gt; r的区间。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * struct Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() : start(0), end(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;Interval&gt; <span class="title">insert</span><span class="params">(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals, Interval newInterval)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> beg = newInterval.start,en = newInterval.end,l = beg,r = en;</span><br><span class="line">        <span class="keyword">int</span> comp = beg;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; intervals.size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(comp &lt; intervals[i].start)</span><br><span class="line">            &#123;</span><br><span class="line">                comp == beg ? l = beg : r = en;</span><br><span class="line">                comp = comp == beg ? en : beg;</span><br><span class="line">                <span class="keyword">if</span>(comp == en &amp;&amp; en &lt; intervals[i].start)</span><br><span class="line">                &#123;</span><br><span class="line">                    r = en;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(comp == beg)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(comp &lt;= intervals[i].end)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                comp == beg ? l = intervals[i].start : r = intervals[i].end;</span><br><span class="line">                comp = comp == beg ? en : beg;</span><br><span class="line">                <span class="keyword">if</span>(comp == en &amp;&amp; en &lt;= intervals[i].end)</span><br><span class="line">                &#123;</span><br><span class="line">                    r = intervals[i].end;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(comp == beg)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Interval&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(;i &lt; intervals.size();++i)</span><br><span class="line">            <span class="keyword">if</span>(intervals[i].end &lt; l)</span><br><span class="line">                ans.push_back(intervals[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="function">Interval <span class="title">i1</span><span class="params">(l,r)</span></span>;</span><br><span class="line">        ans.push_back(i1);</span><br><span class="line">        <span class="keyword">for</span>(;i &lt; intervals.size();++i)</span><br><span class="line">            <span class="keyword">if</span>(intervals[i].start &gt; r)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i &lt; intervals.size();++i)</span><br><span class="line">            ans.push_back(intervals[i]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>58. Length of Last Word</title>
    <url>/2020/04/07/LeetCode_Cpp/0058._Length_of_Last_Word/</url>
    <content><![CDATA[<h1 id="58-Length-of-Last-Word58-Length-of-Last-Word"><a href="#58-Length-of-Last-Word58-Length-of-Last-Word" class="headerlink" title="58. Length of Last Word58. Length of Last Word"></a>58. Length of Last Word58. Length of Last Word</h1><p>难度:Easy</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/length-of-last-word/" target="_blank" rel="noopener">https://leetcode.com/problems/length-of-last-word/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a string s consists of upper&#x2F;lower-case alphabets and empty space characters &#39; &#39;, return the length of last word in the string.</span><br><span class="line"></span><br><span class="line">If the last word does not exist, return 0.</span><br></pre></td></tr></table></figure>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(n)<strong><strong><em>- 空间复杂度: O(1)*</em></strong></strong></p>
</blockquote>
<p>这题我们只要从字符串的末尾开始向前找到第一个单词即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = s.length() - <span class="number">1</span>,length = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((s[i] == <span class="string">' '</span>) &amp;&amp;(i &gt;= <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            --i;</span><br><span class="line">            --length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>((s[i] != <span class="string">' '</span>) &amp;&amp; (i &gt;= <span class="number">0</span>))</span><br><span class="line">            --i;</span><br><span class="line">        <span class="keyword">return</span> length- i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>61. Rotate List</title>
    <url>/2020/04/07/LeetCode_Cpp/0061._Rotate_List/</url>
    <content><![CDATA[<h1 id="61-Rotate-List"><a href="#61-Rotate-List" class="headerlink" title="61. Rotate List"></a>61. Rotate List</h1><p><strong><font color=red>难度:Medium<font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/rotate-list/" target="_blank" rel="noopener">https://leetcode.com/problems/rotate-list/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Given a linked list, rotate the list to the right by k places, where k is non-negative.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k &#x3D; 2</span><br><span class="line"></span><br><span class="line">Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL</span><br><span class="line"></span><br><span class="line">rotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Input: 0-&gt;1-&gt;2-&gt;NULL, k &#x3D; 4</span><br><span class="line"></span><br><span class="line">Output: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class="line"></span><br><span class="line">rotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULL</span><br><span class="line"></span><br><span class="line">rotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULL</span><br><span class="line"></span><br><span class="line">rotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>



<blockquote>
<p>思路1</p>
</blockquote>
<p><strong>**</strong>- 时间复杂度: O(n)<strong>**</strong>- 空间复杂度: O(n)<strong>**</strong></p>
<p>这里的n是指链表的长度，我们用k对n的长度取余，因为k大于链表的长度之后就是一个循环。不需要重复操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        ListNode* h = head;</span><br><span class="line">        ListNode* pre;</span><br><span class="line">        <span class="keyword">while</span>(h)</span><br><span class="line">        &#123;</span><br><span class="line">            ++len;</span><br><span class="line">            pre = h;</span><br><span class="line">            h = h -&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!len)</span><br><span class="line">            <span class="keyword">return</span> head;    </span><br><span class="line">        <span class="keyword">int</span> count1 = len - k % len;</span><br><span class="line">        <span class="keyword">if</span>(count1 == len)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        h = head;</span><br><span class="line">        ListNode* tail;</span><br><span class="line">        <span class="keyword">while</span>(count1)</span><br><span class="line">        &#123;</span><br><span class="line">            tail = h;</span><br><span class="line">            h = h -&gt;next;</span><br><span class="line">            --count1;</span><br><span class="line">        &#125;</span><br><span class="line">        pre -&gt;next = head;</span><br><span class="line">        tail -&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>62. Unique Paths</title>
    <url>/2020/04/07/LeetCode_Cpp/0062._Unique_Paths/</url>
    <content><![CDATA[<h1 id="62-Unique-Paths"><a href="#62-Unique-Paths" class="headerlink" title="62. Unique Paths"></a>62. Unique Paths</h1><p> 难度: Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-paths/</a></p>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</span><br><span class="line"></span><br><span class="line">机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</span><br><span class="line"></span><br><span class="line">问总共有多少条不同的路径？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">例如，上图是一个7 x 3 的网格。有多少可能的路径？</span><br><span class="line"></span><br><span class="line">说明：m 和 n 的值均不超过 100。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: m &#x3D; 3, n &#x3D; 2</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line">2. 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向右</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: m &#x3D; 7, n &#x3D; 3</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">动态规划，走到(i,j)可以从(i-1,j),(i, j-1)两个方向</span><br><span class="line">最优子结构：</span><br><span class="line">    dp[i, j] &#x3D; dp[i-1, j]+dp[i, j-1]</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            dp[i][j]=dp[i<span class="number">-1</span>][j]+dp[i][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>60. Permutation Sequence</title>
    <url>/2020/04/07/LeetCode_Cpp/0060._Permutation_Sequence/</url>
    <content><![CDATA[<h1 id="60-Permutation-Sequence"><a href="#60-Permutation-Sequence" class="headerlink" title="60. Permutation Sequence"></a>60. Permutation Sequence</h1><p><strong><font color=red>难度:Medium<font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/permutation-sequence/" target="_blank" rel="noopener">https://leetcode.com/problems/permutation-sequence/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The set [1,2,3,...,n] contains a total of n! unique permutations.</span><br><span class="line"></span><br><span class="line">By listing and labeling all of the permutations in order, we get the following sequence for n &#x3D; 3:</span><br><span class="line"></span><br><span class="line">&quot;123&quot;</span><br><span class="line">&quot;132&quot;</span><br><span class="line">&quot;213&quot;</span><br><span class="line">&quot;231&quot;</span><br><span class="line">&quot;312&quot;</span><br><span class="line">&quot;321&quot;</span><br><span class="line">Given n and k, return the kth permutation sequence.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">Given n will be between 1 and 9 inclusive.</span><br><span class="line">Given k will be between 1 and n! inclusive.</span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: n &#x3D; 3, k &#x3D; 3</span><br><span class="line">Output: &quot;213&quot;</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: n &#x3D; 4, k &#x3D; 9</span><br><span class="line">Output: &quot;2314&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路1<br><strong>**</strong>- 时间复杂度: O(n^2)<strong>**</strong>- 空间复杂度: O(n)<strong>**</strong></p>
</blockquote>
<p>先将所有数按顺序存在有个字符串中，然后循环n次，每次找到正确的数，由于earse时间复杂度为n，所以总的时间复杂度为n^2</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[n + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">string</span> ans,org;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            org.push_back(i + <span class="string">'0'</span>);</span><br><span class="line">            i == <span class="number">1</span> ? arr[i] = <span class="number">1</span> : arr[i] = arr[i - <span class="number">1</span>] * i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>;i &gt; <span class="number">0</span>;--i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = k / arr[i];</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt; t&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            k = (k) % arr[i];</span><br><span class="line">            <span class="keyword">if</span>(!k)</span><br><span class="line">            &#123;</span><br><span class="line">                k = arr[i];</span><br><span class="line">                t--;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(org[t]);</span><br><span class="line">            org.erase(org.begin() + t);</span><br><span class="line">            arr[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.push_back(org[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>59. Spiral Matrix II</title>
    <url>/2020/04/07/LeetCode_Cpp/0059._Spiral_Matrix_II/</url>
    <content><![CDATA[<h1 id="59-Spiral-Matrix-II"><a href="#59-Spiral-Matrix-II" class="headerlink" title="59. Spiral Matrix II"></a>59. Spiral Matrix II</h1><p><strong><font color=red>难度:Medium<font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/spiral-matrix-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/spiral-matrix-ii/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a positive integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: 3</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 8, 9, 4 ],</span><br><span class="line"> [ 7, 6, 5 ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路1<br><strong>**</strong>- 时间复杂度: O(n^2)<strong>**</strong>- 空间复杂度: O(n^2)<strong>**</strong></p>
</blockquote>
<p>和之前的旋转遍历矩阵一样的方法，只不过这里我们要先分配一个矩阵储存，因为vector数组不好操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">generateMatrix</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp[n][n];</span><br><span class="line">        <span class="keyword">int</span> range = n,cur = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (n + <span class="number">1</span>) / <span class="number">2</span> ;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; range;++j)</span><br><span class="line">                temp[i][j + i] = cur++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; range;++j)</span><br><span class="line">                temp[i + j][i + range - <span class="number">1</span>] = cur++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; range;++j)</span><br><span class="line">                temp[i + range - <span class="number">1</span>][range + i - <span class="number">1</span> -j] = cur++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; range - <span class="number">1</span>;++j)</span><br><span class="line">                temp[range + i - <span class="number">1</span> - j][i] = cur++;</span><br><span class="line">            range -= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;++j)</span><br><span class="line">                v.push_back(temp[i][j]);</span><br><span class="line">            ans.push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>65. Valid Number</title>
    <url>/2020/04/07/LeetCode_Cpp/0065._Valid_Number/</url>
    <content><![CDATA[<h1 id="65-Valid-Number"><a href="#65-Valid-Number" class="headerlink" title="65. Valid Number"></a>65. Valid Number</h1><p><strong><font color=red>难度:Hard<font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/valid-number/" target="_blank" rel="noopener">https://leetcode.com/problems/valid-number/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Validate if a given string can be interpreted as a decimal number.</span><br><span class="line"></span><br><span class="line">Some examples:</span><br><span class="line">&quot;0&quot; &#x3D;&gt; true</span><br><span class="line">&quot; 0.1 &quot; &#x3D;&gt; true</span><br><span class="line">&quot;abc&quot; &#x3D;&gt; false</span><br><span class="line">&quot;1 a&quot; &#x3D;&gt; false</span><br><span class="line">&quot;2e10&quot; &#x3D;&gt; true</span><br><span class="line">&quot; -90e3   &quot; &#x3D;&gt; true</span><br><span class="line">&quot; 1e&quot; &#x3D;&gt; false</span><br><span class="line">&quot;e3&quot; &#x3D;&gt; false</span><br><span class="line">&quot; 6e-1&quot; &#x3D;&gt; true</span><br><span class="line">&quot; 99e2.5 &quot; &#x3D;&gt; false</span><br><span class="line">&quot;53.5e93&quot; &#x3D;&gt; true</span><br><span class="line">&quot; --6 &quot; &#x3D;&gt; false</span><br><span class="line">&quot;-+3&quot; &#x3D;&gt; false</span><br><span class="line">&quot;95a54e53&quot; &#x3D;&gt; false</span><br><span class="line">Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. However, here is a list of characters that can be in a valid decimal number:</span><br><span class="line"></span><br><span class="line">Numbers 0-9</span><br><span class="line">Exponent - &quot;e&quot;</span><br><span class="line">Positive&#x2F;negative sign - &quot;+&quot;&#x2F;&quot;-&quot;</span><br><span class="line">Decimal point - &quot;.&quot;</span><br><span class="line">Of course, the context of these characters also matters in the input.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(N)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>这题做了蛮久的，题目其实不难主要遍历字符串符合要求即可，但要把所有的情况都考虑进去。比如number允许前后有若干个空格，“.1”和”1.”属于合法的数字。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">blank</span><span class="params">(<span class="keyword">int</span>&amp; i,<span class="built_in">string</span>&amp; s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; s.length() &amp;&amp; s[i] == <span class="string">' '</span>)</span><br><span class="line">            i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">firstHalf</span><span class="params">(<span class="keyword">int</span>&amp; i,<span class="built_in">string</span>&amp; s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i &lt; s.length();++i)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isdigit</span>(s[i]))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">'.'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(num)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">'e'</span> || s[i] == <span class="string">' '</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">secondHalf</span><span class="params">(<span class="keyword">int</span>&amp; i,<span class="built_in">string</span>&amp; s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == s.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[i] ==<span class="string">'-'</span> || s[i] == <span class="string">'+'</span>)</span><br><span class="line">            ++i;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">isdigit</span>(s[i]))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i &lt; s.length();++i)</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">isdigit</span>(s[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">' '</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!s.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        blank(i,s);</span><br><span class="line">        <span class="keyword">if</span>(i == s.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">'-'</span> || s[i] == <span class="string">'+'</span>)</span><br><span class="line">            ++i;</span><br><span class="line">        <span class="keyword">int</span> temp = i;</span><br><span class="line">        <span class="keyword">if</span>(!firstHalf(i,s))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(i == temp)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(i - <span class="number">1</span> == temp &amp;&amp; s[i - <span class="number">1</span>] == <span class="string">'.'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(i == s.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">'e'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span>(!secondHalf(i,s))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        blank(i,s);</span><br><span class="line">        <span class="keyword">return</span> i == s.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>64. Minimum Path Sum</title>
    <url>/2020/04/07/LeetCode_Cpp/0064._Minimum_Path_Sum/</url>
    <content><![CDATA[<h1 id="64-Minimum-Path-Sum"><a href="#64-Minimum-Path-Sum" class="headerlink" title="64. Minimum Path Sum"></a>64. Minimum Path Sum</h1><p> 难度: Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-path-sum/</a></p>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</span><br><span class="line"></span><br><span class="line">说明：每次只能向下或者向右移动一步。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp:</span><br><span class="line">1. 首行首列的路径只有一种，累加</span><br><span class="line">2. 其他都有两种方法，走到i，j的最小路径等于min(sum[i][j-1], sum[i-1][j])+grid[i][j]</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.size(), n = grid[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">int</span> dp[m][n];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) dp[i][<span class="number">0</span>] = grid[i][<span class="number">0</span>] + dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) dp[<span class="number">0</span>][i] = grid[<span class="number">0</span>][i] + dp[<span class="number">0</span>][i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            dp[i][j] = grid[i][j] + min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>68. Text Justification</title>
    <url>/2020/04/07/LeetCode_Cpp/0068._Text_Justification/</url>
    <content><![CDATA[<h1 id="68-Text-Justification"><a href="#68-Text-Justification" class="headerlink" title="68. Text Justification"></a>68. Text Justification</h1><p><strong><font color=red>难度:Hard<font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/text-justification/" target="_blank" rel="noopener">https://leetcode.com/problems/text-justification/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given an array of words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.</span><br><span class="line"></span><br><span class="line">You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces &#39; &#39; when necessary so that each line has exactly maxWidth characters.</span><br><span class="line"></span><br><span class="line">Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.</span><br><span class="line"></span><br><span class="line">For the last line of text, it should be left justified and no extra space is inserted between words.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">A word is defined as a character sequence consisting of non-space characters only.</span><br><span class="line">Each word&#39;s length is guaranteed to be greater than 0 and not exceed maxWidth.</span><br><span class="line">The input array words contains at least one word.</span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">words &#x3D; [&quot;This&quot;, &quot;is&quot;, &quot;an&quot;, &quot;example&quot;, &quot;of&quot;, &quot;text&quot;, &quot;justification.&quot;]</span><br><span class="line">maxWidth &#x3D; 16</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">   &quot;This    is    an&quot;,</span><br><span class="line">   &quot;example  of text&quot;,</span><br><span class="line">   &quot;justification.  &quot;</span><br><span class="line">]</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">words &#x3D; [&quot;What&quot;,&quot;must&quot;,&quot;be&quot;,&quot;acknowledgment&quot;,&quot;shall&quot;,&quot;be&quot;]</span><br><span class="line">maxWidth &#x3D; 16</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  &quot;What   must   be&quot;,</span><br><span class="line">  &quot;acknowledgment  &quot;,</span><br><span class="line">  &quot;shall be        &quot;</span><br><span class="line">]</span><br><span class="line">Explanation: Note that the last line is &quot;shall be    &quot; instead of &quot;shall     be&quot;,</span><br><span class="line">             because the last line must be left-justified instead of fully-justified.</span><br><span class="line">             Note that the second line is also left-justified becase it contains only one word.</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">words &#x3D; [&quot;Science&quot;,&quot;is&quot;,&quot;what&quot;,&quot;we&quot;,&quot;understand&quot;,&quot;well&quot;,&quot;enough&quot;,&quot;to&quot;,&quot;explain&quot;,</span><br><span class="line">         &quot;to&quot;,&quot;a&quot;,&quot;computer.&quot;,&quot;Art&quot;,&quot;is&quot;,&quot;everything&quot;,&quot;else&quot;,&quot;we&quot;,&quot;do&quot;]</span><br><span class="line">maxWidth &#x3D; 20</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  &quot;Science  is  what we&quot;,</span><br><span class="line">  &quot;understand      well&quot;,</span><br><span class="line">  &quot;enough to explain to&quot;,</span><br><span class="line">  &quot;a  computer.  Art is&quot;,</span><br><span class="line">  &quot;everything  else  we&quot;,</span><br><span class="line">  &quot;do                  &quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(n)<strong>**</strong>- 空间复杂度: O(n)<strong>**</strong></p>
</blockquote>
<p>题目不难，根据题目的意思先计算出一行最多能容纳多少单词，每个单词之间以一个空格分割就可以计算出每行最多能容纳多少单词。接下来计算每行的正确格式。计算出总共的空格数除以间隔数。总空格数除以间隔数，若余数为0，则商为单词之间的空格数，若余数 r 不为0，则从头开始 r 个空格数加1，剩下的不变。最后一行要注意每个单词之间的空格数为1，字符数不满maxWidth，剩下的用空格补充。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">fullJustify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="keyword">int</span> maxWidth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = <span class="number">0</span>,sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; words.size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += words[i].length();</span><br><span class="line">            <span class="keyword">if</span>(sum &lt;= maxWidth)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += <span class="number">1</span>;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> temp;</span><br><span class="line">                sum -= (r - l + words[i].length());</span><br><span class="line">                <span class="keyword">int</span> residue = <span class="number">0</span>, divide = (maxWidth - words[l].length());</span><br><span class="line">                <span class="keyword">if</span>(l + <span class="number">1</span> != r)</span><br><span class="line">                &#123;</span><br><span class="line">                    residue = (maxWidth - sum) % (r - l - <span class="number">1</span>);</span><br><span class="line">                    divide = (maxWidth - sum - residue) / (r - l - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                temp.append(words[l].begin(),words[l].end());</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = l + <span class="number">1</span>;j &lt; r - <span class="number">1</span>;++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> k = residue &gt; <span class="number">0</span> ? divide + <span class="number">1</span> : divide;</span><br><span class="line">                    <span class="keyword">while</span>(k)</span><br><span class="line">                    &#123;</span><br><span class="line">                        temp.push_back(<span class="string">' '</span>);</span><br><span class="line">                        --k;</span><br><span class="line">                    &#125;</span><br><span class="line">                    temp.append(words[j].begin(),words[j].end());</span><br><span class="line">                    residue--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> k = residue &gt; <span class="number">0</span> ? divide +<span class="number">1</span> : divide;</span><br><span class="line">                <span class="keyword">while</span>(k)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.push_back(<span class="string">' '</span>);</span><br><span class="line">                    --k;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(l + <span class="number">1</span> != r)</span><br><span class="line">                    temp.append(words[r - <span class="number">1</span>].begin(),words[r - <span class="number">1</span>].end());</span><br><span class="line">                ans.push_back(temp);</span><br><span class="line">                l = r++;</span><br><span class="line">                sum = words[i].length() + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sum -= <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">string</span> temp;</span><br><span class="line">        temp.append(words[l].begin(),words[l].end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l + <span class="number">1</span>;i &lt; r;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            temp.push_back(<span class="string">' '</span>);</span><br><span class="line">            temp.append(words[i].begin(),words[i].end());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k = maxWidth - sum;</span><br><span class="line">        <span class="keyword">while</span>(k)</span><br><span class="line">        &#123;</span><br><span class="line">            temp.push_back(<span class="string">' '</span>);</span><br><span class="line">            --k;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.push_back(temp);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>69. Sqrt(x)</title>
    <url>/2020/04/07/LeetCode_Cpp/0069._Sqr(x)/</url>
    <content><![CDATA[<h1 id="69-Sqrt-x"><a href="#69-Sqrt-x" class="headerlink" title="69. Sqrt(x)"></a>69. Sqrt(x)</h1><p><strong><font color=red>难度:Easy<font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/sqrtx/" target="_blank" rel="noopener">https://leetcode.com/problems/sqrtx/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Implement int sqrt(int x).</span><br><span class="line"></span><br><span class="line">Compute and return the square root of x, where x is guaranteed to be a non-negative integer.</span><br><span class="line"></span><br><span class="line">Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 4</span><br><span class="line">Output: 2</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: 8</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The square root of 8 is 2.82842..., and since </span><br><span class="line">             the decimal part is truncated, 2 is returned.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路1<br><strong>**</strong>- 时间复杂度: O(n)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>遍历从0到x的所有数，计算这些数的平方，直到大于x。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!x || x == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">for</span>(;i &lt; x;++i)</span><br><span class="line">             <span class="keyword">if</span>((<span class="keyword">long</span> <span class="keyword">long</span>)i * i &gt; x)</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">return</span> i - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路2<br><strong>**</strong>- 时间复杂度: O(lgn)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>很明显，上述方法我可以进一步优化，用二分法解决，以0为下界，x为上界，就可以进行二分搜索</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r= x;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> mid = (l + r) / <span class="number">2</span>,temp = mid * mid;</span><br><span class="line">            <span class="keyword">if</span>(temp == x)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(temp &lt; x)</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l * l &lt;= x ? l : l - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>72. Edit Distance</title>
    <url>/2020/04/07/LeetCode_Cpp/0072._Edit_Distance/</url>
    <content><![CDATA[<h1 id="72-Edit-Distance"><a href="#72-Edit-Distance" class="headerlink" title="72. Edit Distance"></a>72. Edit Distance</h1><p>难度:Hard</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/edit-distance/" target="_blank" rel="noopener">https://leetcode.com/problems/edit-distance/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">  s &#x3D; &quot;barfoothefoobarman&quot;,</span><br><span class="line">  words &#x3D; [&quot;foo&quot;,&quot;bar&quot;]</span><br><span class="line">Output: [0,9]</span><br><span class="line">Explanation: Substrings starting at index 0 and 9 are &quot;barfoor&quot; and &quot;foobar&quot; respectively.</span><br><span class="line">The output order does not matter, returning [9,0] is fine too.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">  s &#x3D; &quot;wordgoodstudentgoodword&quot;,</span><br><span class="line">  words &#x3D; [&quot;word&quot;,&quot;student&quot;]</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(n^2)<strong>**</strong>- 空间复杂度: O(n^2)<strong>**</strong></p>
</blockquote>
<p>这题可以动态规划的思想去解决，首先定义两个指针 i 和 j，分别指向字符串的末尾。从两个字符串的末尾开始比较，相等，则<code>--i,--j</code>。若不相等，有三种情况，删除 i 指向的字符，在 i 指向的字符之后增加一个字符，替换 i 指向的字符， 接着比较这三次的操作的次数，取最小值即可，不过这里要注意递归操作时会重复计算，所以我们用一个数组 dp[i][j]，表示 i 在words1中的位置，j 在 words2 的位置。由于c++对动态数组的支持不是很好，这里我用 vector 代替，在效率上可能较欠缺。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minLen</span><span class="params">(<span class="built_in">string</span>&amp; w1,<span class="built_in">string</span>&amp; w2,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">	   <span class="keyword">if</span>(i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> j + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp[i][j])</span><br><span class="line">            <span class="keyword">return</span> dp[i][j];</span><br><span class="line">        <span class="keyword">if</span>(w1[i] == w2[j])</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j] = minLen(w1,w2,i - <span class="number">1</span>,j - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> dp[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp1 = min(minLen(w1,w2,i - <span class="number">1</span>,j) + <span class="number">1</span>,minLen(w1,w2,i - <span class="number">1</span>,j - <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">        dp[i][j] = min(minLen(w1,w2,i,j - <span class="number">1</span>) + <span class="number">1</span>,temp1);</span><br><span class="line">        <span class="keyword">return</span> dp[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = word1.length() - <span class="number">1</span>,j = word2.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t1 = <span class="number">0</span>;t1 &lt;= i;++t1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t2 = <span class="number">0</span>;t2 &lt;= j;++t2)</span><br><span class="line">                v1.push_back(<span class="number">0</span>);</span><br><span class="line">            dp.push_back(v1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = minLen(word1,word2,i,j);</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>75. Sort Colors</title>
    <url>/2020/04/07/LeetCode_Cpp/0075._Sort_Colors/</url>
    <content><![CDATA[<h1 id="75-Sort-Colors"><a href="#75-Sort-Colors" class="headerlink" title="75. Sort Colors"></a>75. Sort Colors</h1><p> 难度: Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/sort-colors/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-colors/submissions/</a></p>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</span><br><span class="line"></span><br><span class="line">此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">不能使用代码库中的排序函数来解决这道题。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [2,0,2,1,1,0]</span><br><span class="line">输出: [0,0,1,1,2,2]</span><br><span class="line">进阶：</span><br><span class="line"></span><br><span class="line">一个直观的解决方案是使用计数排序的两趟扫描算法。</span><br><span class="line">首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。</span><br><span class="line">你能想出一个仅使用常数空间的一趟扫描算法吗？</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">记录两个指针，一个是0部分的后一位，另一个是2开头的前一个位置。</span><br><span class="line">遍历数组，遇到2，就和后一个指针交换（交换回来的有可能还是2，所以这个位置要再次判断）</span><br><span class="line">遇到0则和最后一个数的下一个位置交换。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=right;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[left];</span><br><span class="line">            nums[left] = nums[i];</span><br><span class="line">            nums[i] = tmp;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">            nums[i] = nums[right];</span><br><span class="line">            nums[right] = tmp;</span><br><span class="line">            right--;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>77. Combinations</title>
    <url>/2020/04/07/LeetCode_Cpp/0077._combinations/</url>
    <content><![CDATA[<h1 id="77-Combinations"><a href="#77-Combinations" class="headerlink" title="77. Combinations"></a>77. Combinations</h1><p>难度: Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/combinations/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combinations/</a></p>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: n &#x3D; 4, k &#x3D; 2</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">回溯寻找所有组合。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> index, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;</span><br><span class="line">        ans.push_back(path);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;=n;i++)&#123;</span><br><span class="line">        path.push_back(i);</span><br><span class="line">        dfs(k<span class="number">-1</span>, i+<span class="number">1</span>, n, path, ans);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combine</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    dfs(k, <span class="number">1</span>, n, path, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>76. Minimum Window Substring</title>
    <url>/2020/04/07/LeetCode_Cpp/0076._Minimum_Window_Substring/</url>
    <content><![CDATA[<h1 id="76-Minimum-Window-Substring"><a href="#76-Minimum-Window-Substring" class="headerlink" title="76. Minimum Window Substring"></a>76. Minimum Window Substring</h1><p><strong><font color=red>难度:Hard<font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/minimum-window-substring/" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-window-substring/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: S &#x3D; &quot;ADOBECODEBANC&quot;, T &#x3D; &quot;ABC&quot;</span><br><span class="line">Output: &quot;BANC&quot;</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">If there is no such window in S that covers all characters in T, return the empty string &quot;&quot;.</span><br><span class="line">If there is such window, you are guaranteed that there will always be only one unique minimum window in S.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(N)<strong>**</strong>- 空间复杂度: O(N)<strong>**</strong></p>
</blockquote>
<p>刚开始想到用 map 去做，但是这道题的键值是字符，因此可以用数组去做，这样时间复杂度为O(n)。想用一个数组每个字符出现的次数。接着遍历 s。固定一个区间，使在这个区间内的子字符串包含字符串 t，同样也可以用一个数组储存这个区间。接着向右移动区间即可。找到最短的区间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[<span class="number">128</span>],alNum = t.length();</span><br><span class="line">        <span class="built_in">memset</span>(arr,<span class="number">0</span>,<span class="keyword">sizeof</span>(arr));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; t.length();++i)</span><br><span class="line">            arr[t[i]]++;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();++i)</span><br><span class="line">            <span class="keyword">if</span>(arr[s[i]])</span><br><span class="line">                v.push_back(i);</span><br><span class="line">        <span class="keyword">int</span> s_map[<span class="number">128</span>],beg = <span class="number">-1</span>,en,ans = INT_MAX,count1 = <span class="number">0</span>,l,r;</span><br><span class="line">        <span class="built_in">memset</span>(s_map,<span class="number">0</span>,<span class="keyword">sizeof</span>(s_map));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; v.size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(count1 != alNum)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(beg == <span class="number">-1</span>)</span><br><span class="line">                    beg = i;</span><br><span class="line">                s_map[s[v[i]]]++;</span><br><span class="line">                <span class="keyword">if</span>(s_map[s[v[i]]] &lt;= arr[s[v[i]]])</span><br><span class="line">                    count1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = beg;count1 == alNum;)</span><br><span class="line">            &#123;</span><br><span class="line">                en = v[i];</span><br><span class="line">                s_map[s[v[j]]]--;</span><br><span class="line">                <span class="keyword">if</span>(ans &gt; en - v[beg])</span><br><span class="line">                &#123;</span><br><span class="line">                    l = v[beg];</span><br><span class="line">                    r = en;</span><br><span class="line">                    ans = en - v[beg];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(s_map[s[v[j]]] &lt; arr[s[v[j]]])</span><br><span class="line">                    count1--;</span><br><span class="line">                beg = ++j;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans == INT_MAX)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">return</span> s.substr(l,r - l + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>78. Subsets</title>
    <url>/2020/04/07/LeetCode_Cpp/0078._subsets/</url>
    <content><![CDATA[<h1 id="78-Subsets"><a href="#78-Subsets" class="headerlink" title="78. Subsets"></a>78. Subsets</h1><p> 难度: Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subsets/</a></p>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</span><br><span class="line"></span><br><span class="line">说明：解集不能包含重复的子集。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: nums &#x3D; [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">每个元素有两种选择，选与不选，可以使用K位二进制数组表示K个元素的选与不选。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">pow</span>(<span class="number">2</span>, nums.size());i++)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=i;</span><br><span class="line">        <span class="keyword">while</span>(j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">                tmp.push_back(nums[index]);</span><br><span class="line">            index++;</span><br><span class="line">            j/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>81. Search in Rotated Sorted Array II</title>
    <url>/2020/04/07/LeetCode_Cpp/0081._Search_in_Rotated_Sorted_Array_II/</url>
    <content><![CDATA[<h1 id="81-Search-in-Rotated-Sorted-Array-II"><a href="#81-Search-in-Rotated-Sorted-Array-II" class="headerlink" title="81. Search in Rotated Sorted Array II"></a>81. Search in Rotated Sorted Array II</h1><p><strong><font color=red>难度:Medium<font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii/submissions/" target="_blank" rel="noopener">https://leetcode.com/problems/search-in-rotated-sorted-array-ii/submissions/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</span><br><span class="line"></span><br><span class="line">(i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]).</span><br><span class="line"></span><br><span class="line">You are given a target value to search. If found in the array return true, otherwise return false.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 0</span><br><span class="line">Output: true</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 3</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(lgN)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>翻转数组一开始想到的就是用二分法，实现起来也不难，关键是判断 l = mid 还是 j = mid，不过这题还要单独考虑一下当nums[mid] == nums[l] 的情况，当nums[l] == nums[mid]时，分别查找[l,mid]和[mid,r]区间内是否存在target</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchInternal</span><span class="params">( <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; Nums, <span class="keyword">const</span> <span class="keyword">int</span> Target, <span class="keyword">int</span> Left, <span class="keyword">int</span> Right )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( Right &lt;= Left )</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> ( Left &lt; Right - <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> Middle = (Left + Right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ( Nums[Left] == Nums[Middle] )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> searchInternal( Nums, Target, Left, Middle )</span><br><span class="line">                    || searchInternal( Nums, Target, Middle, Right );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( Target &lt; Nums[Middle] )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ( Nums[Left] &lt; Nums[Middle] &amp;&amp; Nums[Left] &gt; Target )</span><br><span class="line">                &#123;</span><br><span class="line">                    Left = Middle;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Right = Middle;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( Target &gt; Nums[Middle] )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ( Nums[Left] &gt; Nums[Middle] &amp;&amp; Nums[Left] &lt;= Target )</span><br><span class="line">                &#123;</span><br><span class="line">                    Right = Middle;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Left = Middle;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Nums[Left] == Target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> searchInternal(nums,target,<span class="number">0</span>,nums.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>85. Maximal Rectangle</title>
    <url>/2020/04/07/LeetCode_Cpp/0085._Maximal_Rectangle/</url>
    <content><![CDATA[<h1 id="85-Maximal-Rectangle"><a href="#85-Maximal-Rectangle" class="headerlink" title="85. Maximal Rectangle"></a>85. Maximal Rectangle</h1><p>难度:Hard</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/maximal-rectangle/" target="_blank" rel="noopener">https://leetcode.com/problems/maximal-rectangle/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a 2D binary matrix filled with 0&#39;s and 1&#39;s, find the largest rectangle containing only 1&#39;s and return its area.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><blockquote>
<p>思路1<br><strong>**</strong>- 时间复杂度: O(n^3)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>第一种暴力的方法去解，先求出每一个数向右有多少个“1”，记录下长度count1，在这个数的位置向下寻找，若下面的长度小于count1，则count1取较小的值。若为0就计算矩阵的大小，直到遍历所有的数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = matrix.size();</span><br><span class="line">        <span class="keyword">if</span>(!len1)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len2 = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">0</span>;t &lt; len1;++t)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len2;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> count1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i + count1 &lt; len2 &amp;&amp; matrix[t][i + count1] - <span class="string">'0'</span>)</span><br><span class="line">                ++count1;</span><br><span class="line">            <span class="keyword">if</span>(count1)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> row = <span class="number">1</span>;</span><br><span class="line">                ans = max(ans,row * count1);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = t + <span class="number">1</span>;j &lt; len1;++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> count2 = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span>(count2  &lt;= count1 &amp;&amp; matrix[j][i + count2] - <span class="string">'0'</span>)</span><br><span class="line">                        ++count2;</span><br><span class="line">                    <span class="keyword">if</span>(!count2)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span>(count1 &gt; count2)</span><br><span class="line">                        count1 = count2;</span><br><span class="line">                    ++row;</span><br><span class="line">                    ans = max(ans,row * count1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路2<br><strong>**</strong>- 时间复杂度: O(n^2)<strong>**</strong>- 空间复杂度: O(n)<strong>**</strong></p>
</blockquote>
<p>对上述算法进行优化，计算每个数的高度和这个高度向左的位置和向右的位置，这样只要在O(n^2)的时间复杂内就能完成</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">int</span> len1 = matrix.size();</span><br><span class="line">        <span class="keyword">if</span>(!len1)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len2 = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> height[len2],l[len2],r[len2];</span><br><span class="line">        <span class="built_in">memset</span>(height,<span class="number">0</span>,<span class="keyword">sizeof</span>(height));</span><br><span class="line">        <span class="built_in">memset</span>(l,<span class="number">0</span>,<span class="keyword">sizeof</span>(l));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len2;++i)</span><br><span class="line">            r[i]  = len2;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len1;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t_l = <span class="number">0</span>,t_r = len2;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; len2;++j)</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]-<span class="string">'0'</span>)</span><br><span class="line">                    height[j] = height[j] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    height[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; len2;++j)</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]-<span class="string">'0'</span>)</span><br><span class="line">                    l[j] = max(l[j],t_l);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    t_l = j + <span class="number">1</span>;</span><br><span class="line">                    l[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = len2 - <span class="number">1</span>;j &gt;= <span class="number">0</span>;--j)</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]-<span class="string">'0'</span>)</span><br><span class="line">                    r[j] = min(r[j],t_r);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    t_r = j;</span><br><span class="line">                    r[j] = len2;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; len2;++j)</span><br><span class="line">                ans = max(ans,(r[j] - l[j]) * height[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>84. Largest Rectangle in Histogram</title>
    <url>/2020/04/07/LeetCode_Cpp/0084._Largest_Rectangle_in_Histogram/</url>
    <content><![CDATA[<h1 id="84-Largest-Rectangle-in-Histogram"><a href="#84-Largest-Rectangle-in-Histogram" class="headerlink" title="84. Largest Rectangle in Histogram"></a>84. Largest Rectangle in Histogram</h1><p>难度：Hard</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">https://leetcode.com/problems/largest-rectangle-in-histogram/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given n non-negative integers representing the histogram&#39;s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</span><br><span class="line"></span><br><span class="line">Above is a histogram where width of each bar is 1, given height &#x3D; [2,1,5,6,2,3].</span><br><span class="line"></span><br><span class="line">The largest rectangle is shown in the shaded area, which has area &#x3D; 10 unit.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: [2,1,5,6,2,3]</span><br><span class="line">Output: 10</span><br></pre></td></tr></table></figure>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><blockquote>
<p>思路1<br><strong>**</strong>- 时间复杂度: O(n^2)<strong>**</strong>- 空间复杂度: O(n)<strong>**</strong></p>
</blockquote>
<p>这题第一种思路就是用暴力的方法去解。时间复杂度为O(n^2)。遍历数组，对数组中每个元素分别向右向左找到最远，计算最大值得到结果</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; heights.size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> l,r;</span><br><span class="line">            <span class="keyword">for</span>(;j &lt; heights.size();++j)</span><br><span class="line">                <span class="keyword">if</span>(heights[j] &lt; heights[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    r = (<span class="keyword">long</span> <span class="keyword">long</span>)heights[i] * (j - i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == heights.size())</span><br><span class="line">                r = (<span class="keyword">long</span> <span class="keyword">long</span>)heights[i] * (heights.size() - i);</span><br><span class="line">            <span class="keyword">for</span>(j = i - <span class="number">1</span>;j &gt;= <span class="number">0</span>;--j)</span><br><span class="line">                <span class="keyword">if</span>(heights[j] &lt; heights[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    l = (<span class="keyword">long</span> <span class="keyword">long</span>)heights[i] * (i - j - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; <span class="number">0</span>)</span><br><span class="line">                l = (<span class="keyword">long</span> <span class="keyword">long</span>)heights[i] * i;</span><br><span class="line">            ans = max(ans,l + r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路2<br><strong>**</strong>- 时间复杂度: O(n)<strong>**</strong>- 空间复杂度: O(n)<strong>**</strong></p>
</blockquote>
<p>上面第一种方法的实现中有重复计算的过程，我们用栈去解决这个问题就很好的剔除了重复计算的过程，时间复杂度降到了O(n)。先定义一个栈，我们要保证栈中的数是递增的，遍历数组，若这个数小于栈顶的数，则将栈顶的数弹出，并计算栈顶元素的最大距离，直到栈为空或者比这个数小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        heights.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; &gt; v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; heights.size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!v.size() || heights[i] &gt; v[v.size() - <span class="number">1</span>].first)</span><br><span class="line">                    v.push_back(make_pair(heights[i],i));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> j = v.size() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; v[j].first &gt; heights[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    ans = max(ans,v[j].first * (i - v[j - <span class="number">1</span>].second - <span class="number">1</span>));</span><br><span class="line">                    v.pop_back();</span><br><span class="line">                    --j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!j &amp;&amp; v[j].first &gt; heights[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    ans = max(ans,v[j].first * (i));</span><br><span class="line">                    v.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">                v.push_back(make_pair(heights[i],i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>83. remove-duplicates-from-sorted-list</title>
    <url>/2020/04/07/LeetCode_Cpp/0083._remove_duplicates_from_sorted_lists/</url>
    <content><![CDATA[<h1 id="83-remove-duplicates-from-sorted-list"><a href="#83-remove-duplicates-from-sorted-list" class="headerlink" title="83. remove-duplicates-from-sorted-list"></a>83. remove-duplicates-from-sorted-list</h1><p><strong><font color=red>难度:Easy</font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<p>*<a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">https://leetcode.com/problems/remove-duplicates-from-sorted-list/</a></p>
<ul>
<li><blockquote>
<p>内容描述</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a sorted linked list, delete all duplicates such that each element appear only once.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 1-&gt;1-&gt;2</span><br><span class="line">Output: 1-&gt;2</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: 1-&gt;1-&gt;2-&gt;3-&gt;3</span><br><span class="line">Output: 1-&gt;2-&gt;3</span><br></pre></td></tr></table></figure>

<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(N)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>题目中给出的链表是已经排序好的，那么我们只需要遍历链表，当后一个节点的数等于当前节点的，就删去</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* l = head;</span><br><span class="line">        ListNode* l1 = head;</span><br><span class="line">        <span class="keyword">if</span>(l != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">while</span>(l -&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(l -&gt;val == (l -&gt;next -&gt;val))</span><br><span class="line">                    l -&gt;next = l -&gt;next -&gt;next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    l = l -&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">           <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>87. Scramble String</title>
    <url>/2020/04/07/LeetCode_Cpp/0087._Scramble_String/</url>
    <content><![CDATA[<h1 id="87-Scramble-String"><a href="#87-Scramble-String" class="headerlink" title="87. Scramble String"></a>87. Scramble String</h1><p><strong><font color=red>难度:Hard<font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/scramble-string/" target="_blank" rel="noopener">https://leetcode.com/problems/scramble-string/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.</span><br><span class="line"></span><br><span class="line">Below is one possible representation of s1 &#x3D; &quot;great&quot;:</span><br><span class="line"></span><br><span class="line">    great</span><br><span class="line">   &#x2F;    \</span><br><span class="line">  gr    eat</span><br><span class="line"> &#x2F; \    &#x2F;  \</span><br><span class="line">g   r  e   at</span><br><span class="line">           &#x2F; \</span><br><span class="line">          a   t</span><br><span class="line">To scramble the string, we may choose any non-leaf node and swap its two children.</span><br><span class="line"></span><br><span class="line">For example, if we choose the node &quot;gr&quot; and swap its two children, it produces a scrambled string &quot;rgeat&quot;.</span><br><span class="line"></span><br><span class="line">    rgeat</span><br><span class="line">   &#x2F;    \</span><br><span class="line">  rg    eat</span><br><span class="line"> &#x2F; \    &#x2F;  \</span><br><span class="line">r   g  e   at</span><br><span class="line">           &#x2F; \</span><br><span class="line">          a   t</span><br><span class="line">We say that &quot;rgeat&quot; is a scrambled string of &quot;great&quot;.</span><br><span class="line"></span><br><span class="line">Similarly, if we continue to swap the children of nodes &quot;eat&quot; and &quot;at&quot;, it produces a scrambled string &quot;rgtae&quot;.</span><br><span class="line"></span><br><span class="line">    rgtae</span><br><span class="line">   &#x2F;    \</span><br><span class="line">  rg    tae</span><br><span class="line"> &#x2F; \    &#x2F;  \</span><br><span class="line">r   g  ta  e</span><br><span class="line">       &#x2F; \</span><br><span class="line">      t   a</span><br><span class="line">We say that &quot;rgtae&quot; is a scrambled string of &quot;great&quot;.</span><br><span class="line"></span><br><span class="line">Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: s1 &#x3D; &quot;great&quot;, s2 &#x3D; &quot;rgeat&quot;</span><br><span class="line">Output: true</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: s1 &#x3D; &quot;abcde&quot;, s2 &#x3D; &quot;caebd&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路1<br><strong>**</strong>- 时间复杂度: O(2^n)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>刚开始的时候题目的意思没理解清楚，以为是把字符串对半，其实字符串有很多的二叉树表示方法。第一种方法就是递归的方法。每次递归时比较i到len的之间的子串是否和s2中的子串的相同，这里有两种比较方式，s2开始和结尾两种比较方式，有一种满足即可，这里我们只要判断两个子串的字母是否相同。相同就进行下一次递归。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isScramble</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1==s2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s1.length();</span><br><span class="line">        <span class="keyword">int</span> count[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            count[s1[i]-<span class="string">'a'</span>]++;</span><br><span class="line">            count[s2[i]-<span class="string">'a'</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(count[i]!=<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=len<span class="number">-1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(isScramble(s1.substr(<span class="number">0</span>,i), s2.substr(<span class="number">0</span>,i)) &amp;&amp; isScramble(s1.substr(i), s2.substr(i)))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(isScramble(s1.substr(<span class="number">0</span>,i), s2.substr(len-i)) &amp;&amp; isScramble(s1.substr(i), s2.substr(<span class="number">0</span>,len-i)))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路2<br><strong>**</strong>- 时间复杂度: O(n^4)<strong>**</strong>- 空间复杂度: O(n^3</p>
</blockquote>
<p>第二种的方法使用DP，定义数组dp[i][j][t],表示s1[i]和s2[j]开始的长度为t的字符是否为scramble string。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isScramble</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s1.length();</span><br><span class="line">    <span class="keyword">int</span> dp[len][len][len + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>;i &gt;= <span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = len - <span class="number">1</span>;j &gt;= <span class="number">0</span>;--j)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">1</span>;t &lt;= min(len - i,len - j);++t)</span><br><span class="line">                <span class="keyword">if</span>(t == <span class="number">1</span>)</span><br><span class="line">                    dp[i][j][t] = (s1[i] == s2[j]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(;k &lt; t;++k)</span><br><span class="line">                        <span class="keyword">if</span>((dp[i][j][k] &amp;&amp; dp[i + k][j + k][t - k]) || (dp[i][j + t - k][k] &amp;&amp; dp[i + k][j][t - k]))</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    dp[i][j][t] = k == t ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>][len];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>88.Merge Sorted Array</title>
    <url>/2020/04/07/LeetCode_Cpp/0088._Merge_Sorted_Array/</url>
    <content><![CDATA[<h1 id="88-Merge-Sorted-Array"><a href="#88-Merge-Sorted-Array" class="headerlink" title="88.Merge Sorted Array"></a>88.Merge Sorted Array</h1><p><strong><font color=red>难度Easy</font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/merge-sorted-array/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-sorted-array/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">The number of elements initialized in nums1 and nums2 are m and n respectively.</span><br><span class="line">You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.</span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3</span><br><span class="line">nums2 &#x3D; [2,5,6],       n &#x3D; 3</span><br><span class="line"></span><br><span class="line">Output: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(n)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>由于数组是已经排序好的，我们可以用两个指针 i，j 指向两个数组的第一个元素，当nums[i] &lt; nums[j],++i。否则就 ++j,并把j所指向的元素插入nums1。不过要注意这两个数组的长度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((i &lt; m) &amp;&amp; (j &lt; n))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &lt; nums2[j])</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                nums1.insert(nums1.begin() + i,nums2[j++]);</span><br><span class="line">                i++;</span><br><span class="line">                m++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            nums1.erase(nums1.begin() + m,nums1.end());</span><br><span class="line">            nums1.insert(nums1.end(),nums2.begin() + j,nums2.begin() + n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nums1.erase(nums1.begin() + m,nums1.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>90. Subsets II</title>
    <url>/2020/04/07/LeetCode_Cpp/0090._Subsets_II/</url>
    <content><![CDATA[<h1 id="90-Subsets-II"><a href="#90-Subsets-II" class="headerlink" title="90. Subsets II"></a>90. Subsets II</h1><p> 难度: Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/subsets-ii/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subsets-ii/submissions/</a></p>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</span><br><span class="line"></span><br><span class="line">说明：解集不能包含重复的子集。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [1,2,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">回溯搜索</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> index, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; subset, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans)</span></span>&#123;</span><br><span class="line">    ans.push_back(subset);</span><br><span class="line">    <span class="keyword">if</span>(index == nums.size())&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;nums.size();i++)&#123; </span><br><span class="line">        <span class="keyword">if</span>(nums[i<span class="number">-1</span>]==nums[i]&amp;&amp;i&gt;index)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        subset.push_back(nums[i]);</span><br><span class="line">        dfs(nums, i+<span class="number">1</span>, subset, ans);</span><br><span class="line">        subset.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsetsWithDup</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; subset;</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    dfs(nums, <span class="number">0</span>, subset, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>96. Unique Binary Search Trees</title>
    <url>/2020/04/07/LeetCode_Cpp/0096._Unique_Binary_Search_Trees/</url>
    <content><![CDATA[<h1 id="96-Unique-Binary-Search-Trees"><a href="#96-Unique-Binary-Search-Trees" class="headerlink" title="96. Unique Binary Search Trees"></a>96. Unique Binary Search Trees</h1><p> 难度: Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-binary-search-trees/</a></p>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">给定 n &#x3D; 3, 一共有 5 种不同结构的二叉搜索树:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假设有n个节点，左右子树有（0，n-1）(1,n-2)...(n-1, 0)等情况</span><br><span class="line">子结构：</span><br><span class="line">dp[i] &#x3D; dp[0]*dp[i-1]+...+dp[i-1]*dp[0]</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            dp[i] += dp[i-j<span class="number">-1</span>]*dp[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>94. Binary Tree Inorder Traversal</title>
    <url>/2020/04/07/LeetCode_Cpp/0094._binary_tree_inorder_traversal/</url>
    <content><![CDATA[<h1 id="94-Binary-Tree-Inorder-Traversal"><a href="#94-Binary-Tree-Inorder-Traversal" class="headerlink" title="94. Binary Tree Inorder Traversal"></a>94. Binary Tree Inorder Traversal</h1><p> 难度: Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-inorder-traversal/</a></p>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个二叉树，返回它的中序 遍历。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">输出: [1,3,2]</span><br><span class="line"></span><br><span class="line">进阶: 递归算法很简单，你可以通过迭代算法完成吗？</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">递归。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    dfs(root-&gt;left, ans);</span><br><span class="line">    ans.push_back(root-&gt;val);</span><br><span class="line">    dfs(root-&gt;right, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    dfs(root, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>99. Recover Binary Search Tree</title>
    <url>/2020/04/07/LeetCode_Cpp/0099._Recover_Binary_Search_Tree/</url>
    <content><![CDATA[<h1 id="99-Recover-Binary-Search-Tree"><a href="#99-Recover-Binary-Search-Tree" class="headerlink" title="99. Recover Binary Search Tree"></a>99. Recover Binary Search Tree</h1><p><strong><font color=red>难度:Hard<font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/recover-binary-search-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/recover-binary-search-tree/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Two elements of a binary search tree (BST) are swapped by mistake.</span><br><span class="line"></span><br><span class="line">Recover the tree without changing its structure.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [1,3,null,null,2]</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">  &#x2F;</span><br><span class="line"> 3</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line"></span><br><span class="line">Output: [3,1,null,null,2]</span><br><span class="line"></span><br><span class="line">   3</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [3,1,4,null,null,2]</span><br><span class="line"></span><br><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   4</span><br><span class="line">   &#x2F;</span><br><span class="line">  2</span><br><span class="line"></span><br><span class="line">Output: [2,1,4,null,null,3]</span><br><span class="line"></span><br><span class="line">  2</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   4</span><br><span class="line">   &#x2F;</span><br><span class="line">  3</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(n)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>这道首先要搞懂平衡二叉树在中序遍历时递增的。清楚这个性质后我们只需要对二叉树进行中序遍历，找到哪个错误的数即可，比如第一个例子中序遍历之后为 321，交换3和1，第二个例子中序遍历之后为 1324，交换3和2。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">TreeNode* n1;</span><br><span class="line">TreeNode* n2;</span><br><span class="line">TreeNode* pre = <span class="keyword">new</span> TreeNode(INT_MIN);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travel</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    travel(root -&gt;left);</span><br><span class="line">    <span class="keyword">if</span>(!n1 &amp;&amp; root -&gt;val &lt;= pre -&gt;val)</span><br><span class="line">        n1 = pre;</span><br><span class="line">    <span class="keyword">if</span>(pre &amp;&amp; n1 &amp;&amp; root -&gt;val &lt;= pre -&gt;val)</span><br><span class="line">        n2 = root;</span><br><span class="line">    pre = root;</span><br><span class="line">    travel(root -&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    travel(root);</span><br><span class="line">    swap(n1 -&gt;val,n2 -&gt;val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>100. same tree</title>
    <url>/2020/04/07/LeetCode_Cpp/0100._same_tree/</url>
    <content><![CDATA[<h1 id="100-same-tree"><a href="#100-same-tree" class="headerlink" title="100. same tree"></a>100. same tree</h1><p>难度: Easy</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/same-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/same-tree/</a></li>
<li><blockquote>
<p>内容描述</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given two binary trees, write a function to check if they are the same or not.</span><br><span class="line"></span><br><span class="line">Two binary trees are considered the same if they are structurally identical and the nodes have the same value.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:  1         1</span><br><span class="line">          &#x2F; \       &#x2F; \</span><br><span class="line">         2   3     2   3</span><br><span class="line"></span><br><span class="line">        [1,2,3],   [1,2,3]</span><br><span class="line"></span><br><span class="line">Output: true</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input:  1         1</span><br><span class="line">          &#x2F;           \</span><br><span class="line">         2             2</span><br><span class="line"></span><br><span class="line">        [1,2],     [1,null,2]</span><br><span class="line"></span><br><span class="line">Output: false</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input:  1         1</span><br><span class="line">          &#x2F; \       &#x2F; \</span><br><span class="line">         2   1     1   2</span><br><span class="line"></span><br><span class="line">        [1,2,1],   [1,1,2]</span><br><span class="line"></span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><blockquote>
<p>思路1<br><strong>**</strong>- 时间复杂度: O(N)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>这道题直接从两颗树的根节点开始递归比较，如果不同就返回false，反之则true</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p != <span class="literal">nullptr</span> &amp;&amp; q != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p -&gt;val != q -&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> isSameTree(p -&gt;left,q -&gt;left) &amp;&amp; isSameTree(p -&gt;right,q -&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p == q ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>101. Symmetric Tree</title>
    <url>/2020/04/07/LeetCode_Cpp/0101._Symmetric_Tree/</url>
    <content><![CDATA[<h1 id="101-Symmetric-Tree"><a href="#101-Symmetric-Tree" class="headerlink" title="101. Symmetric Tree"></a>101. Symmetric Tree</h1><p><strong><font color=red>难度Easy<font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/symmetric-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/symmetric-tree/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</span><br><span class="line"></span><br><span class="line">For example, this binary tree [1,2,2,3,4,4,3] is symmetric:</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br><span class="line">But the following [1,2,2,null,3,null,3] is not:</span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line">   \   \</span><br><span class="line">   3    3</span><br></pre></td></tr></table></figure>

<p>可以直接DFS比较左右两颗子树是否相等，若想等返回true，若不等，返回false</p>
<blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(N)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(TreeNode* oTree,TreeNode* mTree)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((oTree != <span class="literal">nullptr</span>) &amp;&amp; (mTree != <span class="literal">nullptr</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((oTree -&gt;val == mTree  -&gt;val) &amp;&amp; (oTree -&gt;val == mTree -&gt;val))</span><br><span class="line">                <span class="keyword">return</span> judge(oTree -&gt;left,mTree -&gt;right) &amp;&amp; judge(oTree -&gt;right,mTree -&gt;left);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(oTree == mTree)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(root != <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> judge(root -&gt;left,root -&gt;right);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>97. Interleaving String</title>
    <url>/2020/04/07/LeetCode_Cpp/0097._Interleaving_String/</url>
    <content><![CDATA[<h1 id="97-Interleaving-String"><a href="#97-Interleaving-String" class="headerlink" title="97. Interleaving String"></a>97. Interleaving String</h1><p><strong><font color=red>难度:Hard<font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/interleaving-string/" target="_blank" rel="noopener">https://leetcode.com/problems/interleaving-string/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: s1 &#x3D; &quot;aabcc&quot;, s2 &#x3D; &quot;dbbca&quot;, s3 &#x3D; &quot;aadbbcbcac&quot;</span><br><span class="line">Output: true</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: s1 &#x3D; &quot;aabcc&quot;, s2 &#x3D; &quot;dbbca&quot;, s3 &#x3D; &quot;aadbbbaccc&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(N^2)<strong>**</strong>- 空间复杂度: O(N^2)<strong>**</strong></p>
</blockquote>
<p>一般用暴力的方法去解这题，时间复杂度为O(2^n)，时间复杂度为指数级，肯定超时。因此我们可以用动态规划将时间复杂度优化到O(n^2)。解动态规划的关键就是找到状态转移方程，定义二维数组 dp[i][j]，表示 s1[i]和 s2[j]之后的子串是否能组成s3[i + j]。这样我们就能写出状态转移方程，<code>dp[i][j] = (s1[i] == s3[i + j] &amp;&amp; dp[i + 1][j]) || (s2[j] == s3[i + j] &amp;&amp; dp[i][j + 1])</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2, <span class="built_in">string</span> s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l1 = s1.length(),l2 = s2.length(),l3 = s3.length();</span><br><span class="line">        <span class="keyword">if</span>(l1 + l2 != s3.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[l1 + <span class="number">2</span>][l2 + <span class="number">2</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[l1][l2] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l1;i &gt;= <span class="number">0</span>;--i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = l2;j &gt;= <span class="number">0</span>;--j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; l1 &amp;&amp; s1[i] == s3[i + j] &amp;&amp; dp[i + <span class="number">1</span>][j])</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(j &lt; l2 &amp;&amp; s2[j] == s3[i + j] &amp;&amp; dp[i][j + <span class="number">1</span>])</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>104. Maximum Depth of Binary Tree</title>
    <url>/2020/04/07/LeetCode_Cpp/0104._Maximum_Depth_of_Binary_Tree/</url>
    <content><![CDATA[<h1 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. Maximum Depth of Binary Tree"></a>104. Maximum Depth of Binary Tree</h1><p><strong><font color=red>难度:Easy<font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-depth-of-binary-tree/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a binary tree, find its maximum depth.</span><br><span class="line"></span><br><span class="line">The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</span><br><span class="line"></span><br><span class="line">Note: A leaf is a node with no children.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Given binary tree [3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">return its depth &#x3D; 3.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(N)<strong>**</strong>- 空间复杂度: O(N)<strong>**</strong></p>
</blockquote>
<p>用DFS递归遍历二叉树，分别找到二叉树的左子树与右子树的 depth。比较左子树和右子树的 depth的大小。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> max(root,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(TreeNode* ptr,<span class="keyword">int</span> deep)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ptr != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ldeep = max(ptr -&gt;left,deep + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> rdeep = max(ptr -&gt;right,deep + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(ldeep &gt; rdeep) </span><br><span class="line">                deep = ldeep; </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                deep = rdeep;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>102. Binary Tree Level Order Traversal</title>
    <url>/2020/04/07/LeetCode_Cpp/0102._Binary_Tree_Level_Order_Traversal/</url>
    <content><![CDATA[<h1 id="102-Binary-Tree-Level-Order-Traversal"><a href="#102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="102. Binary Tree Level Order Traversal"></a>102. Binary Tree Level Order Traversal</h1><p> 难度: Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</a></p>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</span><br><span class="line"></span><br><span class="line">例如:</span><br><span class="line">给定二叉树: [3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">返回其层次遍历结果：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">层次遍历</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; level;</span><br><span class="line">    level.push_back(root);</span><br><span class="line">    <span class="keyword">while</span>(!level.empty())&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; tmp;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; level_val;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;level.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(level[i]-&gt;left)</span><br><span class="line">                tmp.push_back(level[i]-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(level[i]-&gt;right)</span><br><span class="line">                tmp.push_back(level[i]-&gt;right);</span><br><span class="line">            level_val.push_back(level[i]-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.push_back(level_val);</span><br><span class="line">        level = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>105. Construct Binary Tree from Preorder and Inorder Traversal</title>
    <url>/2020/04/07/LeetCode_Cpp/0105._Construct_Binary_Tree_from_Preorder_and_Inorder_Traversal/</url>
    <content><![CDATA[<h1 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal"></a>105. Construct Binary Tree from Preorder and Inorder Traversal</h1><p> 难度: Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">根据一棵树的前序遍历与中序遍历构造二叉树。</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">你可以假设树中没有重复的元素。</span><br><span class="line"></span><br><span class="line">例如，给出</span><br><span class="line"></span><br><span class="line">前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br><span class="line">返回如下的二叉树：</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">和106思路一致</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span>&amp; index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> post = preorder[index];</span><br><span class="line">    <span class="keyword">int</span> i=start;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;end;i++)</span><br><span class="line">        <span class="keyword">if</span>(post == inorder[i])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    TreeNode* node = <span class="keyword">new</span> TreeNode(post);</span><br><span class="line">    <span class="keyword">if</span>(i&gt;start)</span><br><span class="line">        node-&gt;left = dfs(preorder, inorder, start, i<span class="number">-1</span>, ++index);</span><br><span class="line">    <span class="keyword">if</span>(i&lt;end)</span><br><span class="line">        node-&gt;right = dfs(preorder, inorder, i+<span class="number">1</span>, end, ++index);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preorder.empty()||inorder.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> index =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> dfs(preorder, inorder, <span class="number">0</span>, preorder.size()<span class="number">-1</span>, index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>106. Construct Binary Tree from Inorder and Postorder Traversal</title>
    <url>/2020/04/07/LeetCode_Cpp/0106._Construct_Binary_Tree_from_Inorder_and_Postorder_Traversal/</url>
    <content><![CDATA[<h1 id="106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal"><a href="#106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal" class="headerlink" title="106. Construct Binary Tree from Inorder and Postorder Traversal"></a>106. Construct Binary Tree from Inorder and Postorder Traversal</h1><p> 难度: Medium</p>
<h2 id="原题内容"><a href="#原题内容" class="headerlink" title="原题内容"></a>原题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/</a></p>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">根据一棵树的中序遍历与后序遍历构造二叉树。</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">你可以假设树中没有重复的元素。</span><br><span class="line"></span><br><span class="line">例如，给出</span><br><span class="line"></span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br><span class="line">后序遍历 postorder &#x3D; [9,15,7,20,3]</span><br><span class="line">返回如下的二叉树：</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">后序二叉树最后访问根节点</span><br><span class="line">中序二叉树的节点在中间，左边是左子树，反之是右子树。</span><br><span class="line">通过后序二叉树找到子树根节点，然后到中序二叉树中区分左右子树，递归求解。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder, <span class="keyword">int</span>&amp; val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> post = postorder[val];</span><br><span class="line">    <span class="keyword">int</span> i=start;</span><br><span class="line">    <span class="keyword">for</span>(; i&lt;end;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder[i]==post)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">    TreeNode* root=<span class="keyword">new</span> TreeNode(post);</span><br><span class="line">    <span class="keyword">if</span>(end&gt;=i+<span class="number">1</span>)</span><br><span class="line">        root-&gt;right=dfs(i+<span class="number">1</span>, end, inorder, postorder, --val);</span><br><span class="line">    <span class="keyword">if</span>(i<span class="number">-1</span>&gt;=start)</span><br><span class="line">        root-&gt;left = dfs(start, i<span class="number">-1</span>, inorder, postorder, --val);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(inorder.empty()||postorder.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> index = inorder.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span>, index, inorder, postorder, index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>107.Binary Tree Level Order Traversal II</title>
    <url>/2020/04/07/LeetCode_Cpp/0107._Binary_Tree%20Level_Order_Traversal_II/</url>
    <content><![CDATA[<h1 id="107-Binary-Tree-Level-Order-Traversal-II"><a href="#107-Binary-Tree-Level-Order-Traversal-II" class="headerlink" title="107.Binary Tree Level Order Traversal II"></a>107.Binary Tree Level Order Traversal II</h1><p><strong><font color=red>难度Easy</font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-level-order-traversal-ii/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a binary tree, return the bottom-up level order traversal of its nodes&#39; values. (ie, from left to right, level by level from leaf to root).</span><br><span class="line"></span><br><span class="line">For example:</span><br><span class="line">Given binary tree [3,9,20,null,null,15,7],</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">return its bottom-up level order traversal as:</span><br><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路1<br><strong>**</strong>- 时间复杂度: O(n)<strong>**</strong>- 空间复杂度: O(n)<strong>**</strong></p>
</blockquote>
<p>这是一道典型的BFS题目，第一种方法我用的是递归的方法，比较慢。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">levelOrderBottom</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ret;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        v.push_back(root -&gt;val);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; temp1 = levelOrderBottom(root -&gt;left);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; temp2 = levelOrderBottom(root -&gt;right);</span><br><span class="line">        <span class="keyword">int</span> pos1 = temp1.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pos2 = temp2.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(pos1 &gt;= <span class="number">0</span>  &amp;&amp; pos2 &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp1[pos1].insert(temp1[pos1].end(),temp2[pos2].begin(),temp2[pos2].end());</span><br><span class="line">            --pos1;</span><br><span class="line">            --pos2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos2 &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> pos = temp2.begin() + pos2 + <span class="number">1</span>;</span><br><span class="line">            temp1.insert(temp1.begin(),temp2.begin(),pos);</span><br><span class="line">        &#125;</span><br><span class="line">        temp1.push_back(v);</span><br><span class="line">        <span class="keyword">return</span> temp1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路2<br><strong>**</strong>- 时间复杂度: O(n)<strong>**</strong>- 空间复杂度: O(n)<strong>**</strong></p>
</blockquote>
<p>第二种改进的方法用的是类似栈的储存方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrderBottom</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ret;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode&gt; v;</span><br><span class="line">            v.push_back(*root);</span><br><span class="line">            judge(v,ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">judge</span><span class="params">(<span class="built_in">vector</span>&lt;TreeNode&gt;&amp; v,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; ret)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode&gt; v1;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; v.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            v2.push_back(v[i].val);</span><br><span class="line">            <span class="keyword">if</span>(v[i].left != <span class="literal">nullptr</span>)</span><br><span class="line">                v1.push_back(*(v[i].left));</span><br><span class="line">            <span class="keyword">if</span>(v[i].right != <span class="literal">nullptr</span>)</span><br><span class="line">                v1.push_back(*(v[i].right));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(v1.size())</span><br><span class="line">            judge(v1,ret);</span><br><span class="line">        ret.push_back(v2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>108. Convert Sorted Array to Binary Search Tree</title>
    <url>/2020/04/07/LeetCode_Cpp/0108._Convert_Sorted_Array_to_Binary_Search_Tree/</url>
    <content><![CDATA[<h1 id="108-Convert-Sorted-Array-to-Binary-Search-Tree"><a href="#108-Convert-Sorted-Array-to-Binary-Search-Tree" class="headerlink" title="108. Convert Sorted Array to Binary Search Tree"></a>108. Convert Sorted Array to Binary Search Tree</h1><p>难度:Easy</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</span><br><span class="line"></span><br><span class="line">For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Given the sorted array: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     &#x2F; \</span><br><span class="line">   -3   9</span><br><span class="line">   &#x2F;   &#x2F;</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><blockquote>
<p>思路1<br><strong>**</strong>- 时间复杂度: O(n)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>由于是给定的是已排序好的数组，平衡二叉树要求左子树与右字数的差的绝对值不能大于1。因此只需每次将数组对半，其中一半作为左子树，另一半作为右子树即可。这里用assign进行vecrtor赋值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!nums.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(nums[nums.size() / <span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1,v2;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() / <span class="number">2</span> &gt;= <span class="number">0</span>)</span><br><span class="line">            v1.assign(nums.begin(),nums.begin() + nums.size() / <span class="number">2</span>);</span><br><span class="line">        root -&gt;left = sortedArrayToBST(v1);</span><br><span class="line">        <span class="keyword">if</span>(nums.size() / <span class="number">2</span> + <span class="number">1</span> &lt; nums.size())</span><br><span class="line">            v2.assign(nums.begin() + nums.size() / <span class="number">2</span> + <span class="number">1</span>,nums.end());</span><br><span class="line">        root -&gt;right = sortedArrayToBST(v2);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>111. Minimum Depth of Binary Tree</title>
    <url>/2020/04/07/LeetCode_Cpp/0111._minimum_depth_of_binary_tree/</url>
    <content><![CDATA[<h1 id="111-Minimum-Depth-of-Binary-Tree"><a href="#111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="111. Minimum Depth of Binary Tree"></a>111. Minimum Depth of Binary Tree</h1><p> 难度: Easy</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/</a><blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a binary tree, find its minimum depth.</span><br><span class="line"></span><br><span class="line">The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</span><br><span class="line"></span><br><span class="line">Note: A leaf is a node with no children.</span><br></pre></td></tr></table></figure>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">遍历树，找出最小深度的分支</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> depth, <span class="keyword">int</span>&amp; ans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span> &amp;&amp; root-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(depth&lt;ans)</span><br><span class="line">            ans = depth;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root-&gt;left, depth+<span class="number">1</span>, ans);</span><br><span class="line">    dfs(root-&gt;right, depth+<span class="number">1</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    dfs(root, <span class="number">1</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>112. Path Sum</title>
    <url>/2020/04/07/LeetCode_Cpp/0112._Path_Sum/</url>
    <content><![CDATA[<h1 id="112-Path-Sum"><a href="#112-Path-Sum" class="headerlink" title="112. Path Sum"></a>112. Path Sum</h1><p>难度:Easy</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/path-sum/" target="_blank" rel="noopener">https://leetcode.com/problems/path-sum/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</span><br><span class="line"></span><br><span class="line">Note: A leaf is a node with no children.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Given the below binary tree and sum &#x3D; 22,</span><br><span class="line"></span><br><span class="line">      5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   8</span><br><span class="line">   &#x2F;   &#x2F; \</span><br><span class="line">  11  13  4</span><br><span class="line"> &#x2F;  \      \</span><br><span class="line">7    2      1</span><br><span class="line">return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.</span><br><span class="line"></span><br><span class="line">&gt; 思路</span><br><span class="line">******- 时间复杂度: O(N)******- 空间复杂度: O(1)******</span><br><span class="line">DFS遍历二叉树，分别计算左子树和右子树的是否存在 sum - val 的路径</span><br></pre></td></tr></table></figure>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root -&gt;right == <span class="literal">nullptr</span> &amp;&amp; root -&gt;left == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> sum - root -&gt;val ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root -&gt;left,sum - root -&gt;val) || hasPathSum(root -&gt;right,sum - root -&gt;val); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>109. Convert Sorted List to Binary Search Tree</title>
    <url>/2020/04/07/LeetCode_Cpp/0109._Convert_Sorted_List_to_Binary_Search_Tree/</url>
    <content><![CDATA[<h1 id="109-Convert-Sorted-List-to-Binary-Search-Tree"><a href="#109-Convert-Sorted-List-to-Binary-Search-Tree" class="headerlink" title="109. Convert Sorted List to Binary Search Tree"></a>109. Convert Sorted List to Binary Search Tree</h1><p> 难度: Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/</a></p>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</span><br><span class="line"></span><br><span class="line">本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">给定的有序链表： [-10, -3, 0, 5, 9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     &#x2F; \</span><br><span class="line">   -3   9</span><br><span class="line">   &#x2F;   &#x2F;</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 用快慢指针找链表中点</span><br><span class="line">2. 断开前半部分和后半部分</span><br><span class="line">3. 迭代构造左右子树</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">dfs</span><span class="params">(ListNode* node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(node-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(node-&gt;val);</span><br><span class="line">    ListNode* fast=node;</span><br><span class="line">    ListNode* slow=node;</span><br><span class="line">    ListNode* last = slow;</span><br><span class="line">    <span class="keyword">while</span>(fast&amp;&amp;fast-&gt;next)&#123;</span><br><span class="line">        last = slow;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    fast = slow-&gt;next;</span><br><span class="line">    last-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode(slow-&gt;val);</span><br><span class="line">    <span class="keyword">if</span> (node != slow) </span><br><span class="line">        root-&gt;left=dfs(node);</span><br><span class="line">    root-&gt;right=dfs(fast);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dfs(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>110.Balanced Binary Tree</title>
    <url>/2020/04/07/LeetCode_Cpp/0110._Balanced_Binary_Tree/</url>
    <content><![CDATA[<h1 id="110-Balanced-Binary-Tree"><a href="#110-Balanced-Binary-Tree" class="headerlink" title="110.Balanced Binary Tree"></a>110.Balanced Binary Tree</h1><p>难度:Easy</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/balanced-binary-tree/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a binary tree, determine if it is height-balanced.</span><br><span class="line"></span><br><span class="line">For this problem, a height-balanced binary tree is defined as:</span><br><span class="line"></span><br><span class="line">a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Given the following tree [3,9,20,null,null,15,7]:</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">Return true.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Given the following tree [1,2,2,3,3,null,null,4,4]:</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">      &#x2F; \</span><br><span class="line">     2   2</span><br><span class="line">    &#x2F; \</span><br><span class="line">   3   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 4   4</span><br><span class="line">Return false.</span><br></pre></td></tr></table></figure>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(n)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>判断有个平衡二叉树，我们只要先求出左右子树的高度差，判断是否大于1，再分别判断左右子树是否为平衡二叉树即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(height(root -&gt;left) - height(root -&gt;right)) &lt;= <span class="number">1</span> &amp;&amp; isBalanced(root -&gt;left) &amp;&amp; isBalanced(root -&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> max(height(root -&gt;left),height(root -&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>114. Flatten Binary Tree to Linked List</title>
    <url>/2020/04/07/LeetCode_Cpp/0114._Flatten_Binary_Tree_to_Linked_List/</url>
    <content><![CDATA[<h1 id="114-Flatten-Binary-Tree-to-Linked-List"><a href="#114-Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="114. Flatten Binary Tree to Linked List"></a>114. Flatten Binary Tree to Linked List</h1><p> 难度: Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/</a></p>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个二叉树，原地将它展开为链表。</span><br><span class="line"></span><br><span class="line">例如，给定二叉树</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   5</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">3   4   6</span><br><span class="line">将其展开为：</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line">       \</span><br><span class="line">        5</span><br><span class="line">         \</span><br><span class="line">          6</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">后续遍历二叉树</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    dfs(root-&gt;left);</span><br><span class="line">    dfs(root-&gt;right);</span><br><span class="line">    TreeNode* tmp=root-&gt;right;</span><br><span class="line">    root-&gt;right=root-&gt;left;</span><br><span class="line">    root-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(root-&gt;right)</span><br><span class="line">        root=root-&gt;right;</span><br><span class="line">    root-&gt;right = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    dfs(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>115.Distinct Subsequences</title>
    <url>/2020/04/07/LeetCode_Cpp/0115._Distinct_Subsequences/</url>
    <content><![CDATA[<h1 id="115-Distinct-Subsequences"><a href="#115-Distinct-Subsequences" class="headerlink" title="115.Distinct Subsequences"></a>115.Distinct Subsequences</h1><p>难度:Hard</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/distinct-subsequences/" target="_blank" rel="noopener">https://leetcode.com/problems/distinct-subsequences/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a string S and a string T, count the number of distinct subsequences of S which equals T.</span><br><span class="line"></span><br><span class="line">A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, &quot;ACE&quot; is a subsequence of &quot;ABCDE&quot; while &quot;AEC&quot; is not).</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: S &#x3D; &quot;rabbbit&quot;, T &#x3D; &quot;rabbit&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">As shown below, there are 3 ways you can generate &quot;rabbit&quot; from S.</span><br><span class="line">(The caret symbol ^ means the chosen letters)</span><br><span class="line"></span><br><span class="line">rabbbit</span><br><span class="line">^^^^ ^^</span><br><span class="line">rabbbit</span><br><span class="line">^^ ^^^^</span><br><span class="line">rabbbit</span><br><span class="line">^^^ ^^^</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: S &#x3D; &quot;babgbag&quot;, T &#x3D; &quot;bag&quot;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">As shown below, there are 5 ways you can generate &quot;bag&quot; from S.</span><br><span class="line">(The caret symbol ^ means the chosen letters)</span><br><span class="line"></span><br><span class="line">babgbag</span><br><span class="line">^^ ^</span><br><span class="line">babgbag</span><br><span class="line">^^    ^</span><br><span class="line">babgbag</span><br><span class="line">^    ^^</span><br><span class="line">babgbag</span><br><span class="line">  ^  ^^</span><br><span class="line">babgbag</span><br><span class="line">    ^^^</span><br></pre></td></tr></table></figure>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(n^2)<strong>**</strong>- 空间复杂度: O(n^2)<strong>**</strong></p>
</blockquote>
<p>这题是一道动态规划的问题，动态问题的关键的就是写出状态转移方程。这里我们定义一个数组 dp[m][n],表示在 s[m] 和 t[n] 之前有几个匹配的子序列，这样我们可以写出状态转移方程<br>当 s[m] != t[n]，dp[m][n] = dp[m - 1][n]。else dp[m][n] += (dp[m - 1][n] + dp[m - 1][n - 1])</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> l1 = s.length(),l2 = t.length();</span><br><span class="line">    <span class="keyword">int</span> dp[l1 + <span class="number">1</span>][l2 + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= l1;++i)</span><br><span class="line">        <span class="keyword">if</span>(s[i - <span class="number">1</span>] == t[<span class="number">0</span>])</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= l1;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= l2;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i - <span class="number">1</span>] != t[j - <span class="number">1</span>])</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] += (dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j]);</span><br><span class="line">            <span class="comment">//cout &lt;&lt; dp[i][j] &lt;&lt; " ";</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[l1][l2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>118. Pascal&#39;s Triangle</title>
    <url>/2020/04/07/LeetCode_Cpp/0118._Pascals_Triangle/</url>
    <content><![CDATA[<h2 id="118-Pascal’s-Triangle"><a href="#118-Pascal’s-Triangle" class="headerlink" title="118. Pascal’s Triangle"></a>118. Pascal’s Triangle</h2><p>难度：Easy</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><p>题目链接：<a href="https://leetcode.com/problems/pascals-triangle/description/" target="_blank" rel="noopener">https://leetcode.com/problems/pascals-triangle/description/</a></p>
<p>Given a non-negative integer <em>numRows</em>, generate the first <em>numRows</em> of Pascal’s triangle.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt="img"><br>In Pascal’s triangle, each number is the sum of the two numbers directly above it.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>该题比较简单，杨辉三角形，从第三行开始，除了首尾，中间元素的值可通过如下公式计算：<code>cur[i] = prev[i] + prev[i-1]</code></p>
<p>计算当前行实现要点如下：</p>
<ul>
<li>拷贝上一行，并在末尾添加元素1</li>
<li>倒着开始计算，除了首尾，<code>cur[i] += cur[i-1]</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        for (auto i &#x3D; 0; i &lt; numRows; ++i) &#123;</span><br><span class="line">            vector&lt;int&gt; row;</span><br><span class="line">            if (!res.empty()) </span><br><span class="line">                row.assign(res.at(i-1).begin(), res.at(i-1).end());</span><br><span class="line">            row.emplace_back(1);</span><br><span class="line">            for (auto j &#x3D; i - 1; j &gt; 0; --j)</span><br><span class="line">                row[j] +&#x3D; row[j-1];</span><br><span class="line">            res.emplace_back(row);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>来源：<a href="https://github.com/xiaqunfeng/leetcode" target="_blank" rel="noopener">https://github.com/xiaqunfeng/leetcode</a></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>119. Pascal&#39;s Triangle II</title>
    <url>/2020/04/07/LeetCode_Cpp/0119._Pascals_Triangle-II/</url>
    <content><![CDATA[<h2 id="119-Pascal’s-Triangle-II"><a href="#119-Pascal’s-Triangle-II" class="headerlink" title="119. Pascal’s Triangle II"></a>119. Pascal’s Triangle II</h2><p>难度：Easy</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><p>题目链接：<a href="https://leetcode.com/problems/pascals-triangle-ii/description/" target="_blank" rel="noopener">https://leetcode.com/problems/pascals-triangle-ii/description/</a></p>
<p>Given a non-negative index <em>k</em> where <em>k</em> ≤ 33, return the <em>k</em>th index row of the Pascal’s triangle.</p>
<p>Note that the row index starts from 0.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt="img"><br>In Pascal’s triangle, each number is the sum of the two numbers directly above it.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: [1,3,3,1]</span><br></pre></td></tr></table></figure>

<p><strong>Follow up:</strong></p>
<p>Could you optimize your algorithm to use only <em>O</em>(<em>k</em>) extra space?</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>思路和<a href="118._Pascals_Triangle.md">上一题</a>一样，只不过这里不需要存每一行的数据。</p>
<p>注意：和上一题相比，这里的 <code>rowIndex + 1 = numRows</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; getRow(int rowIndex) &#123;</span><br><span class="line">        vector&lt;int&gt; res(rowIndex+1, 0);</span><br><span class="line">        res[0] &#x3D; 1;</span><br><span class="line">        for (auto i &#x3D; 0; i &lt;&#x3D; rowIndex; ++i) </span><br><span class="line">            for (auto j &#x3D; i; j &gt; 0; --j)</span><br><span class="line">                res[j] +&#x3D; res[j-1];</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>来源：<a href="https://github.com/xiaqunfeng/leetcode" target="_blank" rel="noopener">https://github.com/xiaqunfeng/leetcode</a></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>120. Triangle</title>
    <url>/2020/04/07/LeetCode_Cpp/0120._Triangle/</url>
    <content><![CDATA[<h1 id="120-Triangle"><a href="#120-Triangle" class="headerlink" title="120. Triangle"></a>120. Triangle</h1><p> 难度: Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/triangle/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/triangle/</a></p>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</span><br><span class="line"></span><br><span class="line">例如，给定三角形：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br><span class="line">自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 &#x3D; 11）。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dfs超时</span><br><span class="line">采用dp，自底向上更新每个数，每个数加上向下路径的最小和，更新到第一层既为第一层向下路径的最小和。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = triangle.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; triangle[i].size(); j++)</span><br><span class="line">            triangle[i][j] += min(triangle[i + <span class="number">1</span>][j], triangle[i + <span class="number">1</span>][j + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>121. Best Time to Buy and Sell Stock</title>
    <url>/2020/04/07/LeetCode_Cpp/0121._Best_Tim_%20to_Buy_and_Sell_Stock/</url>
    <content><![CDATA[<h1 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121. Best Time to Buy and Sell Stock"></a>121. Best Time to Buy and Sell Stock</h1><p>难度:Easy</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/submissions/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock/submissions/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">Say you have an array for which the ith element is the price of a given stock on day i.</span><br><span class="line"></span><br><span class="line">If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.</span><br><span class="line"></span><br><span class="line">Note that you cannot sell a stock before you buy one.</span><br></pre></td></tr></table></figure>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(n)<strong><strong><em>- 空间复杂度: O(1)*</em></strong></strong><br>直接遍历数组，每次记录最小值，若此时的price大于最小值，就比较<code>min(ans,prices[i] - min)</code></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min1 = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; prices.size();++i)</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; min1)</span><br><span class="line">                ans = max(ans,prices[i] - min1);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                min1 = prices[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">                </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>122. Best Time to Buy and Sell Stock II</title>
    <url>/2020/04/07/LeetCode_Cpp/0122._Best_Time_to_Buy_and_Sell_Stock_II/</url>
    <content><![CDATA[<h1 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a>122. Best Time to Buy and Sell Stock II</h1><p>难度:Easy</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Say you have an array for which the ith element is the price of a given stock on day i.</span><br><span class="line"></span><br><span class="line">Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).</span><br><span class="line"></span><br><span class="line">Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [7,1,5,3,6,4]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Buy on day 2 (price &#x3D; 1) and sell on day 3 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4.</span><br><span class="line">             Then buy on day 4 (price &#x3D; 3) and sell on day 5 (price &#x3D; 6), profit &#x3D; 6-3 &#x3D; 3.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [1,2,3,4,5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Buy on day 1 (price &#x3D; 1) and sell on day 5 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4.</span><br><span class="line">             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are</span><br><span class="line">             engaging multiple transactions at the same time. You must sell before buying again.</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transaction is done, i.e. max profit &#x3D; 0.</span><br></pre></td></tr></table></figure>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(N)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>用暴力的解法很快就可以做出来这题，但是我们可以用更好的方法在O(N)的时间复杂度解决这题。定义i = 1。遍历数组。如果 prices[i] &gt; prices[i - 1]。ans += （prices[i] - prices[i - 1]）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxRet = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; prices.size();++i)</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i - <span class="number">1</span>])</span><br><span class="line">                maxRet += (prices[i] - prices[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> maxRet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>123. Best Time to Buy and Sell Stock III</title>
    <url>/2020/04/07/LeetCode_Cpp/0123._Best_Time_to_Buy%20_and_Sell_Stock_III/</url>
    <content><![CDATA[<h1 id="123-Best-Time-to-Buy-and-Sell-Stock-III"><a href="#123-Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="123. Best Time to Buy and Sell Stock III"></a>123. Best Time to Buy and Sell Stock III</h1><p>难度:Hard</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Say you have an array for which the ith element is the price of a given stock on day i.</span><br><span class="line"></span><br><span class="line">Design an algorithm to find the maximum profit. You may complete at most two transactions.</span><br><span class="line"></span><br><span class="line">Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [3,3,5,0,0,3,1,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Buy on day 4 (price &#x3D; 0) and sell on day 6 (price &#x3D; 3), profit &#x3D; 3-0 &#x3D; 3.</span><br><span class="line">             Then buy on day 7 (price &#x3D; 1) and sell on day 8 (price &#x3D; 4), profit &#x3D; 4-1 &#x3D; 3.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [1,2,3,4,5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Buy on day 1 (price &#x3D; 1) and sell on day 5 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4.</span><br><span class="line">             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are</span><br><span class="line">             engaging multiple transactions at the same time. You must sell before buying again.</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transaction is done, i.e. max profit &#x3D; 0.</span><br></pre></td></tr></table></figure>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><blockquote>
<p>思路1<br><strong>**</strong>- 时间复杂度: O(n^2)<strong>**</strong>- 空间复杂度: O(n)<strong>**</strong></p>
</blockquote>
<p>与之前的不同，这次需要交易两次，因此我们用记忆化的方法记录下第i天的之后交易的最大值，这就是第二次每天交易之后的最大值，接着只要遍历数组，求出第一天交易最大值，第一个方法我枚举了每次交易，求出了最大值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.size();</span><br><span class="line">        <span class="keyword">if</span>(!len)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> arr[len + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(arr,<span class="number">0</span>,<span class="keyword">sizeof</span>(arr));</span><br><span class="line">        <span class="keyword">int</span> max1 = prices[len - <span class="number">1</span>],price = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = len - <span class="number">2</span>;j &gt;= <span class="number">0</span>;--j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[j] &gt; max1)</span><br><span class="line">                max1 = prices[j];</span><br><span class="line">            arr[j] = max(arr[j + <span class="number">1</span>],max1 - prices[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; len;++j)</span><br><span class="line">                <span class="keyword">if</span>(prices[j] &gt; prices[i])</span><br><span class="line">                    ret = max(ret,prices[j] - prices[i] + arr[j + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路2<br><strong>**</strong>- 时间复杂度: O(n)<strong>**</strong>- 空间复杂度: O(n)<strong>**</strong></p>
</blockquote>
<p>第二种方法就是对思路1进行了优化，再求第一次交易时定义一个最小值min1，代表了第i天之前的最小值，之后遍历数组，每次更新min1，求得prices[i] - min1的最大值即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.size();</span><br><span class="line">        <span class="keyword">if</span>(!len)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> arr[len + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(arr,<span class="number">0</span>,<span class="keyword">sizeof</span>(arr));</span><br><span class="line">        <span class="keyword">int</span> max1 = prices[len - <span class="number">1</span>],price = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = len - <span class="number">2</span>;j &gt;= <span class="number">0</span>;--j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[j] &gt; max1)</span><br><span class="line">                max1 = prices[j];</span><br><span class="line">            arr[j] = max(arr[j + <span class="number">1</span>],max1 - prices[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min1 = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt; min1)</span><br><span class="line">                min1 = prices[i];</span><br><span class="line">            ret = max(ret,prices[i] - min1 + arr[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>124. Binary Tree Maximum Path Sum</title>
    <url>/2020/04/07/LeetCode_Cpp/0124._Binary_Tree_Maximum_Path_Sum/</url>
    <content><![CDATA[<h1 id="124-Binary-Tree-Maximum-Path-Sum"><a href="#124-Binary-Tree-Maximum-Path-Sum" class="headerlink" title="124. Binary Tree Maximum Path Sum"></a>124. Binary Tree Maximum Path Sum</h1><p>难度:Hard</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-maximum-path-sum/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a non-empty binary tree, find the maximum path sum.</span><br><span class="line"></span><br><span class="line">For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [1,2,3]</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">      &#x2F; \</span><br><span class="line">     2   3</span><br><span class="line"></span><br><span class="line">Output: 6</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [-10,9,20,null,null,15,7]</span><br><span class="line"></span><br><span class="line">   -10</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">Output: 42</span><br></pre></td></tr></table></figure>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(N)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>最先想到的是树形DP，时间复杂度为O(n^2)，不过这题是二叉树，只有左子树和右子树。因此，我们可以用更优化的算法。可以用后序遍历二叉树，然后记录下这个节点的最大路径与 ans比较。返回 max(l,r) 加上这个节点的值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MIN;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">travel</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = travel(root -&gt;left);</span><br><span class="line">        <span class="keyword">int</span> r = travel(root -&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(l &lt; <span class="number">0</span>)</span><br><span class="line">            l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(r &lt; <span class="number">0</span>)</span><br><span class="line">            r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = r + l + root -&gt;val;</span><br><span class="line">        ans = max(ans,temp);</span><br><span class="line">        <span class="keyword">return</span> max(l,r) + root -&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        travel(root);</span><br><span class="line">        <span class="keyword">if</span>(ans == INT_MIN)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>128. Longest Consecutive Sequence</title>
    <url>/2020/04/07/LeetCode_Cpp/0128._Longest_Consecutive_Sequence/</url>
    <content><![CDATA[<h1 id="128-Longest-Consecutive-Sequence"><a href="#128-Longest-Consecutive-Sequence" class="headerlink" title="128. Longest Consecutive Sequence"></a>128. Longest Consecutive Sequence</h1><p>难度:Hard</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-consecutive-sequence/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</span><br><span class="line"></span><br><span class="line">Your algorithm should run in O(n) complexity.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: [100, 4, 200, 1, 3, 2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.</span><br></pre></td></tr></table></figure>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><blockquote>
<p>思路1<br><strong>**</strong>- 时间复杂度: O(n)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>先对数组进行排序。在用unique()函数去除重复的数字。在遍历数组，找到最长的连续数字。时间复杂度为O(nlgn)。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!nums.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">auto</span> end_pos = unique(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">int</span> j = end_pos - nums.begin();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>,sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; j;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[i - <span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">                sum++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                sum = <span class="number">1</span>;</span><br><span class="line">            ans = max(ans,sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路2<br><strong>**</strong>- 时间复杂度: O(nlgn)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong><br>c++中的unordered_map是用hash桶实现的，所以可以在线性时间内完成。县遍历数组，用nums[i]作为unordered_map的键值。0作为 value。0表示此时的nums[i]还没被遍历过。接着遍历数组，用DFS搜索每个nums[i]的最长连续数字。被遍历过的nums[i]的unordered_map值设为1</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!nums.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.size();++i)</span><br><span class="line">            m[nums[i]] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(m[nums[i]])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            m[nums[i]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i] + <span class="number">1</span>,sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(m.find(temp) != m.end())</span><br><span class="line">                m[temp++] = <span class="number">1</span>;</span><br><span class="line">            sum = temp - nums[i];</span><br><span class="line">            temp = nums[i] - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; temp &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">while</span>(m.find(temp) != m.end())</span><br><span class="line">                m[temp--] = <span class="number">1</span>;</span><br><span class="line">            sum += (nums[i] - temp - <span class="number">1</span>);</span><br><span class="line">            ans = max(ans,sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>131. Palindrome Paritionaing</title>
    <url>/2020/04/07/LeetCode_Cpp/0131._Palindrome_Partitioning/</url>
    <content><![CDATA[<h1 id="131-Palindrome-Paritionaing"><a href="#131-Palindrome-Paritionaing" class="headerlink" title="131. Palindrome Paritionaing"></a>131. Palindrome Paritionaing</h1><p> 难度: Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/palindrome-partitioning/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/palindrome-partitioning/</a></p>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</span><br><span class="line"></span><br><span class="line">返回 s 所有可能的分割方案。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: &quot;aab&quot;</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;aa&quot;,&quot;b&quot;],</span><br><span class="line">  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">回溯，判断是否回文。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length()/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i]!=str[str.length()-i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; path, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; ans, <span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == s.length())&#123;</span><br><span class="line">        ans.push_back(path);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isValid(s.substr(start, i-start+<span class="number">1</span>)))&#123;</span><br><span class="line">            path.push_back(s.substr(start, i-start+<span class="number">1</span>));</span><br><span class="line">            dfs(i+<span class="number">1</span>, path, ans, s);</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">partition</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">if</span>(s.length()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path;</span><br><span class="line">    dfs(<span class="number">0</span>, path, ans, s);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>136. Single Numbe</title>
    <url>/2020/04/07/LeetCode_Cpp/0136._Single_Numbe/</url>
    <content><![CDATA[<h1 id="136-Single-Numbe"><a href="#136-Single-Numbe" class="headerlink" title="136. Single Numbe"></a>136. Single Numbe</h1><p>难度:Easy</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/single-number/" target="_blank" rel="noopener">https://leetcode.com/problems/single-number/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a non-empty array of integers, every element appears twice except for one. Find that single one.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [2,2,1]</span><br><span class="line">Output: 1</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [4,1,2,1,2]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><blockquote>
<p>思路1<br><strong>**</strong>- 时间复杂度: O(n)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>用异或运算解决这道题，这里用了异或运算的几个性质，异或的交换和结合律，还有两个相同的数异或的值为0，任何数异或0为它本身。有了这些基本只是之后，我们只要对数组进行异或运算得到的数就是答案。因为只有一个数是 single number，其余的数都成双，那么最后就相当于single number异或0</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.size();++i)</span><br><span class="line">            ans ^= nums[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路2<br><strong>**</strong>- 时间复杂度: O(n)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>第二种思路将所有数转成二进制，记录下每一位不为2的倍数，这些位为1，其余为0，求出最后的数就是答案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> arr[<span class="number">32</span>][<span class="number">2</span>],t = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(arr,<span class="number">0</span>,<span class="keyword">sizeof</span>(arr));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> count1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                t *= <span class="number">-1</span>;</span><br><span class="line">                nums[i] *= <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                arr[count1++][nums[i] % <span class="number">2</span>]++;</span><br><span class="line">                nums[i] /= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">32</span>;++i)</span><br><span class="line">            <span class="keyword">if</span>(arr[i][<span class="number">1</span>] % <span class="number">2</span>)</span><br><span class="line">                ans += <span class="built_in">pow</span>(<span class="number">2</span>,i);</span><br><span class="line">        <span class="keyword">if</span>(t &lt; <span class="number">0</span>)</span><br><span class="line">            ans *= <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>129. Sum Root to Leaf Numbers</title>
    <url>/2020/04/07/LeetCode_Cpp/0129._Sum_Root_to_Leaf_Numbers/</url>
    <content><![CDATA[<h1 id="129-Sum-Root-to-Leaf-Numbers"><a href="#129-Sum-Root-to-Leaf-Numbers" class="headerlink" title="129. Sum Root to Leaf Numbers"></a>129. Sum Root to Leaf Numbers</h1><p> 难度: Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/</a></p>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。</span><br><span class="line"></span><br><span class="line">例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。</span><br><span class="line"></span><br><span class="line">计算从根到叶子节点生成的所有数字之和。</span><br><span class="line"></span><br><span class="line">说明: 叶子节点是指没有子节点的节点。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [1,2,3]</span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line">输出: 25</span><br><span class="line">解释:</span><br><span class="line">从根到叶子节点路径 1-&gt;2 代表数字 12.</span><br><span class="line">从根到叶子节点路径 1-&gt;3 代表数字 13.</span><br><span class="line">因此，数字总和 &#x3D; 12 + 13 &#x3D; 25.</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [4,9,0,5,1]</span><br><span class="line">    4</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9   0</span><br><span class="line"> &#x2F; \</span><br><span class="line">5   1</span><br><span class="line">输出: 1026</span><br><span class="line">解释:</span><br><span class="line">从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495.</span><br><span class="line">从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491.</span><br><span class="line">从根到叶子节点路径 4-&gt;0 代表数字 40.</span><br><span class="line">因此，数字总和 &#x3D; 495 + 491 + 40 &#x3D; 1026.</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">深搜，记录路径，到叶子节点相加</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="built_in">string</span> path, <span class="keyword">int</span>&amp; sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span> &amp;&amp; root-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        path = path+<span class="built_in">std</span>::to_string(root-&gt;val);</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="built_in">std</span>::stoi(path);</span><br><span class="line">        sum+=tmp;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root-&gt;left, path+<span class="built_in">std</span>::to_string(root-&gt;val), sum);</span><br><span class="line">    dfs(root-&gt;right, path+<span class="built_in">std</span>::to_string(root-&gt;val), sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    dfs(root, <span class="string">""</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>141. linked list cycle</title>
    <url>/2020/04/07/LeetCode_Cpp/0141._linked_list_cycle/</url>
    <content><![CDATA[<h1 id="141-linked-list-cycle"><a href="#141-linked-list-cycle" class="headerlink" title="141. linked list cycle"></a>141. linked list cycle</h1><p>难度:Easy</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<p>*<a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="noopener">https://leetcode.com/problems/linked-list-cycle/</a></p>
<ul>
<li><blockquote>
<p>内容描述</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a linked list, determine if it has a cycle in it.</span><br><span class="line"></span><br><span class="line">Follow up:</span><br><span class="line">Can you solve it without using extra space?</span><br></pre></td></tr></table></figure>

<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(N)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>这题典型的快慢指针在链表中的运用，定义两个指针，每次循环，一个加1，另一个加2，若两指针相遇，则有环。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode* l1 = head,*l2 = head -&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l2 == <span class="literal">nullptr</span> || l2 -&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(l1 == l2)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            l1 = l1 -&gt;next;</span><br><span class="line">            l2 = l2 -&gt;next -&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>142. linked list cycle II</title>
    <url>/2020/04/07/LeetCode_Cpp/0142._linked_list_cycle%20II/</url>
    <content><![CDATA[<h1 id="142-linked-list-cycle-II"><a href="#142-linked-list-cycle-II" class="headerlink" title="142. linked list cycle II"></a>142. linked list cycle II</h1><p>难度:Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/linked-list-cycle-ii/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</span><br><span class="line"></span><br><span class="line">Note: Do not modify the linked list.</span><br><span class="line"></span><br><span class="line">Follow up:</span><br><span class="line">Can you solve it without using extra space?</span><br></pre></td></tr></table></figure>

<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(N)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>上一道题已经解决了链表是否有环的问题，那么如何判断环的入口在哪里，我们先设入口链表的头的距离为m，两个人指针相遇的节点距离入口为x，l2比l1多走 n 圈，环部分的链表长度为p。这样，我们就得到了如下公式。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2(m + x) &#x3D; m + n * p + x</span><br></pre></td></tr></table></figure>
<p>化简得到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m &#x3D; n * p - x</span><br></pre></td></tr></table></figure>
<p>接着我们再定义一个指针 ret，当 ret 移动 m 个，l1刚好移动 n * p - x，就是二者相遇的地方即为入口</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* l1 = head,*l2 = head;</span><br><span class="line">    <span class="keyword">int</span> count1 = <span class="number">0</span>,count2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="literal">nullptr</span> || l2 -&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        l1 = l1 -&gt;next;</span><br><span class="line">        ++count1;</span><br><span class="line">        l2 = l2 -&gt;next -&gt;next;</span><br><span class="line"></span><br><span class="line">        ++count2;</span><br><span class="line">        <span class="keyword">if</span>(l1 == l2)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* ret = head;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == ret)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        ret = ret -&gt;next;</span><br><span class="line">        l1 = l1 -&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>137.Single Number II</title>
    <url>/2020/04/07/LeetCode_Cpp/0137._single_number_II/</url>
    <content><![CDATA[<h1 id="137-Single-Number-II"><a href="#137-Single-Number-II" class="headerlink" title="137.Single Number II"></a>137.Single Number II</h1><p>难度: Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/single-number-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/single-number-ii/</a><blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [2,2,3,2]</span><br><span class="line">Output: 3</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [0,1,0,1,0,1,99]</span><br><span class="line">Output: 99</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">相同的数有相同的二进制，相同位置有相同的1，0；所以如果都出现3次，那么相同位上出现的1和0都是3的倍数</span><br><span class="line">所以，统计不同位上1、0的个数，如果不是3的倍数，说明出现次数不是3的倍数。</span><br><span class="line">所有不为3倍数的位加起来就是结果。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[<span class="number">32</span>][<span class="number">2</span>],t = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(arr,<span class="number">0</span>,<span class="keyword">sizeof</span>(arr));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> count1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> temp = nums[i];</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                t++;</span><br><span class="line">                temp *= <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(temp)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[count1++][temp % <span class="number">2</span>]++;</span><br><span class="line">                temp /= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">32</span>;++i)</span><br><span class="line">            <span class="keyword">if</span>(arr[i][<span class="number">1</span>] % <span class="number">3</span>)</span><br><span class="line">                ans += <span class="built_in">pow</span>(<span class="number">2</span>,i);</span><br><span class="line">        <span class="keyword">if</span>(t % <span class="number">3</span>)</span><br><span class="line">            ans *= <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>144. Binary Tree Preorder Traversal</title>
    <url>/2020/04/07/LeetCode_Cpp/0144._Binary_Tree_Preorder_Traversal/</url>
    <content><![CDATA[<h1 id="144-Binary-Tree-Preorder-Traversal"><a href="#144-Binary-Tree-Preorder-Traversal" class="headerlink" title="144. Binary Tree Preorder Traversal"></a>144. Binary Tree Preorder Traversal</h1><p> 难度: Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-preorder-traversal/</a></p>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 给定一个二叉树，返回它的 前序 遍历。</span><br><span class="line"></span><br><span class="line"> 示例:</span><br><span class="line"></span><br><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [1,2,3]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">递归</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    ans.push_back(root-&gt;val);</span><br><span class="line">    dfs(root-&gt;left, ans);</span><br><span class="line">    dfs(root-&gt;right, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    dfs(root, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>145. Binary Tree Postorder Traversal</title>
    <url>/2020/04/07/LeetCode_Cpp/0145._Binary_Tree_Postorder_Traversal/</url>
    <content><![CDATA[<h1 id="145-Binary-Tree-Postorder-Traversal"><a href="#145-Binary-Tree-Postorder-Traversal" class="headerlink" title="145. Binary Tree Postorder Traversal"></a>145. Binary Tree Postorder Traversal</h1><p>难度:Hard</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-postorder-traversal/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a binary tree, return the postorder traversal of its nodes&#39; values.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [3,2,1]</span><br><span class="line">Follow up: Recursive solution is trivial, could you do it iteratively?</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路1<br><strong>**</strong>- 时间复杂度: O(N)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>后序遍历二叉树，先判断左子树存不存在，在判断右子树存不存在，最后添加root-&gt;val即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">travel</span><span class="params">(TreeNode* root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root -&gt;left)</span><br><span class="line">            travel(root -&gt;left,v);   </span><br><span class="line">        <span class="keyword">if</span>(root -&gt;right)</span><br><span class="line">            travel(root -&gt;right,v);</span><br><span class="line">        v.push_back(root -&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        travel(root,v);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路2<br><strong>**</strong>- 时间复杂度: O(N)<strong>**</strong>- 空间复杂度: O(N)<strong>**</strong></p>
</blockquote>
<p>题目中提到了不用递归用遍历的方式去解决这个问题。那么我们就需要用栈去储存元素，这时候我们还需要一个辅助栈来标记这个元素是否应该 pop。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; v;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count1;</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            v.push_back(root);</span><br><span class="line">            count1.push_back(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(v.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> index = v.size();</span><br><span class="line">            <span class="keyword">if</span>(!count1[index - <span class="number">1</span>] &amp;&amp; v[index <span class="number">-1</span>] -&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                count1[index - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                v.push_back(v[index - <span class="number">1</span>] -&gt;left);</span><br><span class="line">                count1.push_back(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(count1[index - <span class="number">1</span>] != <span class="number">2</span> &amp;&amp; v[index - <span class="number">1</span>] -&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                count1[index - <span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">                v.push_back(v[index - <span class="number">1</span>] -&gt;right);</span><br><span class="line">                count1.push_back(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans.push_back(v[index - <span class="number">1</span>] -&gt;val);</span><br><span class="line">                count1.pop_back();</span><br><span class="line">                v.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>147. Insertion Sort List</title>
    <url>/2020/04/07/LeetCode_Cpp/0147._Insert_on_Sort_List/</url>
    <content><![CDATA[<h1 id="147-Insertion-Sort-List"><a href="#147-Insertion-Sort-List" class="headerlink" title="147. Insertion Sort List"></a>147. Insertion Sort List</h1><p>难度:Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/insertion-sort-list/" target="_blank" rel="noopener">https://leetcode.com/problems/insertion-sort-list/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sort a linked list using insertion sort.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list.</span><br><span class="line">With each iteration one element (red) is removed from the input data and inserted in-place into the sorted list</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Algorithm of Insertion Sort:</span><br><span class="line"></span><br><span class="line">Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list.</span><br><span class="line">At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there.</span><br><span class="line">It repeats until no input elements remain.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 4-&gt;2-&gt;1-&gt;3</span><br><span class="line">Output: 1-&gt;2-&gt;3-&gt;4</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: -1-&gt;5-&gt;3-&gt;4-&gt;0</span><br><span class="line">Output: -1-&gt;0-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(N^2)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>对链表进行插入排序。和普通的插入排序一样，不过要注意需要对链表的操作很熟悉。当某个值在链表中的位置时需要将这个节点插入到合适的位置，执行依次链表的插入和删除操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">            ListNode* current = head -&gt;next;</span><br><span class="line">        ListNode* pre = head;</span><br><span class="line">        <span class="keyword">while</span>(current)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* temp2 = head;</span><br><span class="line">            ListNode* temp1 = head;</span><br><span class="line">            <span class="keyword">while</span>(temp2 -&gt;val &lt; current -&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                temp1 = temp2;</span><br><span class="line">                temp2 = temp2 -&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp1 != temp2)</span><br><span class="line">                temp1 -&gt;next = current;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                head = current;</span><br><span class="line">            <span class="keyword">if</span>(temp2 != current)</span><br><span class="line">            &#123;</span><br><span class="line">                pre -&gt;next = current -&gt;next;</span><br><span class="line">                current -&gt;next = temp2;</span><br><span class="line">                current = pre -&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pre = current;</span><br><span class="line">                current = current -&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>153. Find Minimum in Rotated Sorted Array</title>
    <url>/2020/04/07/LeetCode_Cpp/0153._Find_Minimum_in_Rotated_Sorted_Array/</url>
    <content><![CDATA[<h2 id="153-Find-Minimum-in-Rotated-Sorted-Array"><a href="#153-Find-Minimum-in-Rotated-Sorted-Array" class="headerlink" title="153. Find Minimum in Rotated Sorted Array"></a>153. Find Minimum in Rotated Sorted Array</h2><p>难度：Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><p>题目链接：<a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/" target="_blank" rel="noopener">https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/</a></p>
<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e.,  <code>[0,1,2,4,5,6,7]</code> might become  <code>[4,5,6,7,0,1,2]</code>).</p>
<p>Find the minimum element.</p>
<p>You may assume no duplicate exists in the array.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,4,5,1,2] </span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [4,5,6,7,0,1,2]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>最简单的方法，挨个遍历，如果当前值小于前一个值，那么输出当前值即可，时间复杂度为O(n)。<br>二分查找法，时间复杂度为O(log(n))。</p>
<p>快速简单的写了一个，提交，过了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findMin(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int res_idx &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 1; i &lt; nums.size(); ++i)</span><br><span class="line">            if (nums[i] &lt; nums[i-1]) &#123;</span><br><span class="line">                res_idx &#x3D; i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        return nums[res_idx];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>二分查找的简单实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findMin(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int left &#x3D; 0, right &#x3D; nums.size() - 1;</span><br><span class="line">        while (nums[left] &gt; nums[right]) &#123;</span><br><span class="line">            int mid &#x3D; (right + left) &gt;&gt; 1;</span><br><span class="line">            if (nums[mid] &gt;&#x3D; nums[left])</span><br><span class="line">                left &#x3D; mid + 1;</span><br><span class="line">            else</span><br><span class="line">                right &#x3D; mid;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用迭代器来实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findMin(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        auto begin &#x3D; nums.begin();</span><br><span class="line">        auto end &#x3D; std::prev(nums.end());</span><br><span class="line">        while (*begin &gt; *end) &#123;</span><br><span class="line">            auto gap &#x3D; (end - begin) &gt;&gt; 1;</span><br><span class="line">            *next(begin, gap) &gt;&#x3D; *begin ? advance(begin, gap + 1) : advance(end, -gap); </span><br><span class="line">        &#125;</span><br><span class="line">        return *begin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>来源：<a href="https://github.com/xiaqunfeng/leetcode" target="_blank" rel="noopener">https://github.com/xiaqunfeng/leetcode</a></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>151. Reverse Words in a String</title>
    <url>/2020/04/07/LeetCode_Cpp/0151._Reverse_Words_in_a_String/</url>
    <content><![CDATA[<h1 id="151-Reverse-Words-in-a-String"><a href="#151-Reverse-Words-in-a-String" class="headerlink" title="151. Reverse Words in a String"></a>151. Reverse Words in a String</h1><p>难度:Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/reverse-words-in-a-string/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-words-in-a-string/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given an input string, reverse the string word by word.</span><br><span class="line"></span><br><span class="line">Example:  </span><br><span class="line"></span><br><span class="line">Input: &quot;the sky is blue&quot;,</span><br><span class="line">Output: &quot;blue is sky the&quot;.</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">A word is defined as a sequence of non-space characters.</span><br><span class="line">Input string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces.</span><br><span class="line">You need to reduce multiple spaces between two words to a single space in the reversed string.</span><br></pre></td></tr></table></figure>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(N)<strong>**</strong>- 空间复杂度: O(N)<strong>**</strong></p>
</blockquote>
<p>倒着比遍历数组，遇到空格就认为是一个单词，注意对于边界条件的判断，在开一个新的 string 储存刚刚的单词，最后赋值给 s。总的来说不难。但是还是有一点小陷阱的，单词之间的空格可以是多个的，字符串的开头和末尾也可以有多个空格。需要写个循环清除空格。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j = s.length();</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; s[i] == <span class="string">' '</span>)</span><br><span class="line">            i++;</span><br><span class="line">        j--;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= i &amp;&amp; s[j] == <span class="string">' '</span>)</span><br><span class="line">            j--;</span><br><span class="line">        j++;</span><br><span class="line">        <span class="built_in">string</span> s1;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = j - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(temp &gt;= <span class="number">0</span> &amp;&amp; s[temp] != <span class="string">' '</span>)</span><br><span class="line">                temp--;</span><br><span class="line">            <span class="keyword">int</span> t = temp;</span><br><span class="line">            temp++;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; temp)</span><br><span class="line">                s1.push_back(s[temp++]);</span><br><span class="line">            j = t - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= i &amp;&amp; s[j] == <span class="string">' '</span>)</span><br><span class="line">                j--;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= i)</span><br><span class="line">                s1.push_back(<span class="string">' '</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        s = s1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>148.Sort list</title>
    <url>/2020/04/07/LeetCode_Cpp/0148._Sort%20_list/</url>
    <content><![CDATA[<h1 id="148-Sort-list"><a href="#148-Sort-list" class="headerlink" title="148.Sort list"></a>148.Sort list</h1><p>难度:Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/sort-list/" target="_blank" rel="noopener">https://leetcode.com/problems/sort-list/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sort a linked list in O(n log n) time using constant space complexity.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 4-&gt;2-&gt;1-&gt;3</span><br><span class="line">Output: 1-&gt;2-&gt;3-&gt;4</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: -1-&gt;5-&gt;3-&gt;4-&gt;0</span><br><span class="line">Output: -1-&gt;0-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(nlgn)<strong>**</strong>- 空间复杂度: O(n)<strong>**</strong></p>
</blockquote>
<p>这个思路头偷了个懒，用来c++中的 sort() 算法。现将链表中的 val 依次储存在数组中，并对数组进行排序。接着再把数组中的数存回链表中即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        ListNode* current = head;</span><br><span class="line">        <span class="keyword">while</span>(current)</span><br><span class="line">        &#123;</span><br><span class="line">            v.push_back(current -&gt;val);</span><br><span class="line">            current = current -&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(v.begin(),v.end());</span><br><span class="line">        current = head;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(current)</span><br><span class="line">        &#123;</span><br><span class="line">            current -&gt;val = v[i++];</span><br><span class="line">            current = current -&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>154. Find Minimum in Rotated Sorted Array II</title>
    <url>/2020/04/07/LeetCode_Cpp/0154._Find_Minimum_in_Rotated_Sorted_Array-II/</url>
    <content><![CDATA[<h2 id="154-Find-Minimum-in-Rotated-Sorted-Array-II"><a href="#154-Find-Minimum-in-Rotated-Sorted-Array-II" class="headerlink" title="154. Find Minimum in Rotated Sorted Array II"></a>154. Find Minimum in Rotated Sorted Array II</h2><p>难度：Hard</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><p>题目链接：<a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/description/" target="_blank" rel="noopener">https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/description/</a></p>
<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e.,  <code>[0,1,2,4,5,6,7]</code> might become  <code>[4,5,6,7,0,1,2]</code>).</p>
<p>Find the minimum element.</p>
<p>The array may contain duplicates.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,3,5]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,2,2,0,1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li>This is a follow up problem to <a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/" target="_blank" rel="noopener">Find Minimum in Rotated Sorted Array</a>.</li>
<li>Would allow duplicates affect the run-time complexity? How and why?</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>这题竟然是hard，好尴尬。最简单时间复杂度为O(n)的方法，我把前一题的代码一行不动的挪过来，Accepted。<br>二分查找法，时间复杂度为O(log(n))。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>O(n)，和前一题代码一样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findMin(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int res_idx &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 1; i &lt; nums.size(); ++i)</span><br><span class="line">            if (nums[i] &lt; nums[i-1]) &#123;</span><br><span class="line">                res_idx &#x3D; i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        return nums[res_idx];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>二分法实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findMin(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int left &#x3D; 0, right &#x3D; nums.size() - 1;</span><br><span class="line"></span><br><span class="line">        while (left &lt; right &amp;&amp; nums[left] &gt;&#x3D; nums[right]) &#123;</span><br><span class="line">            int mid &#x3D; left + (right - left) &#x2F; 2;</span><br><span class="line">            if (nums[mid] &#x3D;&#x3D; nums[left]) &#123;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125; else if (nums[mid] &lt; nums[left]) &#123;</span><br><span class="line">                right &#x3D; mid;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                left &#x3D; mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>迭代器二分查找的实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findMin(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        auto left &#x3D; nums.begin();</span><br><span class="line">        auto right &#x3D; std::prev(nums.end());</span><br><span class="line">        while (*left &gt;&#x3D; *right &amp;&amp; left &lt; right) &#123;</span><br><span class="line">            auto gap &#x3D; (right - left) &gt;&gt; 1;</span><br><span class="line">            if (*next(left, gap) &#x3D;&#x3D; *left)</span><br><span class="line">                advance(left, 1);</span><br><span class="line">            else if (*next(left, gap) &lt; *left)</span><br><span class="line">                advance(right, -gap);</span><br><span class="line">            else</span><br><span class="line">                advance(left, gap + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return *left;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>来源：<a href="https://github.com/xiaqunfeng/leetcode" target="_blank" rel="noopener">https://github.com/xiaqunfeng/leetcode</a></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>164. Maximum Gap</title>
    <url>/2020/04/07/LeetCode_Cpp/0164._Maximum_Gap/</url>
    <content><![CDATA[<h1 id="164-Maximum-GaP"><a href="#164-Maximum-GaP" class="headerlink" title="164. Maximum GaP"></a>164. Maximum GaP</h1><p>难度:Hard</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/maximum-gap/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-gap/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given an unsorted array, find the maximum difference between the successive elements in its sorted form.</span><br><span class="line"></span><br><span class="line">Return 0 if the array contains less than 2 elements.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [3,6,9,1]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The sorted form of the array is [1,3,6,9], either</span><br><span class="line">             (3,6) or (6,9) has the maximum difference 3.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [10]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The array contains less than 2 elements, therefore return 0.</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.</span><br><span class="line">Try to solve it in linear time&#x2F;space.</span><br></pre></td></tr></table></figure>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><blockquote>
<p>思路1<br><strong>**</strong>- 时间复杂度: O(NlgN)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>用普通的方法的去做其实不难，先对数组进行排序，再遍历数组，依次计算 nums[i] - nums[i - 1] 求出最大值即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.size();++i)</span><br><span class="line">            ans = max(ans,nums[i] - nums[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路2<br><strong>**</strong>- 时间复杂度: O(N)<strong>**</strong>- 空间复杂度: O(N)<strong>**</strong></p>
</blockquote>
<p>但是题目中的note已经提示了在线性的时间和空间复杂度完成。由于这题内的数字的大小都是在32bits以内的，那么我们可以用桶排序或者基数排序，具体的算法和复杂度的推导可以参考《算法导论》。这里我们采用了基数排序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res[nums.size()];</span><br><span class="line">        <span class="keyword">int</span> t[nums.size()][<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            res[i] = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">10</span>;++j)</span><br><span class="line">                t[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i],j = <span class="number">9</span>;</span><br><span class="line">            <span class="keyword">while</span>(temp)</span><br><span class="line">            &#123;</span><br><span class="line">                t[i][j--] = temp % <span class="number">10</span>;</span><br><span class="line">                temp /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">9</span>;i &gt;= <span class="number">0</span>;--i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> bucket[nums.size()],count1[<span class="number">10</span>];</span><br><span class="line">            <span class="built_in">memset</span>(count1,<span class="number">0</span>,<span class="keyword">sizeof</span>(count1));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; nums.size();++j)</span><br><span class="line">                count1[t[res[j]][i]]++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; <span class="number">10</span>;++j)</span><br><span class="line">                count1[j] += count1[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = nums.size() - <span class="number">1</span>;j &gt;= <span class="number">0</span>;--j)</span><br><span class="line">                bucket[--count1[t[res[j]][i]]] = res[j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; nums.size();++j)</span><br><span class="line">                res[j] = bucket[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.size();++i)</span><br><span class="line">            ans = max(ans,nums[res[i]] - nums[res[i - <span class="number">1</span>]]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>160 intersection_of_Two_Linked_Lists</title>
    <url>/2020/04/07/LeetCode_Cpp/0160._intersection_of_two_linked_lists/</url>
    <content><![CDATA[<h1 id="160-intersection-of-Two-Linked-Lists"><a href="#160-intersection-of-Two-Linked-Lists" class="headerlink" title="160 intersection_of_Two_Linked_Lists"></a>160 intersection_of_Two_Linked_Lists</h1><p> 难度: Easy</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a><blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Write a program to find the node at which the intersection of two singly linked lists begins.</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.  求长度差</span><br><span class="line">2.  长的链表先走掉长的部分</span><br><span class="line">3.  一起走，相遇即为交点</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lena=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lenb=<span class="number">0</span>;</span><br><span class="line">    ListNode *a = headA;</span><br><span class="line">    ListNode *b = headB;</span><br><span class="line">    <span class="keyword">while</span>(a)&#123;</span><br><span class="line">        lena++;</span><br><span class="line">        a=a-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        lenb++;</span><br><span class="line">        b=b-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a!=b)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> sub=<span class="built_in">abs</span>(lena-lenb);</span><br><span class="line">    <span class="keyword">if</span>(lena&gt;lenb)&#123;</span><br><span class="line">        <span class="keyword">while</span>(sub--)</span><br><span class="line">            headA=headA-&gt;next;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">        <span class="keyword">while</span>(sub--)</span><br><span class="line">            headB=headB-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(headA!=headB)&#123;</span><br><span class="line">        headA = headA-&gt;next;</span><br><span class="line">        headB = headB-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> headA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>167. Two Sum II - Input array is sorted</title>
    <url>/2020/04/07/LeetCode_Cpp/0167._Two_Sum_II-Input_array_is_sorted/</url>
    <content><![CDATA[<h2 id="167-Two-Sum-II-Input-array-is-sorted"><a href="#167-Two-Sum-II-Input-array-is-sorted" class="headerlink" title="167. Two Sum II - Input array is sorted"></a>167. Two Sum II - Input array is sorted</h2><p>难度：Easy</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><p>原题链接：<a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/" target="_blank" rel="noopener">https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/</a></p>
<p>Given an array of integers that is already <strong>sorted in ascending order</strong>, find two numbers such that they add up to a specific target number.</p>
<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.</p>
<p><strong>Note:</strong></p>
<ul>
<li>Your returned answers (both index1 and index2) are not zero-based.</li>
<li>You may assume that each input would have <em>exactly</em> one solution and you may not use the <em>same</em> element twice.</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: numbers &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">Output: [1,2]</span><br><span class="line">Explanation: The sum of 2 and 7 is 9. Therefore index1 &#x3D; 1, index2 &#x3D; 2.</span><br></pre></td></tr></table></figure>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>关键点：</p>
<ul>
<li>升序排列</li>
<li>一定有解</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;</span><br><span class="line">        int left &#x3D; 0, right &#x3D; numbers.size() - 1;</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            int sum &#x3D; numbers[left] + numbers[right];</span><br><span class="line">            if (sum &lt; target) </span><br><span class="line">                left++;</span><br><span class="line">            else if (sum &gt; target) </span><br><span class="line">                right--;</span><br><span class="line">            else </span><br><span class="line">                return &#123;left + 1, right + 1&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;0, 0&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>166. Fraction to Recurring Decimal</title>
    <url>/2020/04/07/LeetCode_Cpp/0166._Fraction_to_Recurring_Decimal/</url>
    <content><![CDATA[<h1 id="166-Fraction-to-Recurring-Decimal"><a href="#166-Fraction-to-Recurring-Decimal" class="headerlink" title="166. Fraction to Recurring Decimal"></a>166. Fraction to Recurring Decimal</h1><p><strong><font color=red>难度:Medium<font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/fraction-to-recurring-decimal/" target="_blank" rel="noopener">https://leetcode.com/problems/fraction-to-recurring-decimal/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.</span><br><span class="line"></span><br><span class="line">If the fractional part is repeating, enclose the repeating part in parentheses.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: numerator &#x3D; 1, denominator &#x3D; 2</span><br><span class="line">Output: &quot;0.5&quot;</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: numerator &#x3D; 2, denominator &#x3D; 1</span><br><span class="line">Output: &quot;2&quot;</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: numerator &#x3D; 2, denominator &#x3D; 3</span><br><span class="line">Output: &quot;0.(6)&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(nlgn)<strong>**</strong>- 空间复杂度: O(n)<strong>**</strong></p>
</blockquote>
<p>对于这道题考虑的点比较多，首先我们用map储存每次的余数，以及得到的答案在字符串中的位置，只要余数在map中出现过了，则表示接下来开始循环。要注意得到的答案有可能是负数，因此要注意添加负号。应为int的最小值乘上-1大于int的最大值，所以用long long储存除数和被除数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">join_str</span><span class="params">(<span class="built_in">string</span>&amp; str,<span class="keyword">long</span> <span class="keyword">long</span> num,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!num)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(t &lt; <span class="number">0</span>)</span><br><span class="line">                str.push_back(<span class="string">'-'</span>);</span><br><span class="line">            str.push_back(<span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(num)</span><br><span class="line">        &#123;</span><br><span class="line">            str.push_back(num % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t &lt; <span class="number">0</span>)</span><br><span class="line">            str.push_back(<span class="string">'-'</span>);</span><br><span class="line">        reverse(str.begin(),str.end());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">fractionToDecimal</span><span class="params">(<span class="keyword">int</span> numerator, <span class="keyword">int</span> denominator)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">if</span>(!numerator)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> n1 = numerator,d1 = denominator;</span><br><span class="line">        <span class="keyword">if</span>(numerator &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t *= <span class="number">-1</span>;</span><br><span class="line">            n1 *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(denominator &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t *= <span class="number">-1</span>;</span><br><span class="line">            d1 *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> num = n1 / d1;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        join_str(ans,num,t);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> quotient = n1 % d1;</span><br><span class="line">        <span class="keyword">if</span>(quotient)</span><br><span class="line">            ans.push_back(<span class="string">'.'</span>);</span><br><span class="line">        <span class="built_in">string</span> temp;</span><br><span class="line">        <span class="keyword">int</span> count1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(quotient)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> new_num = quotient * <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(m[new_num])</span><br><span class="line">            &#123;</span><br><span class="line">                temp.push_back(<span class="string">')'</span>);</span><br><span class="line">                count1 = m[new_num];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            m[new_num] = temp.length() + <span class="number">1</span>;</span><br><span class="line">            temp.push_back(new_num / d1 + <span class="string">'0'</span>);</span><br><span class="line">            quotient = new_num % d1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count1)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.append(temp.begin(),temp.begin() + count1 - <span class="number">1</span>);</span><br><span class="line">            ans.push_back(<span class="string">'('</span>);</span><br><span class="line">            ans.append(temp.begin() + count1 - <span class="number">1</span>,temp.end());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ans.append(temp.begin(),temp.end());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>199. Binary Tree Right Side View</title>
    <url>/2020/04/07/LeetCode_Cpp/0199._Binary_Tree_Right_Side_View/</url>
    <content><![CDATA[<h1 id="199-Binary-Tree-Right-Side-View"><a href="#199-Binary-Tree-Right-Side-View" class="headerlink" title="199. Binary Tree Right Side View"></a>199. Binary Tree Right Side View</h1><p> 难度: Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-right-side-view/</a></p>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [1,2,3,null,5,null,4]</span><br><span class="line">输出: [1, 3, 4]</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">   1            &lt;---</span><br><span class="line"> &#x2F;   \</span><br><span class="line">2     3         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  5     4       &lt;---</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">二叉树层次遍历</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="built_in">stack</span>;</span><br><span class="line">    <span class="built_in">stack</span>.push_back(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">stack</span>.empty())&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; tmp;</span><br><span class="line">        TreeNode* node;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">stack</span>.size();i++)&#123;</span><br><span class="line">            node = <span class="built_in">stack</span>[i];</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left)</span><br><span class="line">                tmp.push_back(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right)</span><br><span class="line">                tmp.push_back(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.push_back(node-&gt;val);</span><br><span class="line">        <span class="built_in">stack</span> = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>230. Kth Smallest Element in a BST</title>
    <url>/2020/04/07/LeetCode_Cpp/0230._Kth_Smallest_Element_in_a_BST/</url>
    <content><![CDATA[<h1 id="230-Kth-Smallest-Element-in-a-BST"><a href="#230-Kth-Smallest-Element-in-a-BST" class="headerlink" title="230. Kth Smallest Element in a BST"></a>230. Kth Smallest Element in a BST</h1><p> <strong><font color=red>难度: Middle</font></strong></p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/</a></p>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class="line">   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">输出: 1</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span><br><span class="line">       5</span><br><span class="line">      &#x2F; \</span><br><span class="line">     3   6</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   4</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">输出: 3</span><br><span class="line">进阶：</span><br><span class="line">如果二叉搜索树经常被修改（插入&#x2F;删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 kthSmallest 函数？</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">遍历树后排序</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">​&#96;&#96;&#96;cpp</span><br><span class="line">void dfs(TreeNode* root, vector&lt;int&gt;&amp; nums)&#123;</span><br><span class="line">    if(root&#x3D;&#x3D;NULL)</span><br><span class="line">        return ;</span><br><span class="line">    nums.push_back(root-&gt;val);</span><br><span class="line">    dfs(root-&gt;left, nums);</span><br><span class="line">    dfs(root-&gt;right, nums);</span><br><span class="line">&#125;</span><br><span class="line">int kthSmallest(TreeNode* root, int k) &#123;</span><br><span class="line">    vector&lt;int&gt; nums;</span><br><span class="line">    dfs(root, nums);</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    return  nums[k-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>216. Combination Sum III</title>
    <url>/2020/04/07/LeetCode_Cpp/0216._Combination_Sum_III/</url>
    <content><![CDATA[<h1 id="216-Combination-Sum-III"><a href="#216-Combination-Sum-III" class="headerlink" title="216. Combination Sum III"></a>216. Combination Sum III</h1><p> 难度: Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/combination-sum-iii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combination-sum-iii/</a></p>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">所有数字都是正整数。</span><br><span class="line">解集不能包含重复的组合。 </span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: k &#x3D; 3, n &#x3D; 7</span><br><span class="line">输出: [[1,2,4]]</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: k &#x3D; 3, n &#x3D; 9</span><br><span class="line">输出: [[1,2,6], [1,3,5], [2,3,4]]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">回溯</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> index, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>||k&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>&amp;&amp;k==<span class="number">0</span>)&#123;</span><br><span class="line">        ans.push_back(path);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">        path.push_back(i);</span><br><span class="line">        dfs(n-i, k<span class="number">-1</span>, i+<span class="number">1</span>, path, ans);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum3</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    dfs(n, k, <span class="number">1</span>, path, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>260. Single Number III</title>
    <url>/2020/04/07/LeetCode_Cpp/0260._Single_Number_III/</url>
    <content><![CDATA[<h1 id="260-Single-Number-III"><a href="#260-Single-Number-III" class="headerlink" title="260. Single Number III"></a>260. Single Number III</h1><p>难度:Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/single-number-iii/" target="_blank" rel="noopener">https://leetcode.com/problems/single-number-iii/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input:  [1,2,1,3,2,5]</span><br><span class="line">Output: [3,5]</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">The order of the result is not important. So in the above example, [5, 3] is also correct.</span><br><span class="line">Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?</span><br></pre></td></tr></table></figure>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><blockquote>
<p>思路1<br><strong>**</strong>- 时间复杂度: O(n)<strong>**</strong>- 空间复杂度: O(1)<strong>**</strong></p>
</blockquote>
<p>这题与之前的那题略有不同，这次有两个 single number，用之前的思维去做的话，在对数组进行依次异或运算之后得到的应该是两个 single number 异或值aXorb，接下来将aXorb转换成二进制，从第0位找起，第一个为1的位，则说明在这个位上a 和 b不相等，把数组中的数分成两部分，即在这个位上为0的一部分，为1的一部分，这样就把两个数分到了不同的两部分中。接着分别对这两部分异或就能得到结果</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> aXorB = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            aXorB ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> differingBit = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((differingBit &amp; aXorB) == <span class="number">0</span>) &#123;</span><br><span class="line">            differingBit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((num &amp; differingBit) == <span class="number">0</span>) &#123;</span><br><span class="line">                a ^= num;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                b ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>287. Find the Duplicate Number</title>
    <url>/2020/04/07/LeetCode_Cpp/0287._Find_the_Duplicate_Number/</url>
    <content><![CDATA[<h1 id="287-Find-the-Duplicate-Number"><a href="#287-Find-the-Duplicate-Number" class="headerlink" title="287. Find the Duplicate Number"></a>287. Find the Duplicate Number</h1><p> 难度: Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-the-duplicate-number/</a></p>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [1,3,4,2,2]</span><br><span class="line">输出: 2</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [3,1,3,4,2]</span><br><span class="line">输出: 3</span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">不能更改原数组（假设数组是只读的）。</span><br><span class="line">只能使用额外的 O(1) 的空间。</span><br><span class="line">时间复杂度小于 O(n2) 。</span><br><span class="line">数组中只有一个重复的数字，但它可能不止重复出现一次。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">采用下标取反标记，假设下标数字为负，则为ans</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="built_in">abs</span>(nums[i])<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[index]&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> index+<span class="number">1</span>;</span><br><span class="line">        nums[index] = - nums[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>326. Power_of_Three</title>
    <url>/2020/04/07/LeetCode_Cpp/0326._power_of_three/</url>
    <content><![CDATA[<h1 id="326-Power-of-Three"><a href="#326-Power-of-Three" class="headerlink" title="326. Power_of_Three"></a>326. Power_of_Three</h1><p>难度: Easy</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode-cn.com/problems/power-of-three/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/power-of-three/</a><blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given an integer, write a function to determine if it is a power of three.</span><br><span class="line"></span><br><span class="line">###example </span><br><span class="line">1. Input: 27  -&gt; Output: true</span><br><span class="line"></span><br><span class="line">2. Input: 0 -&gt; Output: false</span><br><span class="line"></span><br><span class="line">3. Input: 9 -&gt; Output: true</span><br><span class="line"></span><br><span class="line">4. Input: 45 -&gt; Output: false</span><br></pre></td></tr></table></figure>
<h2 id="题解方案"><a href="#题解方案" class="headerlink" title="题解方案"></a>题解方案</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">只要是3的幂次，一定能够被3的最大次方整除</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="number">1162261467</span> % n ==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>328. Odd Even Linked List</title>
    <url>/2020/04/07/LeetCode_Cpp/0328._Odd_Even_Linked_List/</url>
    <content><![CDATA[<h1 id="328-Odd-Even-Linked-List"><a href="#328-Odd-Even-Linked-List" class="headerlink" title="328. Odd Even Linked List"></a>328. Odd Even Linked List</h1><p> 难度: Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/odd-even-linked-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/odd-even-linked-list/</a></p>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</span><br><span class="line"></span><br><span class="line">请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL </span><br><span class="line">输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如题</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span> || head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode* link = head-&gt;next;</span><br><span class="line">    ListNode* slow=head;</span><br><span class="line">    ListNode* fast=head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(fast&amp;&amp;fast-&gt;next)&#123;</span><br><span class="line">        slow-&gt;next = fast-&gt;next;</span><br><span class="line">        fast-&gt;next = fast-&gt;next-&gt;next;</span><br><span class="line">        slow=slow-&gt;next;</span><br><span class="line">        fast=fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;slow-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    slow-&gt;next = link;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>329. Longest Increasing Path in a Matrix</title>
    <url>/2020/04/07/LeetCode_Cpp/0329._Longest_Increasing_Path_in_a_Matrix/</url>
    <content><![CDATA[<h1 id="329-Longest-Increasing-Path-in-a-Matrix"><a href="#329-Longest-Increasing-Path-in-a-Matrix" class="headerlink" title="329. Longest Increasing Path in a Matrix"></a>329. Longest Increasing Path in a Matrix</h1><p>难度:Hard</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/longest-increasing-path-in-a-matrix/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-increasing-path-in-a-matrix/</a></li>
</ul>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given an integer matrix, find the length of the longest increasing path.</span><br><span class="line"></span><br><span class="line">From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: nums &#x3D; </span><br><span class="line">[</span><br><span class="line">  [9,9,4],</span><br><span class="line">  [6,6,8],</span><br><span class="line">  [2,1,1]</span><br><span class="line">] </span><br><span class="line">Output: 4 </span><br><span class="line">Explanation: The longest increasing path is [1, 2, 6, 9].</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: nums &#x3D; </span><br><span class="line">[</span><br><span class="line">  [3,4,5],</span><br><span class="line">  [3,2,6],</span><br><span class="line">  [2,2,1]</span><br><span class="line">] </span><br><span class="line">Output: 4 </span><br><span class="line">Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.</span><br></pre></td></tr></table></figure>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><blockquote>
<p>思路<br><strong>**</strong>- 时间复杂度: O(n * m)<strong>**</strong>-空间复杂度: O(n * m)<strong>**</strong></p>
</blockquote>
<p>如果直接用DFS去做，时间复杂度为O(n^4)，我们就需要对算法进行优化，定义一个二维数组用记忆化的方法去记录进行剪枝</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span>** dp;</span><br><span class="line">    <span class="keyword">int</span> len1,len2,ans;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp;matrix,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i][j] != <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> dp[i][j];</span><br><span class="line">        <span class="comment">//cout &lt;&lt; i &lt;&lt; j &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span>(i &amp;&amp; matrix[i][j] &lt; matrix[i - <span class="number">1</span>][j])</span><br><span class="line">            dp[i][j] = max(dp[i][j],dfs(matrix,i - <span class="number">1</span>,j) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(j &lt; len2 - <span class="number">1</span> &amp;&amp; matrix[i][j] &lt; matrix[i][j + <span class="number">1</span>])</span><br><span class="line">            dp[i][j] = max(dp[i][j],dfs(matrix,i,j + <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; len1 - <span class="number">1</span> &amp;&amp; matrix[i][j] &lt; matrix[i + <span class="number">1</span>][j])</span><br><span class="line">            dp[i][j] = max(dp[i][j],dfs(matrix,i + <span class="number">1</span>,j) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(j &amp;&amp; matrix[i][j] &lt; matrix[i][j - <span class="number">1</span>])</span><br><span class="line">            dp[i][j] = max(dp[i][j],dfs(matrix,i,j - <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//cout &lt;&lt; dp[i][j];</span></span><br><span class="line">        <span class="keyword">if</span>(dp[i][j] == <span class="number">-1</span>)</span><br><span class="line">            dp[i][j] = <span class="number">1</span>;</span><br><span class="line">        ans = max(ans,dp[i][j]);</span><br><span class="line">        <span class="keyword">return</span> dp[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        len1 = matrix.size();</span><br><span class="line">        <span class="keyword">if</span>(!len1)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        len2 = matrix[<span class="number">0</span>].size();</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        dp = <span class="keyword">new</span> <span class="keyword">int</span>*[len1];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; ++i)&#123;</span><br><span class="line">            dp[i] = <span class="keyword">new</span> <span class="keyword">int</span>[len2];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len2;j++)</span><br><span class="line">                dp[i][j]= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; 1;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; matrix.size();++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; matrix[i].size();++j)</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//cout &lt;&lt; 1;</span></span><br><span class="line">                    dfs(matrix,i,j);</span><br><span class="line">                &#125;</span><br><span class="line">        reverse(matrix.begin(),matrix.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; matrix.size();++i)</span><br><span class="line">            reverse(matrix[i].begin(),matrix[i].end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len1;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; len2;++j)</span><br><span class="line">                dp[i][j] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; matrix.size();++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; matrix[i].size();++j)</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] == <span class="number">-1</span>)</span><br><span class="line">                    dfs(matrix,i,j);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>338. Counting Bits</title>
    <url>/2020/04/07/LeetCode_Cpp/0338._counting_bits/</url>
    <content><![CDATA[<h1 id="338-Counting-Bits"><a href="#338-Counting-Bits" class="headerlink" title="338. Counting Bits"></a>338. Counting Bits</h1><p> 难度: Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode-cn.com/problems/counting-bits/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/counting-bits/</a><blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 2</span><br><span class="line">输出: [0,1,1]</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: 5</span><br><span class="line">输出: [0,1,1,2,1,2]</span><br><span class="line">进阶:</span><br><span class="line"></span><br><span class="line">给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？</span><br><span class="line">要求算法的空间复杂度为O(n)。</span><br><span class="line">你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第i个数的二进制中数含1的个数等于等于第（i&amp;i-1）个数中二进制数中1的个数加1</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(num+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++)&#123;</span><br><span class="line">        res[i]=res[i&amp;(i<span class="number">-1</span>)]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>413. Arithmetic Slices</title>
    <url>/2020/04/07/LeetCode_Cpp/0413._Arithmetic_Slices/</url>
    <content><![CDATA[<h1 id="413-Arithmetic-Slices"><a href="#413-Arithmetic-Slices" class="headerlink" title="413. Arithmetic Slices"></a>413. Arithmetic Slices</h1><p> 难度: Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/arithmetic-slices/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/arithmetic-slices/</a></p>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。</span><br><span class="line"></span><br><span class="line">例如，以下数列为等差数列:</span><br><span class="line"></span><br><span class="line">1, 3, 5, 7, 9</span><br><span class="line">7, 7, 7, 7</span><br><span class="line">3, -1, -5, -9</span><br><span class="line">以下数列不是等差数列。</span><br><span class="line"></span><br><span class="line">1, 1, 2, 5, 7</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0&lt;&#x3D;P&lt;Q&lt;N 。</span><br><span class="line"></span><br><span class="line">如果满足以下条件，则称子数组(P, Q)为等差数组：</span><br><span class="line"></span><br><span class="line">元素 A[P], A[p + 1], ..., A[Q - 1], A[Q] 是等差的。并且 P + 1 &lt; Q 。</span><br><span class="line"></span><br><span class="line">函数要返回数组 A 中所有为等差数组的子数组个数。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">A &#x3D; [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i]记录以i开头任意结尾的等差数列的个数</span><br><span class="line">如果A[i+1]-A[i]&#x3D;&#x3D;A[i]-A[i-1],那么A[i+1]，则dp[i+1]&#x3D;dp[i]+1</span><br><span class="line">最后所有位置开头的等差数列的和为结果。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(A.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;A.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i]-A[i<span class="number">-1</span>]==A[i<span class="number">-1</span>]-A[i<span class="number">-2</span>])&#123;</span><br><span class="line">            dp[i]=dp[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dp.size();i++)&#123;</span><br><span class="line">        ans+=dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>515. Find Largest Value in Each Tree Row</title>
    <url>/2020/04/07/LeetCode_Cpp/0515._Find_Largest_Value_in_Each_Tree_Row/</url>
    <content><![CDATA[<h1 id="515-Find-Largest-Value-in-Each-Tree-Row"><a href="#515-Find-Largest-Value-in-Each-Tree-Row" class="headerlink" title="515. Find Largest Value in Each Tree Row"></a>515. Find Largest Value in Each Tree Row</h1><p> 难度: Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/</a></p>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">您需要在二叉树的每一行中找到最大的值。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入: </span><br><span class="line"></span><br><span class="line">          1</span><br><span class="line">         &#x2F; \</span><br><span class="line">        3   2</span><br><span class="line">       &#x2F; \   \  </span><br><span class="line">      5   3   9 </span><br><span class="line"></span><br><span class="line">输出: [1, 3, 9]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">层次遍历二叉树</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">largestValues</span><span class="params">(TreeNode* root)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; level;</span><br><span class="line">    level.push_back(root);</span><br><span class="line">    <span class="keyword">while</span>(level.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; tmp;</span><br><span class="line">        <span class="keyword">int</span> n = level.size();</span><br><span class="line">        <span class="keyword">int</span> maxnum = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(maxnum&lt;level[i]-&gt;val)</span><br><span class="line">                maxnum=level[i]-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(level[i]-&gt;left)</span><br><span class="line">                tmp.push_back(level[i]-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(level[i]-&gt;right)</span><br><span class="line">                tmp.push_back(level[i]-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.push_back(maxnum);</span><br><span class="line">        level=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>442. Find All Duplicates in an Array</title>
    <url>/2020/04/07/LeetCode_Cpp/0442._Find_All_Duplicates_in_an_Array/</url>
    <content><![CDATA[<h1 id="442-Find-All-Duplicates-in-an-Array"><a href="#442-Find-All-Duplicates-in-an-Array" class="headerlink" title="442. Find All Duplicates in an Array"></a>442. Find All Duplicates in an Array</h1><p> 难度: Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/</a></p>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。</span><br><span class="line"></span><br><span class="line">找到所有出现两次的元素。</span><br><span class="line"></span><br><span class="line">你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[2,3]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数值在1-n之间，可以对相应数值-1的下标位置取反，如果出现两次，就为正值，否则为负。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="built_in">abs</span>(nums[i])<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[index]&lt;<span class="number">0</span>)</span><br><span class="line">            ans.push_back(index+<span class="number">1</span>);</span><br><span class="line">        nums[index] = - nums[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>540. Single Element in a Sorted Array</title>
    <url>/2020/04/07/LeetCode_Cpp/0540._Single_Element_in_a_Sorted_Array/</url>
    <content><![CDATA[<h1 id="540-Single-Element-in-a-Sorted-Array"><a href="#540-Single-Element-in-a-Sorted-Array" class="headerlink" title="540. Single Element in a Sorted Array"></a>540. Single Element in a Sorted Array</h1><p> 难度: Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/single-element-in-a-sorted-array/</a></p>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [1,1,2,3,3,4,4,8,8]</span><br><span class="line">输出: 2</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [3,3,7,7,10,11,11]</span><br><span class="line">输出: 10</span><br><span class="line">注意: 您的方案应该在 O(log n)时间复杂度和 O(1)空间复杂度中运行。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">时间复杂度选择二分</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">0</span>, end=nums.size()/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (end+start)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid*<span class="number">2</span>]!=nums[mid*<span class="number">2</span>+<span class="number">1</span>])&#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            start = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">2</span>*start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>513. Find Bottom Left Tree Value</title>
    <url>/2020/04/07/LeetCode_Cpp/0513._Find_Bottom_Left_Tree_Value/</url>
    <content><![CDATA[<h1 id="513-Find-Bottom-Left-Tree-Value"><a href="#513-Find-Bottom-Left-Tree-Value" class="headerlink" title="513. Find Bottom Left Tree Value"></a>513. Find Bottom Left Tree Value</h1><p> 难度: Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-bottom-left-tree-value/</a></p>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个二叉树，在树的最后一行找到最左边的值。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line"></span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">1</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line"></span><br><span class="line">        1</span><br><span class="line">       &#x2F; \</span><br><span class="line">      2   3</span><br><span class="line">     &#x2F;   &#x2F; \</span><br><span class="line">    4   5   6</span><br><span class="line">       &#x2F;</span><br><span class="line">      7</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">7</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">注意: 您可以假设树（即给定的根节点）不为 NULL。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">从左到右层次遍历二叉树</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; que;</span><br><span class="line">    que.push_back(root);</span><br><span class="line">    <span class="keyword">while</span>(que.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; tmp;</span><br><span class="line">        <span class="keyword">int</span> len = que.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(que[i]-&gt;left)</span><br><span class="line">                tmp.push_back(que[i]-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(que[i]-&gt;right)</span><br><span class="line">                tmp.push_back(que[i]-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        que = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> que[<span class="number">0</span>]-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>581. Shortest Unsorted Continuous Subarray</title>
    <url>/2020/04/07/LeetCode_Cpp/0581._shortest_unsorted_continuous_subarray/</url>
    <content><![CDATA[<h1 id="581-Shortest-Unsorted-Continuous-Subarray"><a href="#581-Shortest-Unsorted-Continuous-Subarray" class="headerlink" title="581. Shortest Unsorted Continuous Subarray"></a>581. Shortest Unsorted Continuous Subarray</h1><p> 难度: Easy</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/</a><blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</span><br><span class="line"></span><br><span class="line">你找到的子数组应是最短的，请输出它的长度。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [2, 6, 4, 8, 10, 9, 15]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 拷贝数组，排序</span><br><span class="line">2. 计算两个数组不同的起始位置和末端位置</span><br><span class="line">3. 计算差值</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(nums.begin(), nums.end())</span></span>;</span><br><span class="line">    sort(tmp.begin(), tmp.end());</span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">-1</span>, end=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp[i]!=nums[i])&#123;</span><br><span class="line">            start = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp[i]!=nums[i])&#123;</span><br><span class="line">            end = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(start==<span class="number">-1</span>&amp;&amp;end==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> end-start+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>632. Smallest Range</title>
    <url>/2020/04/07/LeetCode_Cpp/0632._Smallest_Range/</url>
    <content><![CDATA[<h1 id="632-Smallest-Range"><a href="#632-Smallest-Range" class="headerlink" title="632. Smallest Range"></a>632. Smallest Range</h1><p>难度:Hard</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><p>题目:<br><a href="https://leetcode.com/problems/smallest-range/" target="_blank" rel="noopener">https://leetcode.com/problems/smallest-range/</a></p>
<p>题意：</p>
<ol>
<li>给定n个序列，求一个最小区间，使得每个序列至少一个数在这个区间里面</li>
</ol>
<p>思路：</p>
<ul>
<li>采用移动区间的做法。如果区间左端点为l，那么我们需要在所有的序列中寻找比l大的最小数，构成一个区间[l, r]</li>
<li>首先，将所有序列的第一个数字入堆，我们记录一个最大值。这时候堆里面的数形成一个区间，判断和记录下来。接着区间开始移动，将堆里面的最小数弹出丢掉，再从这个最小数所在的序列取出下一个数放进堆，又形成一个区间，判断和记录下来。如此循环，直到其中一个序列没有数可以进堆</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myData</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> x, y, value;</span><br><span class="line">        myData(<span class="keyword">int</span> _x = <span class="number">0</span>, <span class="keyword">int</span> _y = <span class="number">0</span>, <span class="keyword">int</span> _value = <span class="number">0</span>): x(_x), y(_y), value(_value) &#123;&#125;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> myData &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value &gt; b.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">smallestRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">-10000000</span>, r = <span class="number">-10000000</span>;</span><br><span class="line">        priority_queue&lt;myData&gt; q;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">-10000000</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            q.push(myData(i, <span class="number">0</span>, nums[i][<span class="number">0</span>]));</span><br><span class="line">            res = res &gt; nums[i][<span class="number">0</span>] ? res : nums[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;            </span><br><span class="line">            myData t = q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (l == <span class="number">-10000000</span> || (res - t.value) &lt; (r - l)) &#123;</span><br><span class="line">                l = t.value;</span><br><span class="line">                r = res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (t.y + <span class="number">1</span> &lt; nums[t.x].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                q.push(myData(t.x, t.y + <span class="number">1</span>, nums[t.x][t.y + <span class="number">1</span>]));</span><br><span class="line">                res = res &gt; nums[t.x][t.y + <span class="number">1</span>] ? res : nums[t.x][t.y + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        ret.push_back(l);</span><br><span class="line">        ret.push_back(r);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>793. K Inverse Pairs Array</title>
    <url>/2020/04/07/LeetCode_Cpp/0629._K_Inverse_Pairs_Array/</url>
    <content><![CDATA[<h1 id="793-K-Inverse-Pairs-Array"><a href="#793-K-Inverse-Pairs-Array" class="headerlink" title="793. K Inverse Pairs Array"></a>793. K Inverse Pairs Array</h1><p>难度:Hard</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><p>题目:<br><a href="https://leetcode.com/problems/k-inverse-pairs-array" target="_blank" rel="noopener">https://leetcode.com/problems/k-inverse-pairs-array</a></p>
<p>题意：</p>
<ol>
<li>给定一个数n和一个数k</li>
<li>求n个元素，逆序对数等于k的序列数</li>
</ol>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>思路：</p>
<ul>
<li>最容易想到的是动态规划</li>
<li>我们一个数一个数丢进去，假设已经存在n-1个元素的序列，我们要放一个比他们都小的数，这时候根据插入的位置不同就会产生0到(n-1)的逆序对数</li>
<li>设<code>dp[n][k]</code>表示n个元素，逆序对数等于k的序列数，有状态转移方程<code>dp[n][k]=sum{dp[n-1][k - (0..(n-1))]}</code></li>
<li>如果直接求的话，复杂度是o(n^3)</li>
<li>注意观察算<code>dp[n][k]</code>，用到的是<code>dp[n-1][k]</code>到<code>dp[n-1][k-(n-1)]</code>，算<code>dp[n][k-1]</code>，用到的是<code>dp[n-1][k-1]</code>到<code>dp[n-1][k-1-(n-1)]</code>，于是我们可以保存这个和，然后算<code>dp[n][i]</code>的时候只需要加一个数减一个数就可以维护这个和</li>
<li>复杂度是o(n^2)</li>
</ul>
<p>解法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line">    <span class="keyword">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kInversePairs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= k;j++) &#123;</span><br><span class="line">                s += a[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (s &gt;= MOD) &#123;</span><br><span class="line">                    s -= MOD;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j - i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    s -= a[i - <span class="number">1</span>][j - i];</span><br><span class="line">                    <span class="keyword">if</span> (s &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        s += MOD;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                a[i][j] = s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a[n][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>654. Maximum Binary Tree</title>
    <url>/2020/04/07/LeetCode_Cpp/0654._maximum_binary_tree/</url>
    <content><![CDATA[<h1 id="654-Maximum-Binary-Tree"><a href="#654-Maximum-Binary-Tree" class="headerlink" title="654. Maximum Binary Tree"></a>654. Maximum Binary Tree</h1><p> 难度: Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode-cn.com/problems/maximum-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-binary-tree/</a><blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</span><br><span class="line"></span><br><span class="line">二叉树的根是数组中的最大元素。</span><br><span class="line">左子树是通过数组中最大值左边部分构造出的最大二叉树。</span><br><span class="line">右子树是通过数组中最大值右边部分构造出的最大二叉树。</span><br><span class="line">通过给定的数组构建最大二叉树，并且输出这个树的根节点。</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">输入: [3,2,1,6,0,5]</span><br><span class="line">输入: 返回下面这棵树的根节点：</span><br><span class="line"></span><br><span class="line">      6</span><br><span class="line">    &#x2F;   \</span><br><span class="line">   3     5</span><br><span class="line">    \    &#x2F; </span><br><span class="line">     2  0   </span><br><span class="line">       \</span><br><span class="line">        1</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">深搜构建二叉树</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root_val = <span class="number">0</span>, max=INT_MIN;</span><br><span class="line">    <span class="keyword">if</span>(start==end)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;end;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(max&lt;nums[i])&#123;</span><br><span class="line">            max = nums[i];</span><br><span class="line">            root_val = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode(max);</span><br><span class="line">    root-&gt;left = dfs(nums, start, root_val);</span><br><span class="line">    root-&gt;right = dfs(nums, root_val+<span class="number">1</span>, end);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dfs(nums, <span class="number">0</span>, nums.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>668. Kth Smallest Number in Multiplication Table</title>
    <url>/2020/04/07/LeetCode_Cpp/0668._Kth_Smallest_Number_in_Multiplication_Table/</url>
    <content><![CDATA[<h1 id="668-Kth-Smallest-Number-in-Multiplication-Table"><a href="#668-Kth-Smallest-Number-in-Multiplication-Table" class="headerlink" title="668. Kth Smallest Number in Multiplication Table"></a>668. Kth Smallest Number in Multiplication Table</h1><p>难度:Hard</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><p>题目:<br><a href="https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/" target="_blank" rel="noopener">https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/</a></p>
<p>题意：</p>
<ol>
<li>给定一个m和n，表示生成m*n的矩阵，矩阵里面的值为a(i,j) = i * j</li>
<li>求这个矩阵所有数中第k小是哪个数</li>
</ol>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>思路：</p>
<ul>
<li>由于m，n，k都很大，因此不能用排序或者堆排序的方式进行解答</li>
<li>我们可以二分结果，因为结果肯定是在0到n*m之间的某个数</li>
<li>假设二分值是p，我们需要判断整个矩阵中小于p有多少个，只需要遍历一遍，根据p/i来判断第i行小于p有多少个，累加</li>
</ul>
<p>解法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line">    <span class="keyword">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kInversePairs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= k;j++) &#123;</span><br><span class="line">                s += a[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (s &gt;= MOD) &#123;</span><br><span class="line">                    s -= MOD;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j - i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    s -= a[i - <span class="number">1</span>][j - i];</span><br><span class="line">                    <span class="keyword">if</span> (s &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        s += MOD;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                a[i][j] = s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a[n][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>701. Insert into a Binary Search Tree</title>
    <url>/2020/04/07/LeetCode_Cpp/0701._Insert_into_a_Binary_Search_Tree/</url>
    <content><![CDATA[<h1 id="701-Insert-into-a-Binary-Search-Tree"><a href="#701-Insert-into-a-Binary-Search-Tree" class="headerlink" title="701. Insert into a Binary Search Tree"></a>701. Insert into a Binary Search Tree</h1><p> 难度: Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/</a></p>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 保证原始二叉搜索树中不存在新值。</span><br><span class="line"></span><br><span class="line">注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。</span><br><span class="line"></span><br><span class="line">例如, </span><br><span class="line"></span><br><span class="line">给定二叉搜索树:</span><br><span class="line"></span><br><span class="line">        4</span><br><span class="line">       &#x2F; \</span><br><span class="line">      2   7</span><br><span class="line">     &#x2F; \</span><br><span class="line">    1   3</span><br><span class="line"></span><br><span class="line">和 插入的值: 5</span><br><span class="line">你可以返回这个二叉搜索树:</span><br><span class="line"></span><br><span class="line">         4</span><br><span class="line">       &#x2F;   \</span><br><span class="line">      2     7</span><br><span class="line">     &#x2F; \   &#x2F;</span><br><span class="line">    1   3 5</span><br><span class="line">或者这个树也是有效的:</span><br><span class="line"></span><br><span class="line">         5</span><br><span class="line">       &#x2F;   \</span><br><span class="line">      2     7</span><br><span class="line">     &#x2F; \   </span><br><span class="line">    1   3</span><br><span class="line">         \</span><br><span class="line">          4</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">二分查找，记录父节点和大小关系</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    TreeNode* pre;</span><br><span class="line">    TreeNode* head = root;</span><br><span class="line">    <span class="keyword">int</span> side = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(root)&#123;</span><br><span class="line">        pre = root;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&gt;val)&#123;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">            side = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val&lt;val)&#123;</span><br><span class="line">            side = <span class="number">0</span>;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* node = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    <span class="keyword">if</span>(side==<span class="number">1</span>)</span><br><span class="line">        pre-&gt;left = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pre-&gt;right = node;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>715. Range Module</title>
    <url>/2020/04/07/LeetCode_Cpp/0715._Range_Module/</url>
    <content><![CDATA[<h1 id="715-Range-Module"><a href="#715-Range-Module" class="headerlink" title="715. Range Module"></a>715. Range Module</h1><p>难度:Hard</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><p>题目:<br><a href="https://leetcode.com/problems/range-module/" target="_blank" rel="noopener">https://leetcode.com/problems/range-module/</a></p>
<p>题意：</p>
<ol>
<li>设计一种数据结构</li>
<li>操作1：向该数据结构插入一个线段（的所有实数）</li>
<li>操作2：向该数据结构删除一个线段（的所有实数）</li>
<li>操作3：查询一个线段包含的所有实数是否都在这个数据结构中</li>
</ol>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>思路：</p>
<ul>
<li>线段与线段之间有三种关系，包含，相交，相离。插入一个线段，我们需要寻找可能包含和相交的线段来合并</li>
<li>假设插入的线段为[a,b)，我们需要在已有的线段中寻找包含和相交的线段。假设已有线段为[i,j)，当j&lt;a，这个线段肯定不需要判断。所以我们需要寻找左端点跟a相等，或者比a小的最大值。然后遍历，一个个线段判断，直到i &gt; b</li>
<li>我们需要一种数据结构，可以遍历，可以快速定位到比某个数小的最大值。平衡树满足我们的需求。</li>
<li>平衡树的key是线段的左端点，value是线段的右端点</li>
<li>剩下的操作就是线段合并和线段删除了，用笔模拟一下就可以得到结果</li>
</ul>
<p>解法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RangeModule</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; range;</span><br><span class="line">    RangeModule() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Range</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        Range(<span class="keyword">int</span> _x = <span class="number">0</span>, <span class="keyword">int</span> _y = <span class="number">0</span>) : x(_x), y(_y) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b ? b : a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (range.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            range[left] = right;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; forDelete;</span><br><span class="line">        it = range.upper_bound(left);</span><br><span class="line">        <span class="keyword">if</span> (it != range.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">            it--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (it != range.<span class="built_in">end</span>() &amp;&amp; it-&gt;first &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((it -&gt; second &gt;= right &amp;&amp; it -&gt; first &lt;= right) || (right &gt;= it -&gt; second &amp;&amp; left &lt;= it -&gt; second)) &#123;</span><br><span class="line">                forDelete.push_back(it -&gt; first);</span><br><span class="line">                left = <span class="built_in">min</span>(left, it -&gt; first);</span><br><span class="line">                right = <span class="built_in">max</span>(right, it -&gt; second);</span><br><span class="line">            &#125;</span><br><span class="line">            it++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; forDelete.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            range.erase(forDelete[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        range[left] = right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">queryRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (range.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">        it = range.upper_bound(left);</span><br><span class="line">        <span class="keyword">if</span> (it != range.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">            it--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (it -&gt; first &lt;= left &amp;&amp; it -&gt; second &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (range.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; forDelete;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Range&gt; forInsert;</span><br><span class="line">        it = range.upper_bound(left);</span><br><span class="line">            <span class="keyword">if</span> (it != range.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">            it--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (it != range.<span class="built_in">end</span>() &amp;&amp; it-&gt;first &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (it -&gt; first &gt;= left &amp;&amp; it -&gt; second &lt;= right) &#123;</span><br><span class="line">                forDelete.push_back(it-&gt;first);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (it -&gt; first &lt; left &amp;&amp; it -&gt; second &gt; right) &#123;</span><br><span class="line">                forDelete.push_back(it-&gt;first);</span><br><span class="line">                forInsert.push_back(Range(it -&gt; first, left));</span><br><span class="line">                forInsert.push_back(Range(right, it -&gt; second));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(it -&gt; first &lt; left &amp;&amp; it -&gt; second &gt;= left) &#123;</span><br><span class="line">                forDelete.push_back(it-&gt;first);</span><br><span class="line">                forInsert.push_back(Range(it -&gt; first, left));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (it -&gt; first &lt;= right &amp;&amp; it -&gt; second &gt; right) &#123;</span><br><span class="line">                forDelete.push_back(it-&gt;first);</span><br><span class="line">                forInsert.push_back(Range(right, it -&gt; second));</span><br><span class="line">            &#125; </span><br><span class="line">            it++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; forDelete.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            range.erase(forDelete[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; forInsert.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            range[forInsert[i].x] = forInsert[i].y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>793. Find K-th Smallest Pair Distance</title>
    <url>/2020/04/07/LeetCode_Cpp/0719._Find_K-th_Smallest_Pair_Distance/</url>
    <content><![CDATA[<h1 id="793-Find-K-th-Smallest-Pair-Distance"><a href="#793-Find-K-th-Smallest-Pair-Distance" class="headerlink" title="793. Find K-th Smallest Pair Distance"></a>793. Find K-th Smallest Pair Distance</h1><p>难度:Hard</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><p>题目:<br><a href="https://leetcode.com/problems/find-k-th-smallest-pair-distance/" target="_blank" rel="noopener">https://leetcode.com/problems/find-k-th-smallest-pair-distance/</a></p>
<p>题意：</p>
<ol>
<li>给定一个数组</li>
<li>计算数组总所有点对的差</li>
<li>求第k大是多少</li>
</ol>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>思路：</p>
<ul>
<li>暴力枚举肯定不行</li>
<li>换种思路，我们可以二分结果，数组所有点对的差的取值范围是1到最大值-最小值</li>
<li>二分结果，计算点对的差小于或等于这个结果有多少个，跟k比是大还是小</li>
<li>计算点对的差小于或等于某个值p有多少个，需要遍历数组，对于每个数a，判断数组中有多少个数小于或等于a+p，累加即可</li>
<li>复杂度是o(nlogn*logn)</li>
</ul>
<p>解法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findIndex</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (right - left &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= k) &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">judge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.size();i++) &#123;</span><br><span class="line">            ret += findIndex(nums, i, nums.size(), p + nums[i]) - i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        left--;</span><br><span class="line">        <span class="keyword">while</span> (right - left &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (judge(nums, mid) &gt;= k) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">smallestDistancePair</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">return</span> bsearch(nums, <span class="number">0</span>, nums[nums.size() - <span class="number">1</span>] - nums[<span class="number">0</span>], k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>739. Daily Temperatures</title>
    <url>/2020/04/07/LeetCode_Cpp/0739._Daily_Temperatures/</url>
    <content><![CDATA[<h1 id="739-Daily-Temperatures"><a href="#739-Daily-Temperatures" class="headerlink" title="739. Daily Temperatures"></a>739. Daily Temperatures</h1><p> 难度: Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/daily-temperatures/</a></p>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高的天数。如果之后都不会升高，请输入 0 来代替。</span><br><span class="line"></span><br><span class="line">例如，给定一个列表 temperatures &#x3D; [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</span><br><span class="line"></span><br><span class="line">提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的都是 [30, 100] 范围内的整数。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">暴力超时。</span><br><span class="line">采用递减栈思维，用栈存下表</span><br><span class="line">当前值小于栈顶值，入栈</span><br><span class="line">否则出站，出栈index的结果为当前处理下表和出栈下标的差值。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(temperatures.size()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> temperatures;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(temperatures.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; index;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temperatures.size();i++)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!index.empty() &amp;&amp; temperatures[i]&gt;temperatures[index.top()])&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = index.top();</span><br><span class="line">            index.pop();</span><br><span class="line">            ans[tmp]=i-tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        index.push(i);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>797. All Paths From Source to Target</title>
    <url>/2020/04/07/LeetCode_Cpp/0797._all_paths_from_source_to_target/</url>
    <content><![CDATA[<h1 id="797-All-Paths-From-Source-to-Target"><a href="#797-All-Paths-From-Source-to-Target" class="headerlink" title="797. All Paths From Source to Target"></a>797. All Paths From Source to Target</h1><p> 难度: Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode-cn.com/problems/all-paths-from-source-to-target/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/all-paths-from-source-to-target/</a><blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给一个有 n 个结点的有向无环图，找到所有从 0 到 n-1 的路径并输出（不要求按顺序）</span><br><span class="line"></span><br><span class="line">二维数组的第 i 个数组中的单元都表示有向图中 i 号结点所能到达的下一些结点（译者注：有向图是有方向的，即规定了a→b你就不能从b→a）空就是没有下一个结点了。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">输入: [[1,2], [3], [3], []] </span><br><span class="line">输出: [[0,1,3],[0,2,3]] </span><br><span class="line">解释: 图是这样的:</span><br><span class="line">0---&gt;1</span><br><span class="line">|    |</span><br><span class="line">v    v</span><br><span class="line">2---&gt;3</span><br><span class="line">这有两条路: 0 -&gt; 1 -&gt; 3 和 0 -&gt; 2 -&gt; 3.</span><br><span class="line">提示:</span><br><span class="line"></span><br><span class="line">结点的数字会在范围 [2, 15] 内。</span><br><span class="line">你可以把路径以任意顺序输出，但在路径内的结点的顺序必须保证。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">深搜二叉树，记录路径，当i&#x3D;&#x3D;graph.size()-1，停止。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==target)&#123;</span><br><span class="line">        ans.push_back(path);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;graph[i].size();j++)&#123;</span><br><span class="line">        path.push_back(graph[i][j]);</span><br><span class="line">        dfs(graph[i][j], path, target, ans, graph);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">allPathsSourceTarget</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    path.push_back(<span class="number">0</span>);</span><br><span class="line">    dfs(<span class="number">0</span>, path, graph.size()<span class="number">-1</span>, ans, graph);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>841. Keys and Rooms</title>
    <url>/2020/04/07/LeetCode_Cpp/0841._Keys_and_Rooms/</url>
    <content><![CDATA[<h1 id="841-Keys-and-Rooms"><a href="#841-Keys-and-Rooms" class="headerlink" title="841. Keys and Rooms"></a>841. Keys and Rooms</h1><p> 难度: Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/keys-and-rooms/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/keys-and-rooms/submissions/</a></p>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有 N 个房间，开始时你位于 0 号房间。每个房间有不同的号码：0，1，2，...，N-1，并且房间里可能有一些钥匙能使你进入下一个房间。</span><br><span class="line"></span><br><span class="line">在形式上，对于每个房间 i 都有一个钥匙列表 rooms[i]，每个钥匙 rooms[i][j] 由 [0,1，...，N-1] 中的一个整数表示，其中 N &#x3D; rooms.length。 钥匙 rooms[i][j] &#x3D; v 可以打开编号为 v 的房间。</span><br><span class="line"></span><br><span class="line">最初，除 0 号房间外的其余所有房间都被锁住。</span><br><span class="line"></span><br><span class="line">你可以自由地在房间之间来回走动。</span><br><span class="line"></span><br><span class="line">如果能进入每个房间返回 true，否则返回 false。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: [[1],[2],[3],[]]</span><br><span class="line">输出: true</span><br><span class="line">解释:  </span><br><span class="line">我们从 0 号房间开始，拿到钥匙 1。</span><br><span class="line">之后我们去 1 号房间，拿到钥匙 2。</span><br><span class="line">然后我们去 2 号房间，拿到钥匙 3。</span><br><span class="line">最后我们去了 3 号房间。</span><br><span class="line">由于我们能够进入每个房间，我们返回 true。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：[[1,3],[3,0,1],[2],[0]]</span><br><span class="line">输出：false</span><br><span class="line">解释：我们不能进入 2 号房间。</span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; rooms.length &lt;&#x3D; 1000</span><br><span class="line">0 &lt;&#x3D; rooms[i].length &lt;&#x3D; 1000</span><br><span class="line">所有房间中的钥匙数量总计不超过 3000。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">广搜遍历可以到达房间, 记录开启房间个数。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canVisitAllRooms</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rooms)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; keys;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">unlocked</span><span class="params">(rooms.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">    keys.push(<span class="number">0</span>);</span><br><span class="line">    unlocked[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> locked=rooms.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!keys.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> key = keys.front();</span><br><span class="line">        keys.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rooms[key].size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = rooms[key][i];</span><br><span class="line">            <span class="keyword">if</span>(unlocked[tmp]==<span class="literal">false</span>)&#123;</span><br><span class="line">                keys.push(tmp);</span><br><span class="line">                unlocked[tmp]=<span class="literal">true</span>;</span><br><span class="line">                locked--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(locked==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>814. Binary Tree Pruning</title>
    <url>/2020/04/07/LeetCode_Cpp/0814._binary_tree_pruning/</url>
    <content><![CDATA[<h1 id="814-Binary-Tree-Pruning"><a href="#814-Binary-Tree-Pruning" class="headerlink" title="814. Binary Tree Pruning"></a>814. Binary Tree Pruning</h1><p> 难度: Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><a href="https://leetcode-cn.com/problems/binary-tree-pruning/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-pruning/</a><blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定二叉树根结点 root ，此外树的每个结点的值要么是 0，要么是 1。</span><br><span class="line"></span><br><span class="line">返回移除了所有不包含 1 的子树的原二叉树。</span><br><span class="line"></span><br><span class="line">( 节点 X 的子树为 X 本身，以及所有 X 的后代。)</span><br><span class="line"></span><br><span class="line">示例1:</span><br><span class="line">输入: [1,null,0,0,1]</span><br><span class="line">输出: [1,null,0,null,1]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">遍历二叉树，切除左右子树中无1的子树。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> left = dfs(root-&gt;left);</span><br><span class="line">    <span class="keyword">bool</span> right = dfs(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span>(left==<span class="literal">false</span>)</span><br><span class="line">        root-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(right==<span class="literal">false</span>)</span><br><span class="line">        root-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;val==<span class="number">1</span>||left||right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">pruneTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>877. Stone Game</title>
    <url>/2020/04/07/LeetCode_Cpp/0877._Stone_Game/</url>
    <content><![CDATA[<h1 id="877-Stone-Game"><a href="#877-Stone-Game" class="headerlink" title="877. Stone Game"></a>877. Stone Game</h1><p> 难度: Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><blockquote>
<p>原题连接</p>
</blockquote>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/stone-game/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/stone-game/</a></p>
<blockquote>
<p>内容描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。</span><br><span class="line"></span><br><span class="line">游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。</span><br><span class="line"></span><br><span class="line">亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。</span><br><span class="line"></span><br><span class="line">假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：[5,3,4,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。</span><br><span class="line">假设他取了前 5 颗，这一行就变成了 [3,4,5] 。</span><br><span class="line">如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。</span><br><span class="line">如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。</span><br><span class="line">这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h2><blockquote>
<p>思路 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp: </span><br><span class="line">dp[i][j]表示从i-j之间alex和lee拿的总数差</span><br><span class="line">dp[i][j]&gt;0: alex赢，否则lee赢</span><br><span class="line">从i&#x3D;&#x3D;j时：dp[i][i]为piles[i]</span><br><span class="line">i!&#x3D;j时：dp[i][j] &#x3D; max(piles[i]-dp[i+1][j], piles[j]-dp[i][j-1])</span><br><span class="line">两个人交错拿石子，所以上一步的赢为下一步的输，所以本次取减去上一次的差，为本次过后总的比分，取较大。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">stoneGame</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = piles.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(len, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        dp[i][i]=piles[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len-i;j++)&#123;</span><br><span class="line">            dp[j][j+i]=max(piles[j]-dp[j+<span class="number">1</span>][j+i], piles[j+i]-dp[j][j+i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][len<span class="number">-1</span>]&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>945. Minimum Increment to Make Array Unique</title>
    <url>/2020/04/07/LeetCode_Cpp/0945._Minimum_Increment_to_Make_Array_Unique/</url>
    <content><![CDATA[<h1 id="945-Minimum-Increment-to-Make-Array-Unique"><a href="#945-Minimum-Increment-to-Make-Array-Unique" class="headerlink" title="945. Minimum Increment to Make Array Unique"></a>945. Minimum Increment to Make Array Unique</h1><p>难度:Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><p>题目:<br><a href="https://leetcode.com/problems/minimum-increment-to-make-array-unique/" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-increment-to-make-array-unique/</a></p>
<p>题意：</p>
<ol>
<li>给定一个数组</li>
<li>每次操作，数组中的元素只能+1</li>
<li>求最少多少次操作，数组中所有元素都不相同</li>
</ol>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>思路：</p>
<ul>
<li>注意看题意，数组中的元素只能+1，所以数组需要先排序，从小到大，因为小的数处理好，大的数不管怎么+1都不会冲突</li>
<li>从小到大循环，需要操作的只可能是跟前一个相同的，或者比前一个小(因为前一个也有可能跟前前一个相同)，因此我们跟前面一个比较，如果比前面一个大，那么啥事都没，如果跟前一个相同，或者比前一个小，那么我们就把他加到比前面一个数大1即可</li>
</ul>
<p>解法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minIncrementForUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        sort(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i= <span class="number">1</span>;i &lt; A.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &lt;= A[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                ret += A[i - <span class="number">1</span>] - A[i] + <span class="number">1</span>;</span><br><span class="line">                A[i] = A[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>947. Most Stones Removed with Same Row or Column</title>
    <url>/2020/04/07/LeetCode_Cpp/0947._Most_Stones_Removed_with_Same_Row_or_Column/</url>
    <content><![CDATA[<h1 id="947-Most-Stones-Removed-with-Same-Row-or-Column"><a href="#947-Most-Stones-Removed-with-Same-Row-or-Column" class="headerlink" title="947. Most Stones Removed with Same Row or Column"></a>947. Most Stones Removed with Same Row or Column</h1><p>难度:Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><p>题目:<br><a href="https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/" target="_blank" rel="noopener">https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/</a></p>
<p>题意：</p>
<ol>
<li>给平面上n个点</li>
<li>每次操作都可以挑选其中x坐标相等或者y坐标相等的两个点，划掉一个</li>
<li>求最多能划掉多少个</li>
</ol>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>思路：</p>
<ul>
<li>我们平面上的点想象成图论上的一个几点，如果两个点之间，x坐标相等或者y坐标相等，那么连边</li>
<li>题目就可以转为，求这个图的联通分量，因为只要两个团不联通，是无论如何无法进行操作的，所以剩下的个数必是联通分量的个数</li>
<li>剩下就是dfs即可</li>
</ul>
<p>解法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> flag[<span class="number">1010</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; stones, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; stones.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stones[idx][<span class="number">0</span>] != stones[i][<span class="number">0</span>] &amp;&amp; stones[idx][<span class="number">1</span>] != stones[i][<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            flag[i] = <span class="literal">true</span>;</span><br><span class="line">            dfs(stones, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeStones</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(flag, <span class="literal">false</span>, <span class="keyword">sizeof</span>(flag));</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; stones.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!flag[i]) &#123;</span><br><span class="line">                ret++;</span><br><span class="line">                dfs(stones, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stones.<span class="built_in">size</span>() - ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>949. Largest Time for Given Digits</title>
    <url>/2020/04/07/LeetCode_Cpp/0949._Largest_Time_for_Given_Digits/</url>
    <content><![CDATA[<h1 id="949-Largest-Time-for-Given-Digits"><a href="#949-Largest-Time-for-Given-Digits" class="headerlink" title="949. Largest Time for Given Digits"></a>949. Largest Time for Given Digits</h1><p>难度:Easy</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><p> 题目:<br><a href="https://leetcode.com/problems/largest-time-for-given-digits/" target="_blank" rel="noopener">https://leetcode.com/problems/largest-time-for-given-digits/</a></p>
<p>题意：</p>
<ol>
<li>给4个0-9的数字</li>
<li>求能组成最大的时间，时间格式是hh:mm</li>
</ol>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>思路：</p>
<ul>
<li>枚举所有的hh:mm的格式</li>
<li>判断是否符合时间的要求，hh&lt;24，mm&lt;60</li>
<li>寻找最大的时间</li>
</ul>
<p>解法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestTimeFromDigits</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ret = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span>;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (A[i] * <span class="number">10</span> + A[j] &gt;= <span class="number">24</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; <span class="number">4</span>;k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == k || j == k) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>;l &lt; <span class="number">4</span>;l++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (i == l || j == l || k == l) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="built_in">string</span> s = <span class="string">""</span>;</span><br><span class="line">                        <span class="keyword">if</span> (A[k] * <span class="number">10</span> + A[l] &gt;= <span class="number">60</span>) <span class="keyword">continue</span>;</span><br><span class="line">                        s = <span class="built_in">string</span>(<span class="string">""</span>) + <span class="keyword">char</span>(A[i] + <span class="string">'0'</span>) + <span class="keyword">char</span>(A[j] + <span class="string">'0'</span>) + <span class="string">":"</span> + <span class="keyword">char</span>(A[k] + <span class="string">'0'</span>) + <span class="keyword">char</span>(A[l] + <span class="string">'0'</span>);</span><br><span class="line">                        <span class="keyword">if</span> (ret &lt; s) &#123;</span><br><span class="line">                            ret = s;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>946. Validate Stack Sequences</title>
    <url>/2020/04/07/LeetCode_Cpp/0946._Validate_Stack_Sequences/</url>
    <content><![CDATA[<h1 id="946-Validate-Stack-Sequences"><a href="#946-Validate-Stack-Sequences" class="headerlink" title="946. Validate Stack Sequences"></a>946. Validate Stack Sequences</h1><p>难度:Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><p>题目:<br><a href="https://leetcode.com/problems/validate-stack-sequences/" target="_blank" rel="noopener">https://leetcode.com/problems/validate-stack-sequences/</a></p>
<p>题意：</p>
<ol>
<li>两个数组</li>
<li>问入栈顺序为pushed数组，是否可能出栈顺序为popped数组</li>
</ol>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>思路：</p>
<ul>
<li>模拟即可。我们把新建一个栈，按照pushed数组的顺序一个一个丢进去，并且，检查popped数组前面的数组，如果可以弹出就弹出。到最后判断栈是否为空即可</li>
</ul>
<p>解法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stack</span>[<span class="number">1010</span>];</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validateStackSequences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pushed, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; pushed.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="built_in">stack</span>[n++] = pushed[i];</span><br><span class="line">            <span class="keyword">while</span> (n &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">stack</span>[n - <span class="number">1</span>] == popped[j]) &#123;</span><br><span class="line">                n--;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>948. Bag of Tokens</title>
    <url>/2020/04/07/LeetCode_Cpp/0948._Bag_of_Tokens/</url>
    <content><![CDATA[<h1 id="948-Bag-of-Tokens"><a href="#948-Bag-of-Tokens" class="headerlink" title="948. Bag of Tokens"></a>948. Bag of Tokens</h1><p>难度:Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><p>题目:<br><a href="https://leetcode.com/problems/bag-of-tokens/" target="_blank" rel="noopener">https://leetcode.com/problems/bag-of-tokens/</a></p>
<p>题意：</p>
<ol>
<li>玩个游戏，有n个游戏币，游戏币有权值，初始能量为P</li>
<li>每个游戏币只能被选择一次，每次只能在两种操作中选择其中一个操作<ol>
<li>如果当前能量大于或等于该游戏币的权值，那么可以将能量减掉该游戏币的权值，分数+1</li>
<li>如果当前分数大于或等于1，那么可以将分数-1，将能量加上该游戏币的权值</li>
</ol>
</li>
<li>问最多能得到多少分</li>
</ol>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>思路：</p>
<ul>
<li>假设只有第一种操作，那么这个题就是个贪心题，排序，从小到大选择游戏币，直到能量用完</li>
<li>第二种操作，相当于找一个权重小于或等于P的游戏币（命名为游戏币B），跟另一个游戏币（命名为游戏币A）同时去掉，然后能量加上游戏币A的能量</li>
<li>游戏币A很容易想，肯定选择权重最大的那个，那游戏币B要挑哪个呢？</li>
<li>答案是任意挑，因为对结果无影响。大家可以想一想，贪心算法相当于要求A[0]+A[1]+…A[k]&lt;=P，k的最大，假设我们挑中了游戏币B来对冲游戏币A，那么下一轮的贪心问题就是A[0]+A[1]+…+A[k]-values(B)&lt;=P+(values(A)-values(B))，可以看出，values(B)是被消去的</li>
<li>所以解法就是，枚举所有的操作，每次操作把最小的置换最大的，剩下的就是求解贪心问题A[0]+A[1]+…A[k]&lt;=P</li>
</ul>
<p>解法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> sum[<span class="number">10010</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sum[idx];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bagOfTokensScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tokens, <span class="keyword">int</span> P)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tokens.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        sort(tokens.<span class="built_in">begin</span>(), tokens.<span class="built_in">end</span>());</span><br><span class="line">        sum[<span class="number">0</span>] = tokens[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; tokens.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + tokens[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = tokens.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (res &lt;= right &amp;&amp; getSum(res) - getSum(left - <span class="number">1</span>) &lt;= P) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = ret &gt; res - left ? ret : res - left;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (P &gt;= tokens[left]) &#123;</span><br><span class="line">                P += tokens[right--] - tokens[left++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>951. Flip Equivalent Binary Trees</title>
    <url>/2020/04/07/LeetCode_Cpp/0951._Flip_Equivalent_Binary_Trees/</url>
    <content><![CDATA[<h1 id="951-Flip-Equivalent-Binary-Trees"><a href="#951-Flip-Equivalent-Binary-Trees" class="headerlink" title="951. Flip Equivalent Binary Trees"></a>951. Flip Equivalent Binary Trees</h1><p>难度:Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><p>题目:<br><a href="https://leetcode.com/problems/flip-equivalent-binary-trees/" target="_blank" rel="noopener">https://leetcode.com/problems/flip-equivalent-binary-trees/</a></p>
<p>题意：</p>
<ol>
<li>给两棵树</li>
<li>两棵树可以做交换左右子树的操作</li>
<li>求两棵树是否能通过某些操作，使得两棵树一模一样</li>
</ol>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>思路：</p>
<ul>
<li>递归判断<ul>
<li>两个都为空，返回true</li>
<li>一个为空，返回false</li>
<li>根的值不同，返回false</li>
<li>递归判断左子树和右子树，判断左右两棵对应的子树是否为true，或者交换下子树，判断是否为true，返回true</li>
<li>其他情况返回false</li>
</ul>
</li>
</ul>
<p>解法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">flipEquiv</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root1 &amp;&amp; !root2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!root1 || !root2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (root1-&gt;val != root2-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flipEquiv(root1-&gt;left, root2-&gt;left) &amp;&amp; flipEquiv(root1-&gt;right, root2-&gt;right)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flipEquiv(root1-&gt;left, root2-&gt;right) &amp;&amp; flipEquiv(root1-&gt;right, root2-&gt;left)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>952. Largest Component Size by Common Factor</title>
    <url>/2020/04/07/LeetCode_Cpp/0952._Largest_Component_Size_by_Common_Factor/</url>
    <content><![CDATA[<h1 id="952-Largest-Component-Size-by-Common-Factor"><a href="#952-Largest-Component-Size-by-Common-Factor" class="headerlink" title="952. Largest Component Size by Common Factor"></a>952. Largest Component Size by Common Factor</h1><p>难度:Hard</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><p>题目:<br><a href="https://leetcode.com/problems/largest-component-size-by-common-factor/" target="_blank" rel="noopener">https://leetcode.com/problems/largest-component-size-by-common-factor/</a></p>
<p>题意：</p>
<ol>
<li>给n个数</li>
<li>将n个数设定为n个节点，如果两个数之间的最大公约数大于1，则连边</li>
<li>求图的最大联通分量的大小</li>
</ol>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>思路：</p>
<ul>
<li>n的数据量高达2w，如果两两节点计算最大公约数，复杂度是o(n^2logn)</li>
<li>我们可以使用素数筛法来取出需要两两画线的数列，比如：取出被2整除的数，被3整除的数。。。</li>
<li>求图的最大联通分量可以用并查集来做</li>
<li>过程是这样的<ul>
<li>枚举所有的素数</li>
<li>假设当前枚举的素数是i</li>
<li>从n个数中取出所有能被i整除的数</li>
<li>假设有m个数，那么第1个数跟第m-1个数都跟第0个数做下合并</li>
<li>枚举结束后，求最大的集合的大小</li>
</ul>
</li>
<li>素数筛法的复杂度是o(nlogn)，这里需要做下优化，如果枚举每个素数都得从n个数寻找能被它整除的数，复杂度还是o(nk)，k是素数的个数，但如果我们把n个数映射到1-100000的数组中，就可以套用素数筛法了</li>
</ul>
<p>解法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> isPrime[<span class="number">100100</span>];</span><br><span class="line"><span class="keyword">bool</span> hasValue[<span class="number">100100</span>];</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">100100</span>];</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span>[<span class="number">100100</span>];</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> inited = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(isPrime, <span class="literal">true</span>, <span class="keyword">sizeof</span>(isPrime));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">100000</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isPrime[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i;j &lt;= <span class="number">100000</span>;j += i) &#123;</span><br><span class="line">                isPrime[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find_set</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">while</span> (p[x] != x) &#123;</span><br><span class="line">            temp.push_back(x);</span><br><span class="line">            x = p[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; temp.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            p[temp[i]] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">union_set</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = find_set(x);</span><br><span class="line">        y = find_set(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p[x] = y;</span><br><span class="line">        <span class="built_in">size</span>[y] += <span class="built_in">size</span>[x];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> prime)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = prime;i &lt;= <span class="number">100000</span>;i += prime) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasValue[i]) &#123;</span><br><span class="line">                ret.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestComponentSize</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!inited) &#123;</span><br><span class="line">            init();</span><br><span class="line">            inited = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(hasValue, <span class="literal">false</span>, <span class="keyword">sizeof</span>(hasValue));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; A.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            hasValue[A[i]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">100000</span>;i++) &#123;</span><br><span class="line">            p[i] = i;</span><br><span class="line">            <span class="built_in">size</span>[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">100000</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isPrime[i]) &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp = <span class="built_in">find</span>(i);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (temp.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; temp.<span class="built_in">size</span>();j++) &#123;</span><br><span class="line">                    union_set(temp[<span class="number">0</span>], temp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">100000</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasValue[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> x = find_set(i);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">size</span>[x] &gt; ret) &#123;</span><br><span class="line">                ret = <span class="built_in">size</span>[x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>950. Reveal Cards In Increasing Order</title>
    <url>/2020/04/07/LeetCode_Cpp/0950._Reveal_Cards_In_Increasing_Order/</url>
    <content><![CDATA[<h1 id="950-Reveal-Cards-In-Increasing-Order"><a href="#950-Reveal-Cards-In-Increasing-Order" class="headerlink" title="950. Reveal Cards In Increasing Order"></a>950. Reveal Cards In Increasing Order</h1><p>难度:Medium</p>
<h2 id="刷题内容"><a href="#刷题内容" class="headerlink" title="刷题内容"></a>刷题内容</h2><p>题目:<br><a href="https://leetcode.com/problems/reveal-cards-in-increasing-order/" target="_blank" rel="noopener">https://leetcode.com/problems/reveal-cards-in-increasing-order/</a></p>
<p>题意：</p>
<ol>
<li>有这么个操作</li>
<li>将牌的第一张拿出来，把下一张放到底部</li>
<li>重复这种操作</li>
<li>到最后拿出来的是一个严格递增数列</li>
<li>求牌开始的顺序</li>
</ol>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>思路：</p>
<ul>
<li>反过来操作即可</li>
<li>对牌排个序，备选</li>
<li>把底部的牌放到第一张，从备选的牌中选择最大的一张放在顶部</li>
<li>重复这种操作</li>
</ul>
<p>解法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">list</span>[<span class="number">10000</span>];</span><br><span class="line">    <span class="keyword">int</span> front, back;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">list</span>[front++] = val;</span><br><span class="line">        <span class="keyword">if</span> (front == <span class="number">10000</span>) &#123;</span><br><span class="line">            front = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="built_in">list</span>[back];</span><br><span class="line">        back++;</span><br><span class="line">        <span class="keyword">if</span> (back == <span class="number">10000</span>) &#123;</span><br><span class="line">            back = <span class="number">0</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">deckRevealedIncreasing</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; deck)</span> </span>&#123;</span><br><span class="line">        front = back = <span class="number">0</span>;</span><br><span class="line">        sort(deck.<span class="built_in">begin</span>(), deck.<span class="built_in">end</span>());</span><br><span class="line">        add(deck[deck.<span class="built_in">size</span>() - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = deck.<span class="built_in">size</span>() - <span class="number">2</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">remove</span>();</span><br><span class="line">            add(x);</span><br><span class="line">            x = deck[i];</span><br><span class="line">            add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">int</span> i = back;</span><br><span class="line">        <span class="keyword">while</span> (i != front) &#123;</span><br><span class="line">            ret.push_back(<span class="built_in">list</span>[i]);</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">10000</span>) &#123;</span><br><span class="line">                i = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(ret.<span class="built_in">begin</span>(), ret.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode_Cpp/README</title>
    <url>/2020/04/07/LeetCode_Cpp/README/</url>
    <content><![CDATA[<h1 id="Leetcode-solutions-and-summary"><a href="#Leetcode-solutions-and-summary" class="headerlink" title="Leetcode solutions and summary!"></a>Leetcode solutions and summary!</h1>]]></content>
  </entry>
</search>
